{
    "id": "3244279",
    "text": "In computer programming, the block starting symbol (abbreviated to .bss or bss) is the portion of an object file, executable, or assembly language code that contains statically-allocated variables that are declared but have not been assigned a value yet. It is often referred to as the \"bss section\" or \"bss segment\". Typically only the length of the bss section, but no data, is stored in the object file. The program loader allocates memory for the bss section when it loads the program. By placing variables with no value in the .bss section, instead of the .data or .rodata section which require initial value data, the size of the object file is reduced. On some platforms, some or all of the bss section is initialized to zeroes. Unix-like systems and Windows initialize the bss section to zero, allowing C and C++ statically-allocated variables initialized to values represented with all bits zero to be put in the bss segment. Operating systems may use a technique called zero-fill-on- demand to efficiently implement the bss segment. In embedded software, the bss segment is mapped into memory that is initialized to zero by the C run-time system before `main()` is entered. Some C run-time systems may allow part of the bss segment not to be initialized; C variables must explicitly be placed into that portion of the bss segment. On some computer architectures, the application binary interface also supports an sbss segment for \"small data\". Typically, these data items can be accessed using shorter instructions that may only be able to access a certain range of addresses. Architectures supporting thread-local storage might use a tbss section for uninitialized, static data marked as thread-local. ==Origin== This shows the typical layout of a simple computer's program memory with the text, various data, and stack and heap sections. Historically, BSS (from Block Started by Symbol) is a pseudo-operation in UA-SAP (United Aircraft Symbolic Assembly Program), the assembler developed in the mid-1950s for the IBM 704 by Roy Nutt, Walter Ramshaw, and others at United Aircraft Corporation.Network Dictionary. Javvin Press, 2007, p. 70.Coding for the MIT-IBM 704 Computer October 1957, p. V-10 The BSS keyword was later incorporated into FORTRAN Assembly Program (FAP) and Macro Assembly Program (MAP), IBM's standard assemblers for its 709 and 7090/94 computers. It defined a label (i.e. symbol) and reserved a block of uninitialized space for a given number of words. In this situation BSS served as a shorthand in place of individually reserving a number of separate smaller data locations. Some assemblers support a complementary or alternative directive BES, for Block Ended by Symbol, where the specified symbol corresponds to the end of the reserved block. ==BSS in C== In C, statically- allocated objects without an explicit initializer are initialized to zero (for arithmetic types) or a null pointer (for pointer types). Implementations of C typically represent zero values and null pointer values using a bit pattern consisting solely of zero-valued bits (though this is not required by the C standard). Hence, the BSS segment typically includes all uninitialized objects (both variables and constants) declared at file scope (i.e., outside any function) as well as uninitialized static local variables (local variables declared with the `static` keyword); static local constants must be initialized at declaration, however, as they do not have a separate declaration, and thus are typically not in the BSS section, though they may be implicitly or explicitly initialized to zero. An implementation may also assign statically-allocated variables and constants initialized with a value consisting solely of zero-valued bits to the BSS section. Peter van der Linden, a C programmer and author, says, \"Some people like to remember it as 'Better Save Space.' Since the BSS segment only holds variables that don't have any value yet, it doesn't actually need to store the image of these variables. The size that BSS will require at runtime is recorded in the object file, but BSS (unlike the data segment) doesn't take up any actual space in the object file.\"Peter van der Linden, Expert C Programming: Deep C Secrets, Prentice Hall 1994, p. 141 ==BSS in Fortran== In Fortran, common block variables are allocated in this segment.How does Fortran 77 allocate common- block variables? Some compilers may, for 64-bit instruction sets, limit offsets, in instructions that access this segment, to 32 bits, limiting its size to 2 GB or 4 GB. Also, note that Fortran does not require static data to be initialized to zero. On those systems where the bss segment is initialized to zero, putting common block variables and other static data into that segment guarantees that it will be zero, but for portability, programmers should not depend on that. ==See also== * Linker (computing) * Data segment * Code segment * Uninitialized variable ==References== * Category:Executable file formats Category:Memory management Assembly language Category:Programming language implementation de:Datensegment#BSS ",
    "title": ".bss"
}