{
    "id": "20504129",
    "text": "UBIFS (UBI File System, more fully Unsorted Block Image File System) is a flash file system for unmanaged flash memory devices. UBIFS works on top of a UBI (unsorted block image) layer, which is itself on top of a memory technology device (MTD) layer. The file system is developed by Nokia engineers with help of the University of Szeged, Hungary. Development began in earnest in 2007, with the first stable release made to Linux kernel 2.6.27 in October 2008. Two major differences between UBIFS and JFFS2 are that UBIFS supports write caching, and UBIFS errs on the pessimistic side of free space calculation. UBIFS tends to perform better than JFFS2 for large NAND FLASH devices. This is a consequence of the UBIFS design goals: faster mounting, quicker access to large files, and improved write speeds. UBIFS also preserves or improves upon JFFS2's on-the-fly compression, recoverability and power fail tolerance. UBIFS's on-the-fly data compression allows zlib (deflate algorithm), LZO or Zstandard. UBIFS stores indexes in flash whereas JFFS2 stores filesystem indexes in memory. This directly impacts the scalability of JFFS2 as the tables must be rebuilt every time the volume is mounted. Also, the JFFS2 tables may consume enough system RAM that some images may be unusable. == UBI == UBI (Unsorted Block Images) is an erase block management layer for flash memory devices. UBI serves two purposes, tracking NAND flash bad blocks and providing wear leveling. Wear leveling spreads the erases and writes across the entire flash device. UBI presents logical erase blocks to higher layers and maps these to physical erase blocks. UBI was written specifically for UBIFS so that UBIFS does not have to deal with wear leveling and bad blocks. However, UBI may also be useful with squashfs and NAND flash; squashfs is not aware of NAND flash bad blocks. UBI's documentation explains that it is not a complete flash translation layer (FTL). Although a FTL also handles bad blocks and wear leveling, the interface a FTL provides is a block device with small (typically 512 byte) sectors that can be written completely independently. In contrast, UBI's interface directly exposes erase blocks and programmable pages (which are different sizes, and much larger than typical block device sectors), and filesystems that use UBI must be aware of the sizes and restrictions on how blocks must be erased before being written. UBI is in some ways analogous to a Logical Volume Manager. In typical usage, rather than partitioning flash into fixed regions, a single UBI device spans the entire flash (except for perhaps a few pages in fixed locations reserved for the bootloader), and multiple volumes are created within the UBI device. This allows wear-leveling to be spread across the whole flash, even if some volumes are written more frequently than others. UBI volumes can be static (which contain a whole file or image written once and protected by CRC-32 by UBI) or dynamic (which contain a read-write filesystem that is responsible for its own data integrity). The only filesystem that directly supports UBI is UBIFS, but using `gluebi` it's possible to emulate a MTD device, which can then be used to run other flash filesystems like JFFS2 and YAFFS, and using `ubiblk` it's possible to emulate block devices, which can run common filesystems like Ext4. === Fastmap === UBI was augmented in Linux 3.7 with fastmap support. Fastmap maintains an on-disk version of information previously created in memory by scanning the entire flash device. The code falls back to the previous mechanism of a full scan on failures and older UBI systems will simply ignore the fastmap information. == See also == * List of file systems * Comparison of file systems == References == == External links == * Home page * University of Szeged: UBIFS * UBIFS experiments on the XO Laptop (One Laptop per Child) * UBIFS file system Category:Embedded Linux Category:Flash file systems supported by the Linux kernel Category:Free special-purpose file systems ",
    "title": "UBIFS"
}