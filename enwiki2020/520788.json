{
    "id": "520788",
    "text": "Helix is a database management system for the Apple Macintosh platform, created in 1983. Helix uses a graphical \"programming language\" to add logic to its applications, allowing non-programmers to construct sophisticated applications. The Helix was the first multiuser database on any PC platform, the first object-based, visual programming tool and the first relational database on a PC platform. ==History== Originally created by Odesta Corporation of Northbrook, IL in 1983 on the original Macintosh, Helix debuted to rave reviews when it was first released in late 1984. At that time the Mac only supported 440kB floppy disks as storage. Users initial ran Helix from a floppy disk with Helix installed on the \"system disk,\" which was where the operating system lived before the age of hard disk storage began. This configuration left little room for applications or data. It was assumed that users would add a second floppy for any sort of real-world use, with the OS and Helix on one floppy, and data on another. In spite of these initial limitations, Helix was already a very powerful and fully relational database that migrated easily as machines became faster and more powerful and storage options evolved to the cavernous tools taken for granted today. In May 1986, Odesta released Double Helix. The main new feature set allowed for the construction of custom menus and menu bars, resulting in \"stand-alone\" applications. In comparison, the original Helix produced applications that were clearly running within Helix, much as a Microsoft Word document is clearly running \"inside Word\". Released as a part of a larger suite of software, the Helix suite also included a stand-alone runtime version known as RunTime Helix which would allow users to run Double Helix applications without the full version installed, as well as MultiUser Helix which operated in a client\u2013server fashion. Upgrades to the Helix product line were continuous during the 1980s, but the company spent a tremendous amount of time and money working on a version known as Remote Helix which ran the basic Helix development system on top of VAX based databases. The idea was to offer a Mac- like experience on \"big iron\" systems, a common theme in the early 1990s. The company also released a number of related tools, GeoQuery and Data Desk, for analyzing databases. However it wasn't long before the average Mac could outperform a minicomputer, the popularity of the VAX faded, and the product was never a major success. In 1992 Odesta split up, with the original Helix applications being spun off. Double Helix re-emerged as Helix Express at Helix Technologies, marketed as a performance leader as opposed to \"easy to use\". Unfortunately, the parent company became entangled in an unrelated but costly legal battle, and Helix languished. In 1998, Helix Technologies was purchased by The Chip Merchant, a San Diego-based memory vendor, who released a major upgrade in 2000, adding TCP/IP capabilities to Helix Client/Server and improving the performance of the entire product line significantly. However, falling memory prices and a slumping economy combined to drive The Chip Merchant into bankruptcy in 2002, sending Helix into legal limbo. It was purchased in 2004 by two of the people who were running its day-to-day operations, Gil Numeroff and Matt Strange, with financial backing from an unnamed businessman and long-time Helix user, forming a new company: QSA ToolWorks. QSA brought Helix co-creator Larry Atkin back into the Helix fold and later brought back Steve Keyser, the original architect of MultiUser Helix. Dubbed the Helix Recovery Team, this new management and programming team began the task of rewriting the Classic Helix products to run natively under Mac OS X. The OS X Helix Server, along with three native diagnostic and maintenance tools, shipped in December 2005. One month later, Apple announced the first products based on their switch from PowerPC to Intel processors, causing QSA to have to \"switch gears\" and begin the process of converting their code to Universal Binary format. This forced a conversion from the CodeWarrior IDE to Xcode, after which they produced Intel-native releases of their three \"end user\" products. Early versions (known as \"Preview Releases\") were feature incomplete and unstable, but frequent updates (five in 2008 alone) addressed these issues. Nine more updates in 2009 and 2010 focused on completing the feature set, eradicating remaining bugs and improving performance. At the same time, QSA started work on bringing the Helix IDE (known as \"Helix RADE\") to OS X. Originally announced in December 2009 the project went by the code name of Europa, as an oblique reference to the movie 2010.http://www.qsatoolworks.com/tlw/2009/dec31.html In June 2011, QSA began shipping \u2033Preliminary Releases\u2033 \u2014 versions with some, but not all of the features ported to OS X.http://www.qsatoolworks.com/tlw/2011/jun10.html The porting of features continued through to completion in June 2013.http://www.qsatoolworks.com/tlw/2013/jun10.html ==Description== A Helix project is known as a Collection, a \"document\" created by Helix RADE (which stands for \"Rapid Application Development Environment\"). It is represented in the system by a sort of \"pseudo-desktop\" similar to the Macintosh Finder. A collection may contain thousands of individual databases (also known as relations or tables). Helix applications only open one Collection at a time. However, licenses can be purchased to allow access to numerous collections simultaneously, limited primarily by available memory. Opening a collection results in a project window with two main parts driven entirely by a unique set of GUI objects. On the left are a number of icon wells, representing new objects that could be created, and a scrollable window on the right (known as the Collection Window) displays the objects that the user has created. Icons are dragged from the wells on the left into the window to create new objects in the collection. These objects include relations (tables) to hold data, sequences (macros) to automate tasks, and users to create custom menus for the end-user. This is one of Helix's most unusual and powerful features. In the Relation, database tables (groups of related data) are created. Relations contain fields to define datatypes, an abacus to define the relationships among data and create information the fields alone cannot present, indexes to organize data and improve performance, queries to find data, \"templates\" to structure information visually and for entering, modifying, deleting and printing from \"Views\" that combine templates, queries and indexes to give the user access to and control over information. The abacus uses a completely graphical system for creating calculations. You describe the desired calculation by dragging icons representing operations and fields into the abacus' editor window, and then arrange them in a dataflow diagram. For example, to say \"first name followed by space followed by last name\", you drag in a \"followed by\" icon, then drag the \"first name\" field into its first part and set a space character as its second part; then you drag in a second \"followed by\" icon, feed the output arrow from the first one into the second's first part, and drag the \"last name\" field into its second part. Helix RADE runs in two modes, Design mode and User mode. In User Mode the Helix collection opens in one of the defined user menu bars, allowing the user to use the database as they would any other application. Design mode allows the developer (or advanced user) to alter the design of the database, adding fields, creating new reports, etc. Although intended to simplify programming, iconic programming languages often \"miss the point\": programming is difficult not because you have to type, but because the complexity very quickly reaches a level where the project can no longer be understood. In theory a graphical language can help reduce this complexity considerably (see intentional programming for examples). In some cases, they do, but in many cases they make the problem worse. Helix is a very forgiving tool, allowing numerous routes to the same result. In the hands of an unskilled user, as with any tool, complex calculations can quickly become unwieldy, requiring that the programmer have a large monitor (or two) to work efficiently. However, skillful users find its visual approach both timesaving and liberating with few serious limitations. Although quite adept at handling small to mid-size databases, a common problem for Helix is that for much of its lifetime, it has run only in the co- operative multitasking environment of the Classic Mac OS, making it rather unstable for large databases. Although the programming language itself has the scalability required to create complex databases, the inability to run reliably in a 24/7 environment relegates Helix to workgroups of 100 users or less. However, these limitations are rapidly becoming history. QSA released an OS X version of its Helix Server in December 2005 and is rolling out the rest of its product line in OS X versions in 2006 and 2007. For someone familiar with Helix, the savings in development time can be significant. One expert who is also a leading Microsoft Access trainer/developer estimates that depending upon the size of the project, a Helix project can be finished in 30-70% of the time as the same Access project. The savings come particularly from the absence of a programming \"language,\" thus the elimination of all syntax errors. Since Helix, itself, prevents a developer from making syntactical or programming errors, the remaining sources of problems come from errors in business logic. All languages face this problem, but Helix once again softens the difficulty in tracking down the problems due to its object-based and graphical nature. Because all of the objects are linked (through icons, not through coding), the system \"knows\" what objects are used by other objects and in what way and simplifies tracking down business logic errors and also provides a simple method of determining everything that is about to be affected by a proposed change to any object. ==Limitations of Helix Visual Programming== In Helix, one must compose all code graphically - thus, an if..then..else construct is built using flowchart-type widgets such as decision diamonds, and loops are implemented using connectors. While Helix's visual programming is possibly easier for novices to learn (because it uses a flowcharting paradigm that is intuitively understood by non-technical individuals), it can become tedious when the amount of code to be written becomes significant, especially for an individual who can write code much more easily and conveniently than if forced to drag icons from a palette. To this end, when Helix RADE was updated to run natively on Intel Macs, an \"abacus expression language\" was added to provide this capability for those who needed it. While there are those who might argue that Helix has suffered from the lack of developer support and third-party applications, the truth is that Helix, which was one of the original Macintosh applications, still exists today precisely because of its developer support. ==References== ==External links== *QSA ToolWorks, LLC Category:Proprietary database management systems ",
    "title": "Helix (database)"
}