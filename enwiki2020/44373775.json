{
    "id": "44373775",
    "text": "Many concepts in one\u2013dimensional signal processing are similar to concepts in multidimensional signal processing. However, many familiar one\u2013dimensional procedures do not readily generalize to the multidimensional case and some important issues associated with multidimensional signals and systems do not appear in the one\u2013dimensional special case. ==Motivation and applications== Most of the signals we witness in real life exist in more than one dimension, be they image, video or sound among many others. A multidimensional (M-D) signal can be modeled as a function of M independent variables, where M is greater than or equal to 2. Certain concepts for multidimensional signal processing vary from one dimensional signal processing. For example, The computational complexity for multi-dimensional case is higher as it involves more dimensions. Also, assumptions of causality do not hold good for the multi-dimensional case. A multidimensional (M-D) signal can be modeled as a function of M independent variables, where M is greater than or equal to 2. These signals may be categorized as continuous, discrete, or mixed. A continuous signal can be modeled as a function of independent variables which range over a continuum of values, example \u2013 an audio wave traveling in space.A continuous signal in the multi-dimensional case can be represented in the time domain as x(t_1,t_2,...t_M).The number of arguments within the parenthesis indicates the number of dimensions of the signal. The signal in this case is of n dimensions. A discrete signal, on the other hand, can be modeled as a function defined only on a set of points, such as the set of integers.A discrete signal of M-dimensions can be represented in the spatial domain as x(n_1,n_2,...n_M). A mixed signal is a multidimensional signal that is modeled as a function of some continuous variables and some discrete ones, for example an ensemble of time waveforms recorded from an array of electrical transducers is a mixed signal. The ensemble can be modeled with one continuous variable, time, and one or more discrete variables to index the transducers. Filtering is an application that is performed on signals whenever certain frequencies are to be removed so as to suppress interfering signals and reduce background noise. A mixed filter is a kind of filter that is different from the traditional Finite Impulse Response(FIR) and Infinite impulse response(IIR) filters and these three filters are explained here in detail. We can combine the M-D Discrete Fourier transform(DFT) method and the M-D linear difference equation(LDE) method to filter the M-D signals. This results in the so-called combined DFT/LDE filtering technique in which the Discrete Fourier Transform is performed in some of the dimensions prior to Linear Difference Equation filtering which is performed later in the remaining dimensions. Such kind of filtering of M-D signals is referred to as Mixed domain(MixeD) filtering and the filters that perform such kind of filtering are referred to as MixeD Multidimensional Filters.K.S. Knudsen and T. Bruton, \"Mixed Multidimensional Filters\" IEEE transactions on \"Circuits and Systems for Video Technology\" Combining Discrete Transforms with Linear Difference Equations for implementing the Multidimensional filters proves to be computationally efficient and straightforward to design with low memory requirements for spatio-temporal applications such as video processing. Also the Linear Difference equations of the MixeD filters are of lower dimensionality as compared to normal multidimensional filters which results in simplification of the design and increase in the stability.Knud Steven Knudsen and Leonard T. Bruton \"Mixed Domain Filtering of Multidimensional Signals\", IEEE transactions on \"Circuits and Systems for Video Technology\", VOL. I , NO. 3, SEPTEMBER 1991 Multidimensional Digital filters are finding applications in many fields such as image processing, video processing, seismic tomography, magnetic data processing, Computed tomography (CT), RADAR, Sonar and many more.Kwan, H. K., and C. L. Chan. \"Multidimensional spherically symmetric recursive digital filter design satisfying prescribed magnitude and constant group delay responses.\" IEE Proceedings G (Electronic Circuits and Systems). Vol. 134. Issue 4, pp. 187 \u2013 193, IET Digital Library, 1987 There is a difference between 1-D and M-D digital filter design problems. In the 1-D case, the filter design and filter implementation issues are distinct and decoupled. The 1-D filter can first be designed and then particular network structure can be determined through the appropriate manipulation of the transfer function. In the case of M-D filter design, the multidimensional polynomials cannot be factored in general. This means that an arbitrary transfer function can generally not be manipulated into a form required by a particular implementation. This makes the design and implementation of M-D filters more complex than the 1-D filters. == Problem statement and basic conceptsDan E. Dudgeon, Russell M. Mersereau, \"Multidimensional Digital Signal Processing\", Prentice-Hall Signal Processing Series, , 1983.== Multidimensional filters not unlike their one dimensional counterparts can be categorized as * Finite impulse response filters * Infinite impulse response filters * Mixed filters In order to understand these concepts, it is necessary to understand what an impulse response means. An impulse response is basically the response of the system when the input to that system is a Unit impulse function. An impulse response in the spatial domain can be represented as h(n_1,n_2,....n_n). A Finite Impulse Response (FIR), or non-recursive filter has an impulse response with a finite number of non-zero samples. This makes their impulse response always absolutely summable and thus FIR filters are always stable. x\\left(\\underline {n}\\right) is the multidimensional input signal and y\\left(\\underline {n}\\right) is the multidimensional output signal. For a m dimensional spatial domain, the output y can be represented as y\\left(n_1,n_2,...,n_m\\right)=\\sum_{l_1=0}^{L_1-1}\\sum_{l_2=0}^{L_2-1}...\\sum_{l_m=0}^{L_m-1}a(l_1,l_2,...,l_m)x(n_1-l_1,n_2-l_2,...,n_m- l_m) The above difference equation can be represented in the Z-domain as follows Y(z_1,z_2,....z_m)=\\sum_{l_1=0}^{L_1-1}\\sum_{l_2=0}^{L_2-1}...\\sum_{l_m=0}^{L_m-1}a(l_1,l_2,....l_m)X(z_1,z_2,...z_m)z_1^{-l_1}z_2^{-l_2}......z_m^{-l_m}, where X(z_1,z_2,...z_m) and Y(z_1,z_2,....z_m) are the Z-transform of x(n_1,n_2,...n_m), and y(n_1,n_2,...n_m) respectively. The transfer function H(z_1,z_2,...z_m) is given by, H(z_1,z_2,....z_m)=Y(z_1,z_2,...z_m)/X(z_1,z_2,....z_m) In the case of FIR filters the transfer function consists of only numerator terms as the denominator is unity due to the absence of feedback. An Infinite Impulse Response (IIR), or recursive filter (due to feedback) has infinite-extent impulse response. Its input and output satisfy a multidimensional difference equation of finite order. IIR filters may or may not be stable and in many cases are less complex to realize when compared to FIR filters. The promise of IIR filters is a potential reduction in computation compared to FIR filters when performing comparable filtering operations. by, feeding back output samples, we can use a filter with fewer coefficients (hence less computations) to implement a desired operation. On the other hand, IIR filters pose some potentially significant implementation and stabilization problems not encountered with FIR filters. The design of an M-D recursive filter is quite different from the design of a 1-D filter which is due to the increased difficulty of assuring stability. For a m dimensional domain, the output y can be represented as y\\left(n_1,n_2,...,n_m\\right)=\\sum_{l_1=0}^{L_1-1}\\sum_{l_2=0}^{L_2-1}...\\sum_{l_m=0}^{L_m-1}a(l_1,l_2,...,l_m)x(n_1-l_1,n_2-l_2,...,n_m- l_m)-\\sum_{m_1=0}^{M_1-1}\\sum_{m_2=0}^{M_2-1}...\\sum_{m_m=0}^{M_m-1}b(m_1,m_2,...,m_m)y(n_1-m_1,n_2-m_2,...,n_m- m_m) Y(z_1,z_2,....z_m)=\\sum_{l_1=0}^{L_1-1}\\sum_{l_2=0}^{L_2-1}...\\sum_{l_m=0}^{L_m-1}a(l_1,l_2,....l_m)X(z_1,z_2,...z_m)z_1^{-l_1}z_2^{-l_2}......z_m^{-l_m}-\\sum_{m_1=0}^{M_1-1}\\sum_{m_2=0}^{M_2-1}...\\sum_{m_m=0}^{M_m-1}b(m_1,m_2,....m_m)Y(z_1,z_2,...z_m)z_1^{-m_1}z_2^{-m_2}......z_m^{-m_m} The transfer function in this case will have both numerator and denominator terms due to the presence of feedback. Although multidimensional difference equations represent a generalization of 1-D difference equations, they are considerably more complex and quite different. A number of important issues associated with multidimensional difference equations, such as the direction of recursion and the ordering relation, are really not an issue in the 1-D case. Other issues such as stability, although present in the 1-D case, are far more difficult to understand for multidimensional systems Multidimensional(M-D) filtering may also be achieved by carrying out the P-dimensional Discrete Fourier transform (DFT) over P of the dimensions where (P In general, the M-D Linear Difference Equation (LDE) filter method convolves a real M-D input sequence ' with a M-D unit impulse sequence 'to obtain a desired M-D output sequence '. = * \\overset{M}{\\cdots} * , where * \\overset{M}{\\cdots} * refers to the M-D convolutional(convolution) operator and ' refers to the M-D signal domain index vector. If a sequence is zero for some i' and for all n_i > L_i, where L_i < \\infty, that sequence is said to be duration bounded in the ' dimension. A multiplicative operator ' may be used to obtain from ' a M-D sequence that is duration bounded. An M-D sequence, = is duration bounded in the first P dimensions if ' = 1 \\forall where \\subset and r_i \\leq L_i < \\infty, i = 1,2,3....P where P \\leq M and 0 otherwise . The MixeD filter method requires that the M-D input sequence be duration bounded in P of the M dimensions. The index ' is then ordered so that \\left(n_1,n_2,...,n_p\\right)' corresponds to the duration-bounded dimensions. The MixeD filtering method involves a P-dimensional(P-D) discrete forward transform operation '[.] on ' over the first P variables \\left(n_1,n_2,...,n_p\\right) , which we can write as ',' = '[']. Examples of '[.] are the P-Dimensional DFT, DCT and DHT. According to the MixeD filter method, each complex sequence, ',' is filtered by a (M - P)-dimensional LDE. The LDE filters have impulse responses ','. Finally the complex output sequences of the LDE filters, i.e. ',' are inverse transformed using the operator '[.], to give the final M-D filtered output signal, '. The three step process can be summarized as follows, Step 1. ',' = '['] Step 2. ',' = ',' * \\overset{M-P}{\\cdots} * ',' 'Step 3. ' = [,] The crucial step in the MixeD filter design is the 2nd step. This is because filtering takes place in this step. Since there is no filtering involved in Steps 1 and 3, there is no need to weigh the transform coefficients. The block diagram which shows the MixeD filter method can be seen below. File:Block_diagram_showing_the_MixeD_Filter_Method.png == FIR filter implementation == === Direct convolution === Output of any Linear Shift Invariant (LSI) filter can be determined from its input by means of the convolution sum. There are a finite number of non-zero samples and the limits of summation are finite for a FIR filter. The convolution sum serves as an algorithm that enables us to compute the successive output samples of the filter. As an example, let is assume that the filter has support over the region {(n_1,n_2,...,n_m): 0 \u2264 n_1 < N_1 , 0 \u2264 n_2 < N_2,...,0 \u2264 n_m < N_m }, the output samples can be computed using y\\left(n_1,n_2,...,n_m\\right)=\\sum_{k_1=0}^{N_1-1}\\sum_{k_2=0}^{N_2-1}...\\sum_{k_m=0}^{N_m-1}h(k_1,k_2,...,k_m)x(n_1-k_1,n_2-k_2,...,n_m- k_m) If all input samples are available, the output samples can be computed in any order or can also be computed simultaneously. However, if only selected samples of the output are desired, only those samples need to be computed. The number of multiplications and additions for one desired output sample is (N_1.N_2...N_m) and (N_1.N_2...N_m)\u20131 respectively. For the 2D case, the computation of y\\left(n_1,n_2\\right) depends on input samples from (N_1 \u2013 1) previous columns of the input and the (N_2 \u2013 1) previous rows. If the input samples arrive row by row, we need sufficient storage to store N_2 rows of the input sequence. If the input is available column by column instead, we need to store N_1 columns of the input. A zero phase filter with a real impulse response satisfies h\\left(n_1,n_2\\right) = h\\left(-n_1, -n_2\\right), which means that each sample can be paired with another of identical value. In this case we can use the arithmetic distributive law to interchange some of the multiplications and additions, to reduce the number of multiplications necessary to implement the filter, but the number of multiplications is still proportional to the filter order. Specifically, if the region of support for the filter is assumed to be rectangular and centered at the origin, we have y\\left(n_1,n_2\\right)=\\sum_{k_1=-N_1}^{N_1}\\sum_{k_2=-N_2}^{N_2}h(k_1,k_2)x(n_1-k_1,n_2-k_2) y\\left(n_1,n_2\\right)=\\sum_{k_1=-N_1}^{N_1}\\sum_{k_2=1}^{N_2}h(k_1,k_2)[x(n_1-k_1,n_2-k_2)+x(n_1+k_1,n_2+k_2)]+\\sum_{k_1=1}^{N_1}h(k_1,0)[x(n_1-k_1,n_2)+x(n_1+k_1,n_2)]+h(0,0)x(n_1,n_2) Using the above equation to implement an FIR filter requires roughly one-half the number of multiplications of an implementation, although both implementations require the same number of additions and the same amount of storage. If the impulse response of an FIR filter possess other symmetries, they can be exploited in a similar fashion to reduce further the number of required multiplications. === Discrete Fourier transform implementations of FIR filters === The FIR filter can also be implemented by means of the Discrete Fourier transform (DFT). This can be particularly appealing for high- order filters because the various Fast Fourier transform algorithms permit the efficient evaluation of the DFT. The general form of DFT for multidimensional signals can be seen below, where N is periodicity matrix, x(\\underline{n}) is the multidimensional signal in the space domain, X(\\underline{k}) is the DFT of x(\\underline{n}) in frequency domain, I_N is a region containing |det N| samples in n domain, and J_N is a region containing |det N^T| (= det N) frequency samples. X\\left(\\underline{k}\\right) = \\sum_{n \\epsilon I_n}x\\left(\\underline{n}\\right)e^{-j\\underline{k}^T\\left(2\\pi \\underline{N}^{-1}\\right)\\underline{n}} Let y\\left(n_1,n_2,...,n_m\\right) be the linear convolution of a finite-extent sequence x\\left(n_1,n_2,...,n_m\\right) with the impulse response h\\left(n_1,n_2,...,n_m\\right) of an FIR filter. y\\left(n_1,n_2,...,n_m\\right)=x\\left(n_1,n_2,...,n_m\\right)*h\\left(n_1,n_2,...,n_m\\right) On computing Fourier Transform of both sides of this expression, we get Y\\left(w_1,w_2,...,w_m\\right)=X\\left(w_1,w_2,...,w_m\\right)H\\left(w_1,w_2,...,w_m\\right) There are many possible definitions of the M-D discrete Fourier transform, and that all of these correspond to sets of samples of the M-D Fourier transform; these DFT's can be used to perform convolutions as long their assumed region of support contains the support for y\\left(n_1,n_2,...,n_m\\right). Let us assume that Y\\left(w_1,w_2,...,w_m\\right) is sampled on a N_1xN_2x...xN_m rectangular lattice of samples, and let Y\\left(k_1,k_2,...,k_m\\right)=Y\\left(w_1,w_2,...,w_m\\right) | w_1=\\frac{2\\pi k_1}{N_1} ; w_2=\\frac{2\\pi k_2}{N_2} ;...; w_m=\\frac{2\\pi k_m}{N_m} Therefore, Y\\left(k_1,k_2,...,k_m\\right)=X\\left(k_1,k_2,...,k_m\\right)H\\left(k_1,k_2,...,k_m\\right). To compute (N_1xN_2x...xN_m)-point DFT's of x and h requires that both sequences have their regions of support extended with samples of value zero. If \\hat y\\left(n_1,n_2,...,n_m\\right) results from the inverse DFT of the product X\\left(k_1,k_2,...,k_m\\right).H\\left(k_1,k_2,...,k_m\\right) , then \\hat y\\left(n_1,n_2,...,n_m\\right) will be the circular convolution of h\\left(n_1,n_2,...,n_m\\right) and x\\left(n_1,n_2,...,n_m\\right). If N_1, N_2,..., N_m are chosen to be at least equal to the size of y\\left(n_1,n_2,...,n_m\\right), then \\hat y\\left(n_1,n_2,...,n_m\\right) = y\\left(n_1,n_2,...,n_m\\right). This implementation technique is efficient with respect to computation, however it is prodigal with respect to storage as this method requires sufficient storage to contain all N_1xN_2x...xN_m points of the signal x\\left(n_1,n_2,...,n_m\\right). In addition, we must store the filter response coefficients H\\left(k_1,k_2,...,k_m\\right). By direct convolution the number of rows of the input that needs to be stored depends on the order of the filter. However, with the DFT the whole input must be stored regardless of the filter order. For the 2D case, and assuming that H\\left(k_1,k_2\\right) is pre-computed, the number of real multiplications needed to compute y\\left(n_1,n_2\\right) is 2xN_1xN_2x \\log _2N_1xN_2 + 2xN_1xN_2; N_1 and N_2 are powers of 2 === Block convolution === The arithmetic complexity of the DFT implementation of an FIR filter is effectively independent of the order of the filter, while the complexity of a direct convolution implementation is proportional to the filter order. So, the convolution implementation would be more efficient for the lower filter order. As, the filter order increases, the DFT implementation would eventually become more efficient. The problem with the DFT implementation is that it requires a large storage. The block convolution method offers a compromise. With these approaches the convolutions are performed on sections or blocks of data using DFT methods. Limiting the size of these blocks limits the amount of storage required and using transform methods maintains the efficiency of the procedure. The simplest block convolution method is called the overlap-add technique. We begin by partitioning 2-D array, x\\left(n_1,n_2\\right), into (N_1xN_2) point sections, where the section indexed by the pair (k_1,k_2) is defined as below: x_{k_1k_2}\\left(n_1,n_2\\right) = x\\left(n_1, n_2\\right) \\text{if } k_1N_1 \\le n_1 < (k_1 +1)N_1 \\text{and } k_2N_2 \\le n_2 < (k_2 +1)N_2 The regions of support for the different sections do not overlap, and collectively they cover the entire region of support of the array x\\left(n_1,n_2\\right). Thus, x\\left(n_1,n_2\\right) = \\sum_{k_1}\\sum_{k_2}x_{k_1k_2}\\left(n_1,n_2\\right) Because the operation of discrete convolution distributes with respect to addition, y\\left(n_1,n_2\\right) can be written as follows: y\\left(n_1,n_2\\right) = x\\left(n_1,n_2\\right) ** h\\left(n_1,n_2\\right) = \\left(\\sum_{k_1}\\sum_{k_2}x_{k_1k_2}\\left(n_1,n_2\\right)\\right) ** h\\left(n_1,n_2\\right) = \\sum_{k_1}\\sum_{k_2}\\left(x_{k_1k_2}\\left(n_1,n_2\\right) ** h\\left(n_1,n_2\\right)\\right) = \\sum_{k_1}\\sum_{k_2}y_{k_1k_2}\\left(n_1,n_2\\right) center Figure (a) shows the section of the input array x_{21}\\left(n_1,n_2\\right). Figure (b) shows the region of support of the convolution of that section with h that is y_{21}\\left(n_1,n_2\\right). The block output y_{k_1k_2}\\left(n_1,n_2\\right) is the convolution of h\\left(n_1,n_2\\right) with block \\left(k_1,k_2\\right) of x\\left(n_1,n_2\\right). The result of the block convolution must be added together to produce the complete filter output y\\left(n_1,n_2\\right). As the support of y_{k_1k_2}\\left(n_1,n_2\\right) is greater than the support of x_{k_1k_2}\\left(n_1,n_2\\right), the output blocks will of necessity overlap, but the degree of that overlap is limited. The convolutions of the x_{k_1k_2}\\left(n_1,n_2\\right) and h(n_1,n_2) can be evaluated by means of discrete Fourier transforms, provided that the size of the transform is large enough to support y_{k_1k_2}\\left(n_1,n_2\\right). By controlling the block size we can limit the size of the DFTs, which reduces the required storage. The overlap-save method is an alternative block convolution technique. When the block size is considerably larger than the support of h, the samples of y in the center of each block are not overlapped by samples from neighboring blocks. Similarly, when a sequence x is circularly convolved with another, h, which has a much smaller region of support, only a subset of the samples of that circular convolution will show the effects of the spatial aliasing. The remaining samples of the circular convolution will be identical to the samples of the linear convolution. Thus if an (N_1\u00d7N_2) -point section of x\\left(n_1,n_2\\right) is circularly convolved with an (M_1\u00d7M_2) -point impulse response using an (N_1\u00d7N_2) -point DFT, the resulting circular convolution will contain a cluster of \\left(N_1 - M_1 + 1\\right) \u00d7\\left(N_2 - M_2 + 1\\right) samples which are identical to samples of the linear convolution, y. The whole output array can be constructed form these \"good\" samples by carefully choosing the regions of support for the input sections. If the input sections are allowed to overlap, the \"good\" samples of the various blocks can be made to abut. The overlap-save method thus involves overlapping input sections, whereas the overlap-add method involves overlapping output sections. center The figure above shows the overlap-save method. The shaded region gives those samples of y for which both the (N_1\u00d7N_2) circular convolution and the linear convolution of x with h are identical. For both the overlap-add and overlap-save procedures, the choice of block size affects the efficiency of the resulting implementation. It affects the amount of storage needed, and also affects the amount of computation. == FIR filter design == === Minimax design of FIR filters === The frequency response of a multi-dimensional filter is given by, H(w_1,w_2,...w_n)=\\sum_{n_1=0}^{N_1-1}\\sum_{n_2=0}^{N_2-1}...\\sum_{n_n=0}^{N_n-1} h(n_1,n_2,....n_n)e^{-jw_1n_1}e^{-jw_2n_2}.....e^{-jw_nn_n} where h(n_1,n_2,....n_n) is the impulse response of the designed filter for size N_1\\times N_2\\times.....N_n The frequency response of the ideal filter is given by I(w_1,w_2,...w_n)=\\sum_{n_1=-\\infty}^{\\infty}\\sum_{n_2=-\\infty}^{\\infty}...\\sum_{n_n=-\\infty}^{\\infty} i(n_1,n_2,....n_n)e^{-jw_1n_1}e^{-jw_2n_2}.....e^{-jw_nn_n} where i(n_1,n_2,...n_n) is the impulse response of the ideal filter. The error measure is given by subtracting the above two results i.e. E(w_1,w_2,....w_n)=H(w_1,w_2,.....w_n)-I(w_1,w_2,.....w_n) The maximum of this error measure is what needs to be minimized.There are different norms available for minimizing the error namely: L_2 norm given by the formula E_2=[1/(2\\pi)^n\\int\\limits_{-\\pi}^{\\pi}\\int\\limits_{-\\pi}^{\\pi}...\\int\\limits_{-\\pi}^{\\pi}\\left\\vert E(w_1,w_2,...w_n) \\right\\vert^{2}dw_1dw_2...dw_n]^{1/2} L_p norm given by the formula E_p=[1/(2\\pi)^n\\int\\limits_{-\\pi}^{\\pi}\\int\\limits_{-\\pi}^{\\pi}...\\int\\limits_{-\\pi}^{\\pi}\\left\\vert E(w_1,w_2,...w_n) \\right\\vert^{p}dw_1dw_2...dw_n]^{1/p} if p =2 we get the L_2 norm and if p tends to \\infty we get the L_\\infty norm.The L_\\infty norm is given by, E_\\infty=\\max_{(w_1,w_2,...w_n\\isin B)}\\left\\vert E(w_1,w_2,...w_n) \\right\\vert When we say minimax design the L_\\infty norm is what comes to mind. === Design using transformation === Another method to design a multidimensional FIR filter is by the transformation from 1-D filters. This method was first developed by McClellan as other methods were time consuming and cumbersome. The first successful implementation was achieved by Mecklenbrauker and MersereauRussell M.Mersereau, Wolfgang F.G. Mecklenbrauker, and Thomas F. Quatieri, Jr., \"McClellan Transformation for 2-D Digital Filtering: I-Design,\" IEEE Trans. Circuits and Systems, CAS-23, no. 7 (July 1976),405-14.Wolfgang F.G. Mecklenbrauker and Russell M. Mersereau, \"McClellan Transformations for 2-D Digital Filtering: II-Implementation,\" IEEE Trans. Circuits and Systems, CAS-23, no.7(July 1976), 414-22. and was later revised by McClellan and Chan.James H. McClellan and David S.K. Chan. \"A 2-D FIR Filter Structure Derived from the Chebyshev Recursion,\" IEEE Trans. Circuits and Systems, CAS-24, no.7 (July 1977), 372-78. For a zero phase filter the one phase impulse response is given by h(\\ \\underline{n})=h^*(-\\ \\underline{n}) where h^*(-\\ \\underline{n}) represents the complex conjugate of h(\\ \\underline{n}). Let H(\\ \\underline{w}) be the frequency response of h(\\ \\underline{n}).Assuming h(\\ \\underline{n}) is even,we can write H(w)=\\sum_{n=0}^N a_ncos(wn) where a_n is defined as a_n=h(0) if n=0 and a_n=2h(n) if n e0.Also cos(wn) is a polynomial of degree n known as the Chebyshev polynomial. The variable is cos(w) and the polynomial can be represented by T_n(cos(w)). Thus H(w)=\\sum_{n=0}^N a(n)T_n(cos(w)) is the required 1-D frequency response in terms of Chebyshev polynomial T_n(cos(w)). If we consider F(w_1,w_2,...w_n) to be a transformation function whereF(w_1,w_2,...w_n) maps to cos(w),then we get, H(w_1,w_2,....w_n)=\\sum_{n=0}^N a_nT_n[F(w_1,w_2,...w_n)] The contours and the symmetry of H(w_1,w_2,.....w_n) depend on that of F(w_1,w_2,....w_n). F(w_1,w_2,....w_n) is also called the mapping function. The values of H(w_1,w_2,...w_n) can be obtained from the values of the 1_D prototype H(w). The conditions for choosing the mapping function are * \u00b7 It must be a valid frequency response of a md filter * \u00b7 It should be real * \u00b7 It should lie between -1 and 1. Considering a two dimensional case to compute the size of H(w_1,w_2), If the 1-D prototype has size (2N+1) and the mapping function has size (2Q+1)*(2Q+1),then the size of the desired H(w_1,w_2) will be (2NQ+1)*(2NQ+1) The main advantages of this method are * Easy to implement * \u00b7Easy to understand 1-D concepts * \u00b7Optimal filter design is possible ===Implementation of filters designed using transformations=== Methods such as Convolution or implementation using the DFT can be used for the implementation of FIR filters. However, for filters of moderate order another method can be used which justifies the design using transformation.Consider the equation for a 2-dimensional case, H(w_1,w_2)=\\sum_{n=0}^N a_nT_n[F(w_1,w_2)] where,T_n[F(w_1,w_2)] is a Chebyshev polynomial.These polynomials are defined as, T_0[x]=1 T_1[x]=x T_n[x]=2xT_{n-1}[x]-T_{n-2}[x]. Using this we can form a digital network to realize the 2-D frequency response as shown in the figure below.Replacing x by F(w_1,w_2) we get, T_n[F(w_1,w_2)]=2F(w_1,w_2)T_{n-1}[F(w_1,w_2)]-T_{n-2}[F(w_1,w_2)] 400x400pxSince each of these signals can be generated from two lower order signals, a ladder network of N outputs can be formed such that frequency response between the input and nth output is T_n[F(w_1,w_2) .By weighting these outputs according to the equation mentioned below, The filter H(w_1,w_2) can be realized. H(w_1,w_2)=\\sum_{n=0}^N a_nT_n[F(w_1,w_2)] This realization is as shown in the figure below. 600x600pxIn the figure,the filters F define the transformation function and h(n) is the impulse response of the 1-D prototype filter . === Trigonometric sum-of-squares optimization === Here we discuss a method for multidimensional FIR filter design via sum-of-squares formulations of spectral mask constraints. The sum-of-squares optimization problem is expressed as a semidefinite program with low-rank structure, by sampling the constraints using discrete sine and cosine transforms. The resulting semidefinite program is then solved by a customized primal-dual interior-point method that exploits low-rank structure. This leads to substantial reduction in the computational complexity, compared to general- purpose semidefinite programming methods that exploit sparsity.Roh T., Bogdan D.,Vandenberghe L., \"Multidimensional FIR Filter Design Via Trigonometric Sum- of-Squares Optimization,\" 'IEEE JOURNAL OF SELECTED TOPICS IN SIGNAL PROCESSING (12/2007)', Vol. 1, No. 4, Page 1-10 A variety of one-dimensional FIR filter design problems can be expressed as convex optimization problems over real trigonometric polynomials, subject to spectral mask constraints. These optimization problems can be formulated as semidefinite programs (SDPs) using classical sum-of-squares (SOS) characterizations of nonnegative polynomials, and solved efficiently via interior-point methods for semidefinite programming. FIR filter in frequency domain with d=2; n1=n2=5 and has 61 sampling points For the figure above, FIR filter in frequency domain with d=2; n1=n2=5 and has 61 sampling points. The extension of these techniques to multidimensional filter design poses several difficulties. First, SOS characterization of multivariate positive trigonometric polynomials may require factors of arbitrarily high degree. Second, difficulty stems from the large size of the semidefinite programming problems obtained from multivariate SOS programs. Most recent research on exploiting structure in semidefinite programming has focused on exploiting sparsity of the coefficient matrices. This technique is very useful for SDPs derived from SOS programs and are included in several general purpose semidefinite programming packages. Let Z_d and N_d denote the sets of d-vectors of integers and natural numbers, respectively. For a vector x, we define diag\\left(x\\right) as the diagonal matrix with x_i as its ith diagonal entry. For a square matrix X, diag\\left(X\\right) is a vector with the i^{th} entry Xii. The matrix inequality A > \\ge B denotes that A-B is positive definite (semidefinite). Tr\\left(A\\right) denotes the trace of a symmetric matrix A. R is a d-variate trigonometric polynomial of degree n \\epsilon Z_d , with real symmetric coefficients x_k = x_{-k} R\\left(w\\right) = \\sum_{k =-n}^{n}x_ke^{-jk^Tw} The above summation is over all integer vectors k that satisfy -n \\le k \\le n, where the inequalities between the vectors are interpreted element-wise. R is positive on [-\\pi , \\pi ]^d, then it can be expressed as sum of squares of trigonometric polynomials H_l\\left(w\\right) = \\sum_{l=1}^{r}|H_l\\left(w\\right)|^2 H_l\\left(w\\right) = \\sum_{k=0}^{n_l}h_{l,k}e^{-jk^Tw} 2-D FIR Filter Design as SOS Program: H is taken to be the frequency response of a 2-D linear phase FIR filter with filter order n = \\left(n_1, n_2\\right), with filter coefficients h_k = h_{-k}. H\\left(w\\right) = \\sum_{k =-n}^{n}h_ke^{-jk^Tw} We want to determine the filter coefficients h _k that maximize the attenuation \\delta _s in the stopband D_s for a given maximum allowable ripple (\\delta _p) in the passband D_p. The optimization problem is to minimize \\delta _s by subjecting to the following conditions |1- H\\left(w\\right)| \\le \\delta _p, \\, \\, w \\epsilon D_p |H\\left(w\\right)| \\le \\delta _s, \\, \\, w \\epsilon D_s where the scalar \\delta _s and the filter coefficients h _k are the problem variables. These constraints are as shown below R_1\\left(w\\right) = H\\left(w\\right)-1+\\delta _p \\ge 0, \\, \\, w \\epsilon D_p R_2\\left(w\\right) = 1-H\\left(w\\right)+\\delta _p \\ge 0, \\, \\, w \\epsilon D_p R_3\\left(w\\right) = H\\left(w\\right)+\\delta _s \\ge 0, \\, \\, w \\epsilon D_s R_4\\left(w\\right) = H\\left(w\\right)-\\delta _s \\ge 0, \\, \\, w \\epsilon D_s If the passband and stopband are defined, then we can replace each positive polynomial R_i by a weighted sum of squares expression. Limiting the degrees of the sum-of-squares polynomials to n then gives sufficient conditions for feasibility. We call the resulting optimization problem a sum-of-squares program and can be solved via semidefinite programming. == Iterative implementation for M-D IIR filters == In some applications, where access to all values of signal is available (i.e. where entire signal is stored in memory and is available for processing), the concept of \"feedback\" can be realized. The iterative approach uses the previous output as feedback to generate successively better approximations to the desired output signal. In general, the IIR frequency response can be expressed as H\\left(w_1,w_2,...,w_m\\right) = \\frac{A\\left(w_1,w_2,...,w_m\\right)}{B\\left(w_1,w_2,...,w_m\\right)} = \\frac{\\sum_{l_1} \\sum_{l_2} ... \\sum_{l_m} a\\left(l_1,l_2,...,l_m\\right) e^{-j\\left(w_1l_1+w_2l_2+...+w_ml_m\\right)}}{\\sum_{k_1} \\sum_{k_2} ... \\sum_{k_m} b\\left(k_1,k_2,...,k_m\\right) e^{-j\\left(w_1k_1+w_2k_2+...+w_mk_m\\right)}} where a\\left(l_1,l_2,...,l_m\\right) and b\\left(k_1,k_2,...,k_m\\right) are M-D finite extent coefficient arrays. The ratio is normalized so that b\\left(0,0,...,0\\right) = 1 Now, let X\\left(w_1,w_2,...,w_m\\right) represent the spectrum of a M-D input signal x\\left(n_1,n_2,...,n_m\\right) and Y\\left(w_1,w_2,...,w_m\\right) represent the spectrum of a M-D output signal y\\left(n_1,n_2,...,n_m\\right). Y\\left(w_1,w_2,...,w_m\\right) = A\\left(w_1,w_2,...,w_m\\right)X\\left(w_1,w_2,...,w_m\\right) + C\\left(w_1,w_2,...,w_m\\right)Y\\left(w_1,w_2,...,w_m\\right) where C\\left(w_1,w_2,...,w_m\\right) is a trigonometric polynomial defined as C\\left(w_1,w_2,...,w_m\\right) = 1- B\\left(w_1,w_2,...,w_m\\right) In the signal domain, the equation becomes y\\left(n_1,n_2,...,n_m\\right) = a\\left(n_1,n_2,...,n_m\\right)*x\\left(n_1,n_2,...,n_m\\right) + c\\left(n_1,n_2,...,n_m\\right)*y\\left(n_1,n_2,...,n_m\\right) After making an initial guess, and then substituting the guess in the above equation iteratively, a better approximation of y\\left(n_1,n_2,...,n_m\\right) can be obtained \u2013 y_i\\left(n_1,n_2,...,n_m\\right)= a\\left(n_1,n_2,...,n_m\\right)*x\\left(n_1,n_2,...,n_m\\right) + c\\left(n_1,n_2,...,n_m\\right)*y_{i-1}\\left(n_1,n_2,...,n_m\\right) where i denotes the iteration index In the frequency domain, the above equation becomes Y_i\\left(w_1,w_2,...,w_m\\right) = A\\left(w_1,w_2,...,w_m\\right)X\\left(w_1,w_2,...,w_m\\right) + C\\left(w_1,w_2,...,w_m\\right)Y_{i-1}\\left(w_1,w_2,...,w_m\\right) An IIR filter is BIBO stable if C\\left(w_1,w_2,...,w_m\\right) eq 0 If we assume that | C\\left(w_1,w_2,...,w_m\\right) | < 1 then \\lim_{I \\to \\infty}Y_I\\left(w_1,w_2,...,w_m\\right) = \\frac{A\\left(w_1,w_2,...,w_m\\right)X\\left(w_1,w_2,...,w_m\\right)}{1 - C\\left(w_1,w_2,...,w_m\\right)} = Y\\left(w_1,w_2,...,w_m\\right) design Thus, it can be said that, the frequency response H\\left(w_1,w_2,...,w_m\\right) of a M-D IIR filter can be obtained by infinite number of M-D FIR filtering operations. The store operator stores the result of the previous iteration. To be practical, an iterative IIR filter should require fewer computations, counting all iterations to achieve an acceptable error, compared to an FIR filter with similar performance. == Existing approaches for IIR filter design == Similar to its 1-D special case, M-D IIR filters can have dramatically lower order than FIR filters with similar performance. This motivates the development of design techniques for M-D IIR filtering algorithms. This section presents brief overview of approaches for designing M-D IIR filters. === Shank's method === This technique is based on minimizing the error functionals in the space domain. The coefficient arrays a\\left(n_1,n_2,...,n_m\\right) and b\\left(n_1,n_2,...,n_m\\right) are determined such that the output response y\\left(n_1,n_2\\right) of a filter matches the desired response d\\left(n_1,n_2,...,n_m\\right). Let us denote the error signal as e\\left(n_1,n_2,...,n_m\\right) = y\\left(n_1,n_2,...,n_m\\right) - d\\left(n_1,n_2,...,n_m\\right) And let E\\left(w_1,w_2,...,w_m\\right) denote it's the Fourier transform E\\left(w_1,w_2,...,w_m\\right) = \\frac{A\\left(w_1,w_2,...,w_m\\right)X\\left(w_1,w_2,...,w_m\\right)}{B\\left(w_1,w_2,...,w_m\\right)} - D\\left(w_1,w_2,...,w_m\\right) By multiplying both sides by B\\left(w_1,w_2,...,w_m\\right), we get the modified error spectrum, converted in discrete domain as e'\\left(n_1,n_2,...,n_m\\right) = a\\left(n_1,n_2,...,n_m\\right)*x\\left(n_1,n_2,...,n_m\\right) - b\\left(n_1,n_2,...,n_m\\right)*d\\left(n_1,n_2,...,n_m\\right) The total mean- squared error is obtained as e'_2\\left(n_1,n_2,...,n_m\\right) = \\sum_{n_1}\\sum_{n_2} ... \\sum_{n_m}[e'\\left(n_1,n_2,...,n_m\\right)]^2 Let the input signal be \\delta\\left(n_1,n_2,...,n_m\\right). Now, the numerator coefficient a\\left(n_1,n_2,...,n_m\\right) is zero outside region 0 \\le n_1 \\le N_1-1 \\, \\& \\, 0 \\le n_2 \\le N_2-1 ... , 0 \\le n_m \\le N_m-1 because of the ROS of input signal.Then equation becomes e'\\left(n_1,n_2,...,n_m\\right) = -\\sum_{q_1=0}^{M_1-1}\\sum_{q_2=0}^{M_2-1}...\\sum_{q_m=0}^{M_m-1}b\\left(q_1,q_2,..,q_m\\right)d\\left(n_1-q_1,n_2-q_2\\right)\\,;\\, for n_1 \\ge N_1-1 or n_2 \\ge N_2-1 or ... n_m \\ge N_m-1 Substituting the result e' into e_2' and differentiating e'_2 with respect to denominator coefficients b\\left(q_1,q_2,...,q_n\\right), the linear set of equations is obtained as \\sum_{m_1=0}^{M_1-1}\\sum_{m_2=0}^{M_2-1}...\\sum_{m_m=0}^{M_m-1}b\\left(m_1,m_2,...,m_m\\right)r\\left(m_1,m_2,...,m_m;q_1,q_2,...,q_m\\right) = 0 \\,;\\, for 0 \\le m_1 < M_1 ; 0 \\le m_2 < M_2 ; ... ; 0 \\le m_m < M_m Design Now, taking the double summation for the region \"R\" i.e. for n_1 \\ge N_1-1 and n_2 \\ge N_2-1 and ... n_m \\ge N_m-1 shown in figure (shown for 2-D case), the coefficients b\\left(n_1,n_2,...,n_m\\right) are obtained. The coefficients a\\left(n_1,n_2,...,n_m\\right) can be obtained from a\\left(n_1,n_2,...,n_m\\right) \\approx b\\left(n_1,n_2,...,n_m\\right)*d\\left(n_1,n_2,...,n_m\\right) The major advantage of Shank's method is that IIR filter coefficients can be obtained by solving linear equations. The disadvantage is that the mean squared error between y and d is not minimized. Also, the stability is not certain. ==Frequency-domain designs for IIR == Shank's method is a spatial-domain design method. It is also possible to design IIR filters in the frequency domain. Here our aim would be to minimize the error in the frequency domain and not the spatial domain.Due to Parseval's theorem we observe that the mean squared error will be identical to that in the spatial domain.Parseval's theorem states that \\sum_{n_1}\\sum_{n_2}...\\sum_{n_n}[y(n_1,n_2,....n_n)-d(n_1,n_2,....n_n)]^2=1/(2\\pi)^n\\int\\limits_{-\\pi}^{\\pi}\\int\\limits_{-\\pi}^{\\pi}....\\int\\limits_{-\\pi}^{\\pi}\\left\\vert Y(w_1,w_2,...w_n)-D(w_1,w_2,...w_n) \\right\\vert^2dw_1dw_2..dw_n Also the different norms that are used for FIR filter design such as L_2,L_p and L_\\infty can also be used for the design of IIR filters E_p=[1/(2\\pi)^n\\int\\limits_{-\\pi}^{\\pi}\\int\\limits_{-\\pi}^{\\pi}...\\int\\limits_{-\\pi}^{\\pi}\\left\\vert E(w_1,w_2,...w_n) \\right\\vert^{p}dw_1dw_2...dw_n]^{1/p} is the required equation for the L_p norm and when p tends to \\infty we get the L_\\infty norm as explained above E_\\infty=\\max_{(w_1,w_2,...w_n\\isin B)}\\left\\vert E(w_1,w_2,...w_n) \\right\\vert The main advantages of design in the frequency domain are * If there is any specification which is only partially complete, such as approximation of a magnitude response without the specification of phase response, this can be implemented with greater ease in the frequency domain rather than the space domain. * Also the approximating function can be written in closed form as a function of the filter parameters, thus facilitating simpler derivation of partial derivatives. The main disadvantage of this technique is that there is no guarantee for stability. General minimization techniques as seen in the design of IIR filters in the spatial domain can be used in the frequency domain too. One popular method for frequency domain design is the Magnitude and magnitude squared algorithms. === Magnitude and magnitude squared design algorithm === In this section, we examine the technique for designing 2-D IIR filters based on minimizing error functionals in the frequency domain. The mean-squared error is given as \\frac{1}{\\left(2\\pi\\right) ^m} \\int_{-\\pi}^{\\pi} \\int_{-\\pi}^{\\pi} ... \\int_{-\\pi}^{\\pi}|Y\\left(w_1,w_2,...,w_m\\right) - D\\left(w_1,w_2,...,w_m\\right)|^2 dw_1dw_2...dw_m The below function J_a is the measure of difference between two complex functions - the desired response D\\left(w_1,w_2,...,w_m\\right) and the actual response Y\\left(w_1,w_2,...,w_m\\right). Generally, we can define a complex function f of Y to approximate the desired response D. Hence, the optimization task boils down to the task of minimizing f (Y)-D. J_a = \\sum_{k}W\\left(w_{1k},w_{2k},...,w_{mk}\\right)[f\\left(\\frac{A\\left(w_{1k},w_{2k},...,w_{mk}\\right)}{B\\left(w_{1k},w_{2k},...,w_{mk}\\right)} \\right) - D\\left(w_{1k},w_{2k},...,w_{mk}\\right)]^2 where W\\left(w_1,w_2,...,w_m\\right) is the weighting function and \\left(w_{1k},w_{2k},...w_{mk}\\right) are frequency domain samples selected for minimization. Now, consider a case, where we ignore the phase response of the filter i.e. we concentrate on only matching the magnitude (or square of magnitude) of the desired and actual filter response. Linearization can be used to find out the coefficients \\\\{a\\left(n_1,n_2,...,w_m\\right) \\, b\\left(n_1,n_2,...,w_m\\right)\\\\} that results in minimum value of J_a. This will ensure that the filter form can be represented by a finite order difference equation. The stability of the filter depends on the functionY\\left(w_1,w_2,...,w_m\\right). The disadvantages of this method are, * Stability cannot be guaranteed * Depending on the function f, the computations of partial derivatives will be cumbersome. === Magnitude design with stability constraint === This design procedure includes a stability error J_s, which is to be minimized together with the usual approximation error J_a.Ekstrom, Michael P., Richard E. Twogood, and John W. Woods. \"Two-dimensional recursive filter design--A spectral factorization approach.\" Acoustics, Speech and Signal Processing, IEEE Transactions on 28.1 (1980): 16-26. The stability error is a crude measure of how unstable a filter is. It is a type of penalty function. It should be zero for stable filters and large for the unstable filters. The filters can be designed by minimizing J = J_a + aJ_s a is a positive constraint which weights the relative importance of J_a and J_s. Ekstrom et al. used the nonlinear optimization techniques to minimize J. Their stability error was based on the difference between the denominator coefficient array and the minimum-phase array with the same autocorrelation function. The minimum phase array can be determined by first computing the autocorrelation function of the denominator coefficient array b\\left(n_1,n_2\\right). r_b\\left(n_1, n_2\\right) = \\sum_{q_1}\\sum_{q_2}b\\left(q_1,q_2\\right)b\\left(q_1+n_1, q_2+n_2\\right) After computing r_b, its Fourier transform R_b\\left(w_1,w_2\\right) must be split into its minimum- and maximum-phase components. This is accomplished by spectral factorization using the complex cepstrum. We form the cepstrum r_b\\left(n_1, n_2\\right) of the autocorrelation function is formed and multiplied by a non symmetric half-plane window w\\left(n_1, n_2\\right) to obtain the cepstrum, b_{mp}\\left(n_1, n_2\\right) = r_b\\left(n_1, n_2\\right)w\\left(n_1, n_2\\right) The subscript \"mp\" denotes that this cepstrum corresponds to a minimum phase sequence b_{mp}\\left(n_1, n_2\\right). If the designed filter is stable, its denominator coefficient array b(n_1, n_2) is a minimum-phase sequence with non symmetric half-plane support. In this case, b(n_1, n_2) is equal to b_{mp}(n_1, n_2); otherwise it is not. J_s can be denoted as, J_s = \\sum_{n_1}\\sum_{n_2}[b(n_1, n_2) - b_{mp}(n_1, n_2)]^2 In practice, J_s is rarely driven to zero because of numerical errors in computing the cepstrum r_b\\left(n_1, n_2\\right). In general, r_b\\left(n_1, n_2\\right) has infinite extent, and spatial aliasing results when the FFT is used to compute it. The degree of aliasing can be controlled by increasing the size of the FFT. == Design and implementation of M-D zero-phase IIR filters == Often, especially in applications such as image processing, one may be required to design a filter with symmetric impulse response. Such filters will have a real-valued, or zero-phase, frequency response. Zero-phase IIR filter could be implemented in two ways, cascade or parallel. ; 1. The cascade approach In the cascade approach, a filter whose impulse response is h\\left(n_1, n_2\\right) is cascaded with a filter whose impulse response is h\\left(-n_1, -n_2\\right). The overall impulse response of the cascade is h\\left(n_1, n_2\\right) ** h\\left(-n_1, -n_2\\right). The overall frequency response is a real and non-negative function, C\\left(w_1, w_2\\right) = \\left\\vert H\\left(w_1, w_2\\right)\\right\\vert^2 The cascade approach suffers from some computational problems due to transient effects. The output samples of the second filter in the cascade are computed by a recursion which runs in the opposite direction from that of the first filter. For an IIR filter, its output has infinite extent, and theoretically an infinite number of its output samples must be evaluated before filtering with the h\\left(-n_1, -n_2\\right) can begin, even if the ultimate output is desired only over a limited region. Truncating the computations from the first filter can introduce errors. As a practical approach, the output form the first filter must be computed far enough out in space depending on the region-of-support of the numerator coefficient array a\\left(n_1, n_2\\right) and on the location of the to-be- computed second filter's output sample, so that any initial transient from the second filter will have effectively died out in the region of interest of the final output. ; 2. The parallel approach In the parallel approach, the outputs of two non symmetric half-plane (OR four non-symmetric quarter-plane) IIR filters are added to form the final output signal. As in the cascade approach, the second filter is a space-reserved version of the first. The overall frequency response is given by, P\\left(w_1, w_2 \\right) = H\\left(w_1, w_2 \\right) + H^*\\left(w_1, w_2 \\right) = 2\\text{ Re}[H\\left(w_1, w_2 \\right)] This approach avoids the problems of the cascade approach for zero-phase implementation. But, this approach is best suited for the 2-D IIR filters designed in the space domain, where the desired filter response d\\left(n_1, n_2\\right) can be partitioned into the proper regions of support. For a symmetric zero-phase 2-D IIR filter, the denominator has a real positive frequency response. H\\left(w_1,w_2,...,w_m\\right) = \\frac{A\\left(w_1,w_2,...,w_m\\right)}{B\\left(w_1,w_2,...,w_m\\right)} For 2-D zero-phase IIR filter, since a\\left(n_1, n_2\\right) = a\\left(-n_1, -n_2\\right) b\\left(n_1, n_2\\right) = b\\left(-n_1, -n_2\\right) We can write, A\\left(w_1, w_2\\right) = \\sum_{n_1}\\sum_{n_2}a'\\left(n_1, n_2\\right) cos(w_1n_1 + w_2n_2) B\\left(w_1, w_2\\right) = \\sum_{n_1}\\sum_{n_2}b'\\left(m_1, m_2\\right) cos(w_1m_1 + w_2m_2) We can formulate the mean-squared error functional that could be minimized by various techniques. The result of the minimization would yield the zero-phase filter coefficients {a'\\left(n_1, n_2\\right), b'\\left(n_1, n_2\\right)}. We can use these coefficients to implement the designed filter then. ==Implementation of Mixed Multidimensional Filters== If the M-D transform transfer function, ' = / for a particular class of inputs ' and a particular transform is known, the design approximation problem becomes simple and we then have to find the (M-P) dimensional LDE's, one for each P-tuple that help in approximating all the complex (M-P) dimensional transform transfer functions, ','. But as the multidimensional approximation theory for dimensions greater than 2 is not well developed, the (M-P) dimensional approximation maybe a problem. The input and output sequences of each (M-P) dimensional LDE are complex and are given by ',' and ',' respectively. The main design objective is to choose coefficients of the LDE in such a way that the complex (M-P) dimensional transform transfer function of the sequences ',' and ',', are approximately in the ratio of ',' = '. This can be very difficult unless certain transforms such as DFT, DCT and DHT are used. For the above- mentioned transforms, it is possible to find the (M-P) dimensional impulse response, ',' by approximating the Linear Difference Equations. The following approaches can be used to implement Mixed Multidimensional filters: ===Using discrete Fourier transform (DFT)=== For a multidimensional array x_{n_1, n_2, \\dots, n_p} that is a function of p discrete variables n_\\ell = 0, 1, \\dots, N_\\ell-1 for \\ell in 1, 2, \\dots, p, the P-Dimensional Discrete Forward Fourier Transform is defined by: ' = \\sum_{n_1=0}^{N_1-1} \\left(\\omega_{N_1}^{~k_1 n_1} \\sum_{n_2=0}^{N_2-1} \\left( \\omega_{N_2}^{~k_2 n_2} \\cdots \\sum_{n_p=0}^{N_p-1} \\omega_{N_p}^{~k_p n_p}\\cdot x_{n_1, n_2, \\dots, n_p} \\right) \\right) \\, , , where \\omega_{N_\\ell} = \\exp(-2\\pi i/N_\\ell) as shown above and the p output indices run from k_\\ell = 0, 1, \\dots, N_\\ell-1. If we want to express it in vector notation, where \\mathbf{n} = (n_1, n_2, \\dots, n_p) and \\mathbf{k} = (k_1, k_2, \\dots, k_p) are p-dimensional vectors of indices from 0 to \\mathbf{N} - 1, where \\mathbf{N} - 1 = (N_1 - 1, N_2 - 1, \\dots, N_p - 1), the P-Dimensional Discrete Forward Fourier Transform is given by : ' = \\sum_{\\mathbf{n}=\\mathbf{0}}^{\\mathbf{N}-1} e^{-2\\pi i \\mathbf{k^T} \\cdot (\\mathbf{n} / \\mathbf{N})} x_\\mathbf{n} \\, ,, where the division \\mathbf{n} / \\mathbf{N} is defined as \\mathbf{n} / \\mathbf{N} = (n_1/N_1, \\dots, n_p/N_p) to be performed element-wise, and the sum denotes the set of nested summations above. To find the P-Dimensional inverse Discrete Fourier Transform, we can use the following: = \\frac{1}{\\prod_{\\ell=1}^p N_\\ell} \\sum_{\\mathbf{k}=\\mathbf{0}}^{\\mathbf{N}-1} e^{2\\pi i \\mathbf{n} \\cdot (\\mathbf{k^T} / \\mathbf{N})} \\,. . The Discrete Fourier Transform is useful for certain applications such as Data Compression, Spectral Analysis, Polynomial Multiplication, etc. The DFT is also used as a building block for techniques that take advantage of properties of signals frequency-domain representation, such as the overlap-save and overlap-add fast convolution algorithms. However the computational complexity increases if Discrete Fourier Transform is used as the Discrete Transform. The computational complexity of the DFT is way higher than the other Discrete Transforms and for P-D DFT, the computational complexity is given by O(N_1^2N_2^2...N_P^2). Therefore, the Fast Fourier Transform(FFT) is used to compute the DFT as it reduces the computational complexity significantly to O(N_1N_2...N_PLog_2N_1N_2...N_P) and at the same time other Discrete Transforms are preferred over the DFT. ===Using discrete cosine transform (DCT)=== For a multidimensional array x_{n_1, n_2, \\dots, n_p} that is a function of p discrete variables n_\\ell = 0, 1, \\dots, N_\\ell-1 for \\ell in 1, 2, \\dots, p, the P-Dimensional Discrete Forward Cosine Transform is defined by: ''' \\begin{align}= \\sum_{n_1=0}^{N_1-1} \\sum_{n_2=0}^{N_2-1} \\cdots \\sum_{n_p=0}^{N_p-1} x_{n_1,n_2,\\cdots n_p} \\cos \\left[\\frac{\\pi}{N_1} \\left(n_1+\\frac{1}{2}\\right) k_1 \\right] \\cos \\left[\\frac{\\pi}{N_2} \\left(n_2+\\frac{1}{2}\\right) k_2 \\right] \\cdots \\cos \\left[\\frac{\\pi}{N_p} \\left(n_p+\\frac{1}{2}\\right) k_p \\right], k_1,k_2,\\cdots k_p=0,1,2,3....N-1. \\end{align} The P-Dimensional inverse Discrete Cosine Transform is given by: ''' \\begin{align}= \\sum_{k_1=0}^{N_1-1} \\sum_{k_2=0}^{N_2-1}\\cdots \\sum_{k_p=0}^{N-p-1} X_{k_1,k_2,\\cdots k_p} \\cos \\left[\\frac{\\pi}{N_1} \\left(n_1+\\frac{1}{2}\\right) k_1 \\right] \\cos \\left[\\frac{\\pi}{N_2} \\left(n_2+\\frac{1}{2}\\right) k_2 \\right]\\cdots \\cos \\left[\\frac{\\pi}{N_p} \\left(n_p+\\frac{1}{2}\\right) k_p \\right], n_1,n_2,\\cdots n_p=0,1,2,3....N-1. \\end{align} The DCT finds its use in data compression applications such as the JPEG image format. The DCT has high degree of spectral compaction at a qualitative level, which makes it very suitable for various compression applications. A signal's DCT representation tends to have more of its energy concentrated in a small number of coefficients when compared to other transforms like the DFT. Thus you can reduce your data storage requirement by only storing the DCT outputs that contain significant amounts of energy. The computational complexity of P-D DCT goes by O(N_1N_2...N_PLog_2N_1N_2...N_P). Since the number of operations required to compute the DCT is less than that required to compute the DFT without the use of FFT, the DCT's are also called as Fast Cosine Transforms(FCT). ===Using discrete Hartley transform (DHT)=== For a multidimensional array x_{n_1, n_2, \\dots, n_p} that is a function of p discrete variables n_\\ell = 0, 1, \\dots, N_\\ell-1 for \\ell in 1, 2, \\dots, p, the P-Dimensional Discrete Forward Hartley Transform is defined by: ''' =\\sum_{n_1=0}^{N_1-1} \\sum_{n_2=0}^{N_2-1} \\dots \\sum_{n_p=0}^{N_p-1} x(n_1,n_2,...,n_p)cas(\\frac{2\\pi n_1 k_1}{N_1}+\\dots +\\frac{2\\pi n_p k_p}{N_p}), where, k_i = 0,1,\\ldots, N_i-1 and where cas(x)=cos(x)+sin(x). If Discrete Hartley Transform is used, the computational complexity of complex numbers can be avoided. The overall computational complexity of P-D Discrete Hartley Transform is given by O(N_1N_2...N_PLog_2N_1N_2...N_P), if algorithms similar to the FFT are used and thus the DHT is also referred to as the Fast Hartley Transform(FHT). The Discrete Hartley Transform is used in various applications in communications and signal processing areas. Some of these applications include multidimensional filtering, multidimensional spectral analysis, error control coding, adaptive digital filters, image processing etc. ==Applications of MixeD Multidimensional Filters== Mixed 3-D filters can be used for enhancement of 3-D spatially planar signals. A 3-D MixeD Cone filter can be designed using 2-D DHT and is shown below. ===Review of 3-D Spatially Planar Signals=== An M-D signal, ' is considered to be spatially-planar(SP) if it is constant on all surfaces, i.e. \\alpha_1\\\\!n_1 \\+ \\alpha_2\\\\!n_2 +\\cdots \\+ \\alpha_M\\\\!n_M = d, for \\foralld \\inR where R is the set of real numbers. Therefore, a 3-D spatially planar signal, ' is constant on 3 surfaces and is given by \\alpha_1\\\\!n_1 \\+ \\alpha_2\\\\!n_2 \\+ \\alpha_3\\\\!n_3 = d, for \\foralld \\inR It may be shown that the 3-D DFT of a SP ' yields 3-D DFT frequency domain coefficients, ', which are zero everywhere except on the line ' where \\in \\\\{ Z\\vert k_1/\\alpha_1\\\\!=k_2/\\alpha_2\\\\!=k_3/\\alpha_3\\\\! \\\\},where Z refer to the set of integers. A 3-D signal input sequence will be selectively enhanced by a 3-D passband enclosing this line. Thus we make use of a cone filter having a thin pyramidal shaped passband which is approximated using Mixed filter constructed using 2-D DHT. ===Design of a 3-D MixeD cone filter using 2-D DHT=== Firstly, we have to select the passband regions on {k1,k2}. The close examination of DFT and DHT, shows that the 3-D DHT of ' of a spatially-planar signal ' is zero outside the straight line ' passing through the origin of 3-D DHT ' space. Therefore, \\in \\\\{ Z\\vert k_1/\\alpha_1\\\\!=k_2/\\alpha_2\\\\!}, where Z refer to the set of integers. All the LDE's that correspond to 2-tuples {k_1,k_2}, that lie outside the fan shaped projection of the thin pyramidal passband on the k_1-k_2 plane have to be omitted. The half angle will determine the k1-k2 plane bandwidth of the MixeD filter. Secondly, we have to find the characteristics of the LDE Input sequences X_H(k_1,k_2,n3). The LDE input sequences computed for the 2-D DHT of a S-P signal ', are real and sinusoidal in the steady-state. Since a spatially planar signal is also a linear trajectory signal, it maybe written in the form, ' = x(n_1 \\- p_1n_3, n_2 \\- p_2n_3,n_3 ), where p_1 = \\alpha_3\\\\!/\\alpha_1\\\\! and p_2 = \\alpha_3\\\\!/\\alpha_2\\\\!. Now, using the shift property of 2-D DHT, we get, X_H(k_1,k_2,n_3) = X_H(k_1,k_2,0)cos\\\\{W\\\\} \\+ X_H(N - k_1, N - k_2,0)cos\\\\{W\\\\}, where W = cos\\\\{2(p_1k_1 \\+ p_2k_2)(n_3\\pi)/N\\\\}. This equation implies that the passband sequences, X_H(k_1,k_2,n3) at each tuple {k_1,k_2} are real sampled sinusoids that may be selectively transmitted by employing LDE's that are characterized by narrowband bandpass magnitude frequency respone having Normalized frequencies given by, v = 2(p_1k_1 \\+ p_2k_2)/N. If we choose the bandwidths B{k_1,k_2} of these narrowband bandpass LDEs to be proportional to the centre frequencies v, so that B{k_1,k_2} = Kv, K > 0, and K constant, the required 3D pyramidal passband is realized. Thus it has been proved that 2-D DHT helped in the constructing a MixeD 3-D filter. ==References== Category:Digital signal processing Category:Multidimensional signal processing ",
    "title": "Multidimensional filter design and implementation"
}