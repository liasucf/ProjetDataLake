{
    "id": "60376830",
    "text": "d-dimensional hypercube is a network topology for parallel computers with 2^d processing elements. The topology allows for an efficient implementation of some basic communication primitives such as Broadcast, All-Reduce, and Prefix sum.Grama, A.(2003). Introduction to Parallel Computing. Addison Wesley; Auflage: 2 ed. . The processing elements are numbered 0 through 2^d - 1. Each processing element is adjacent to processing elements whose numbers differ in one and only one bit. The algorithms described in this page utilize this structure efficiently. == Algorithm outline == Most of the communication primitives presented in this article share a common template.Foster, I.(1995). Designing and Building Parallel Programs: Concepts and Tools for Parallel Software Engineering. Addison Wesley; . Initially, each processing element possesses one message that must reach every other processing element during the course of the algorithm. The following pseudo code sketches the communication steps necessary. Hereby, Initialization, Operation, and Output are placeholders that depend on the given communication primitive (see next section). Input: message m. Output: depends on Initialization, Operation and Output. Initialization s := m for 0 \\leq k < d do y := i \\text{ XOR } 2^k Send s to y Receive m from y Operation(s, m) endfor Output Each processing element iterates over its neighbors (the expression i \\text{ XOR } 2^k negates the k-th bit in i's binary representation, therefore obtaining the numbers of its neighbors). In each iteration, each processing element exchanges a message with the neighbor and processes the received message afterwards. The processing operation depends on the communication primitive. Algorithm outline applied to the 3-dimensional hypercube. In the first step (before any communication), each processing element possesses one message (blue). Communication is marked red. After each step, the processing elements store the received message, but other operations are also possible. == Communication primitives == === Prefix sum === In the beginning of a prefix sum operation, each processing element i owns a message m_i. The goal is to compute \\bigoplus_{0 \\le j \\le i} m_j, where \\oplus is an associative operation. The following pseudo code describes the algorithm. Input: message m_i of processor i. Output: prefix sum \\bigoplus_{0 \\le j \\le i} m_j of processor i. x := m_i \\sigma := m_i for 0 \\le k \\le d - 1 do y := i \\text{ XOR } 2^k Send \\sigma to y Receive m from y \\sigma := \\sigma \\oplus m if bit k in i is set then x := x \\oplus m endfor The algorithm works as follows. Observe that hypercubes of dimension d can be split into two hypercubes of dimension d - 1. Refer to the sub cube containing nodes with a leading 0 as the 0-sub cube and the sub cube consisting of nodes with a leading 1 as 1-sub cube. Once both sub cubes have calculated the prefix sum, the sum over all elements in the 0-sub cube has to be added to the every element in the 1-sub cube, since every processing element in the 0-sub cube has a lower rank than the processing elements in the 1-sub cube. The pseudo code stores the prefix sum in variable x and the sum over all nodes in a sub cube in variable \\sigma. This makes it possible for all nodes in 1-sub cube to receive the sum over the 0-sub cube in every step. This results in a factor of \\log p for T_\\text{start} and a factor of n\\log p for T_\\text{byte}: T(n,p) = (T_\\text{start} + nT_\\text{byte})\\log p. Example for a prefix sum calculation. Upper number: tentatetive prefix sum (variable x). Lower number: sum over all elements in the sub cube (variable \\sigma). === All-gather / all-reduce === All-gather operations start with each processing element having a message m_i. The goal of the operation is for each processing element to know the messages of all other processing elements, i.e. x := m_0 \\cdot m_1 \\dots m_p where \\cdot is concatenation. The operation can be implemented following the algorithm template. Input: message x := m_i at processing unit i. Output: all messages m_1 \\cdot m_2 \\dots m_p. x := m_i for 0 \\le k < d do y := i \\text{ XOR } 2^k Send x to y Receive x' from y x := x \\cdot x' endfor With each iteration, the transferred message doubles in length. This leads to a runtime of T(n,p) \\approx \\sum_{j=0}^{d-1}(T_\\text{start} + n \\cdot 2^jT_\\text{byte})= \\log(p) T_\\text{start} + (p-1)nT_\\text{byte}. The same principle can be applied to the All-Reduce operations, but instead of concatenating the messages, it performs a reduction operation on the two messages. So it is a Reduce operation, where all processing units know the result. Compared to a normal reduce operation followed by a broadcast, All-Reduce in hypercubes reduces the number of communication steps. === All-to-all === Here every processing element has a unique message for all other processing elements. Input: message m_{ij} at processing element i to processing element j. for d > k \\geq 0 do Receive from processing element i \\text{ XOR } 2^k: all messages for my k-dimensional sub cube Send to processing element i \\text{ XOR } 2^k: all messages for its k-dimensional sub cube endfor With each iteration a messages comes closer to its destination by one dimension, if it hasn't arrived yet. Hence, all messages have reached their target after at most d = \\log{p} steps. In every step, p / 2 messages are sent: in the first iteration, half of the messages aren't meant for the own sub cube. In every following step, the sub cube is only half the size as before, but in the previous step exactly the same number of messages arrived from another processing element. This results in a run- time of T(n,p) \\approx \\log{p} (T_\\text{start} + \\frac{p}{2}nT_\\text{byte}). == ESBT-broadcast == The ESBT-broadcast (Edge-disjoint Spanning Binomial Tree) algorithm is a pipelined broadcast algorithm with optimal runtime for clusters with hypercube network topology. The algorithm embeds d edge-disjoint binomial trees in the hypercube, such that each neighbor of processing element 0 is the root of a spanning binomial tree on 2^d - 1 nodes. To broadcast a message, the source node splits its message into k chunks of equal size and cyclically sends them to the roots of the binomial trees. Upon receiving a chunk, the binomial trees broadcast it. === Runtime === In each step, the source node sends one of its k chunks to a binomial tree. Broadcasting the chunk within the binomial tree takes d steps. Thus, it takes k steps to distribute all chunks and additionally d steps until the last binomial tree broadcast has finished, resulting in k + d steps overall. Therefore, the runtime for a message of length n is T(n, p, k) = \\left(\\frac{n}{k} T_\\text{byte} + T_\\text{start} \\right) (k + d). With the optimal chunk size k^* = \\sqrt{\\frac{nd \\cdot T_\\text{byte}}{T_\\text{start}}}, the optimal runtime of the algorithm is T^*(n, p) = n \\cdot T_\\text{byte} + \\log(p) \\cdot T_\\text{start} + \\sqrt{n \\log(p) \\cdot T_\\text{start} \\cdot T_\\text{byte}}. === Construction of the binomial trees === A 3-dimensional hypercubes with three ESBT embedded. This section describes how to construct the binomial trees systematically. First, construct a single binomial spanning tree von 2^d nodes as follows. Number the nodes from 0 to 2^d - 1 and consider their binary representation. Then the children of each nodes are obtained by negating single leading zeroes. This results in a single binomial spanning tree. To obtain d edge-disjoint copies of the tree, translate and rotate the nodes: for the k-th copy of the tree, apply a XOR operation with 2^k to each node. Subsequently, right-rotate all nodes by k digits. The resulting binomial trees are edge-disjoint and therefore fulfill the requirements for the ESBT- broadcasting algorithm. ==References== Category:Parallel computing ",
    "title": "Hypercube (communication pattern)"
}