{
    "id": "1272999",
    "text": "This article discusses support programs included in or available for OS/360 and successors. IBM categorizes some of these programs as utilities and others as service aids; the boundaries are not always consistent or obvious. Many, but not all, of these programs match the types in utility software. The following lists describe programs associated with OS/360 and successors. No DOS, TPF or VM utilities are included. ==History/Common JCL== Many of these programs were designed by IBM users, through the group SHARE, and then modified or extended by IBM from versions originally written by a user. These programs are usually invoked via Job Control Language (JCL). They tend to use common JCL DD identifiers (in the OS, now z/OS operating systems) for their data sets: {|class=\"wikitable\" |- ! DDNAME !! Usual function |- | SYSIN || input file for the 'commands' for the utility. Often set to DUMMY if the default action is desired |- | SYSUT1 || input file |- | SYSUT2 || output file |- | SYSUT3 || work (spill) file for input (SYSUT1) (often not used) |- | SYSUT4 || work (spill) file for output (SYSUT2) (often not used) |- | SYSPRINT || output file for printed output from the utility |- | SYSOUT || output file for messages from the utility |- | SYSUDUMP || output file for a system 'dump' if the program fails |} ==Dataset utilities== ===IDCAMS=== IDCAMS (\"Access Method Services\") generates and modifies Virtual Storage Access Method (VSAM) and Non-VSAM datasets. IDCAMS was introduced along with VSAM in OS/VS; the \"Access Method\" reference derives from the initial \"VSAM replaces all other access methods\" mindset of OS/VS. IDCAMS probably has the most functionality of all the utility programs, performing many functions, for both VSAM and non- VSAM files. The following example illustrates the use of IDCAMS to copy a dataset to disk. The dataset has 80-byte records, and the system will choose the block size for the output: //XXXXXXXW JOB XXXXXXX,AAAA,CLASS=G,MSGCLASS=1,NOTIFY=&SYSUID; //STEP001 EXEC PGM=IDCAMS //SYSIN DD * REPRO INFILE(FILE01) OUTFILE(FILE02) /* //FILE01 DD DSN=PROD.FILE1.INPUT,disp=shr ..... //FILE02 DD DSN=PROD.FILE2.OUTPUT, // DISP=(NEW,CATLG,DELETE), // UNIT=DASD, // SPACE=(TRK,(100,10),RLSE), // DCB=(RECFM=FB,BLKSIZE=0,LRECL=80) //SYSPRINT DD SYSOUT=* //SYSOUT DD SYSOUT=* //SYSUDUMP DD SYSOUT=* //* In the example above, SYSIN control cards are coming from an in-stream file, but you can instead point to any sequential file or a PDS member containing control cards or a temporary data-set, if you wish. Example of using SYSIN files would be something like this: //SYSIN DD DSN=PROD.MYFILE.REPRO,DISP=SHR or this: //SYSIN DD DSN=PROD.MYLIB.CNTLLIB(REPRO), // DISP=SHR ===IEBCOMPR=== IEBCOMPR compares records in sequential or partitioned data sets. The IEBCOMPR utility is used to compare two sequential or partitioned datasets. This data set comparison is performed at the logical record level. Therefore, IEBCOMPR is commonly used to verify that a backup copy of a data set is correct (exact match to the original). During processing, IEBCOMPR compares each record from each data set, one by one. If the records are unequal, IEBCOMPR lists the following information in the SYSOUT: * The record and block numbers in question. * The names of the DD statements in which the inconsistency occurred. * The unequal records. When comparing sequential data sets, IEBCOMPR considers the data sets equal if the following conditions are met: :* The data sets contain the same number of records. :* The corresponding records and keys are identical. For partitioned data sets, IEBCOMPR considers the data sets equal if the following conditions are met: :* The directory entries for the two partitioned data sets match - that is, the names are the same, and the number of entries are equal. :* The corresponding members contain the same number of records. :* The corresponding records and keys are identical. If ten unequal comparisons are encountered during processing, IECOMPR terminates with the appropriate message. //XXXXXXXW JOB XXXXXXX,AAAA.A.A,CLASS=G,MSGCLASS=1,NOTIFY=XXXXX //STEP01 EXEC PGM=IEBCOMPR,ACCT=PJ00000000 // INCLUDE MEMBER=@BATCHS //*SYSIN DD DUMMY //SYSIN DD * COMPARE TYPORG=PO /* //SYSUT1 DD DSN=XXXXXXX.OLDFILE,UNIT=DASD,DISP=SHR //SYSUT2 DD DSN=XXXXXXX.NEWFILE,UNIT=DASD,DISP=SHR //SYSUT# DD Note: IEBCOMPR is not a very flexible or user-friendly compare program. It can't restrict the comparison to only certain columns, it can't ignore differences in white space, it doesn't tell you where in the record the difference occurs, and it halts after 10 differences. On the other hand, it is fast, and it is present on all IBM mainframes. So it is very useful when an exact match is expected, such as comparing load modules that have not been reblocked, or checking that a copy worked properly. For comparisons of programs or reports, the ISPF SuperC (ISRSUPC) compare program is often used instead. ===IEBCOPY=== IEBCOPY copies, compresses and merges partitioned data sets. It can also select or exclude specified members during the copy operation, and rename or replace members. Some of the tasks that IEBCOPY can perform include the following: * Creating an unload of a partitioned data set (PDS) to a PS dataset, for backup or transmission. * Copying a PDS in place to reclaim the unused space from deleted members; also called compressing a PDS. * Copying selected members to another PDS. * Renaming selected members of a PDS. * Merging multiple partitioned data sets into a single PDS. * Altering, copying and reblocking load modules. * Members that are already present in another PDS will not get replaced unless the R option is specified. For the IEBCOPY utility, the required job control statements for a copy are as follows: //stepname EXEC PGM=IEBCOPY //SYSPRINT DD SYSOUT=class //MYDD1 DD DSN=xxxx.ppp.psps,DISP=SHR //MYDD2 DD DSN=xxxx.ppp.pssp,DISP=SHR //SYSIN DD * COPY INDD=MYDD1,OUTDD=MYDD2 SELECT MEMBER=(MEM1,MEM2,MEM3)/ EXCLUDE MEMBER=(SF,DF,SA) The MYDD1 and MYDD2 DD statements are names chosen by the user for the partitioned input and output data sets, respectively; The defaults are SYSUT1 and SYSUT2. You can use any valid DDNAME for these two DD statements. These DDNAMEs are specified in the utility control statements to tell IEBCOPY the name of the input and output data sets. You only need one DD statement for a PDS to be compressed. ===IEBDG=== IEBDG ('Data Generator') creates test datasets consisting of patterned data. Control statements define the fields of the records to be created, including position, length, format, and initialization to be performed. IEBDG can use an existing dataset as input and change fields as specified in the control statements, for example replacing a name field by random alphabetic text. The contents of each field may be varied for each record, for example by rotating the characters in an alphanumeric field left or right for each subsequent record. Example: //XXXXXXXW JOB XXXXXXX,AAAA,CLASS=G,MSGCLASS=1,NOTIFY=&SYSUID; //********************************************************************** //* CREATION OF A DATASET To BE USED LATER ON //********************************************************************** //CRSTEP EXEC PGM=IEFBR14 //DDCREA DD DSN=&SYSUID..MVSUT.SEQOUT;,DISP=(NEW,CATLG) //********************************************************************** //* CREATION OF THE TESTDATA //********************************************************************** //STEP1 EXEC PGM=IEBDG //SYSPRINT DD SYSOUT=* //SEQOUT DD DSN=&SYSUID..MVSUT.SEQOUT;,DISP=OLD //SYSIN DD DATA DSD OUTPUT=(SEQOUT) FD NAME=FIELD1,LENGTH=30,STARTLOC=1,FORMAT=AL,ACTION=TL FD NAME=FIELD2,LENGTH=30,STARTLOC=31,FORMAT=AL,ACTION=TR FD NAME=FIELD3,LENGTH=10,STARTLOC=71,PICTURE=10, X P'1234567890',INDEX=1 CREATE QUANTITY=500,NAME=(FIELD1,FIELD2,FIELD3),FILL=X'FF' END /* //********************************************************************** //* PRINTING THE TEST DATA TO SYSOUT //********************************************************************** //STEP2 EXEC PGM=IEBGENER //SYSPRINT DD SYSOUT=* //SYSUT1 DD DSN=*.STEP1.SEQOUT,DISP=SHR //SYSIN DD DUMMY //SYSUT2 DD SYSOUT=* //********************************************************************** //* DELETE THE CREATED DATASET, EVEN IF PREVIOUS STEPS ABENDED //********************************************************************** //DLSTEP EXEC PGM=IEFBR14,COND=EVEN //DDDEL DD DSN=&SYSUID..MVSUT.SEQOUT;,DISP=(OLD,DELETE,DELETE) // ===IEBEDIT=== IEBEDIT selectively copies portions of JCL. An example of an IEBEDIT program: //IEBEDITJ JOB ACCT,,CLASS=P,MSGCLASS=T,MSGLEVEL=(1,1),NOTIFY=&SYSUID; //STEP0001 EXEC PGM=IEBEDIT //SYSPRINT DD SYSOUT=* //SYSUT1 DD DSN=xxxxx.yyyyy.zzzzz,DISP=SHR //SYSUT2 DD SYSOUT=(*,INTRDR) //SYSIN DD * EDIT TYPE=INCLUDE,STEPNAME=(STEP10,STEP5,STEP15) /* // In this example, data set xxxxx.yyyyy.zzzzz should contain job(s) (which should include steps named STEP5, STEP10, and STEP15). This IEBEDIT routine copies the selected steps of the job onto the SYSUT2 output file (in this example, the internal reader. The syntax of the EDIT statement is: [label] EDIT [START=jobname] [,TYPE={POSITION|INCLUDE|EXCLUDE}] [,STEPNAME=(namelist)] [,NOPRINT] `START=jobname` specifies the name of the input job to which the EDIT statement applies. Each EDIT statement must apply to a separate job. If START is specified without TYPE and STEPNAME, the JOB statement and all job steps for the specified job are included in the output. Default: If START is omitted and only one EDIT statement is provided, the first job encountered in the input data set is processed. If START is omitted from an EDIT statement other than the first statement, processing continues with the next JOB statement found in the input data set. `TYPE={POSITION|INCLUDE|EXCLUDE}` specifies the contents of the output data set. These values can be coded: `POSITION` specifies that the output is to consist of a JOB statement, the job step specified in the STEPNAME parameter, and all steps that follow that job step. All job steps preceding the specified step are omitted from the operation. POSITION is the default. `INCLUDE` specifies that the output data set is to contain a JOB statement and all job steps specified in the STEPNAME parameter. `EXCLUDE` specifies that the output data set is to contain a JOB statement and all job steps belonging to the job except those steps specified in the STEPNAME parameter. `STEPNAME=(namelist)` specifies the names of the job steps that you want to process. `namelist` can be a single job step name, a list of step names separated by commas, or a sequential range of steps separated by a hyphen (for example, STEPA-STEPE). Any combination of these may be used in one namelist. If more than one step name is specified, the entire namelist must be enclosed in parentheses. When coded with TYPE=POSITION, STEPNAME specifies the first job step to be placed in the output data set. Job steps preceding this step are not copied to the output data set. When coded with TYPE=INCLUDE or TYPE=EXCLUDE, STEPNAME specifies the names of job steps that are to be included in or excluded from the operation. For example, STEPNAME=(STEPA,STEPF-STEPL,STEPZ) indicates that job steps STEPA, STEPF through STEPL, and STEPZ are to be included in or excluded from the operation. If STEPNAME is omitted, the entire input job whose name is specified on the EDIT statement is copied. If no job name is specified, the first job encountered is processed. `NOPRINT` specifies that the message data set is not to include a listing of the output data set. Default: The resultant output is listed in the message data set. See here for more info: ===IEBGENER=== IEBGENER copies records from a sequential dataset, or creates a partitioned dataset. Some of the tasks that IEBGENER can perform include the following: * Creating a backup of a sequential data set or a member of a PDS. * Changing the physical block size or logical record length of a sequential data set. * Creating an edited data set. * Printing a sequential data set or a member of a PDS. * Creating partitioned output data set from sequential input data set. An example of an IEBGENER program to copy one dataset to another: //IEBGENER JOB ACCT,'DATA COPY',MSGCLASS=J,CLASS=A //STEP010 EXEC PGM=IEBGENER //SYSUT1 DD DSN=xxxxx.yyyyy.zzzzz,DISP=SHR //SYSUT2 DD DSN=aaaaa.bbbbb.ccccc,DISP=(,CATLG), // UNIT=SYSDA,SPACE=(TRK,(5,5),RLSE), // DCB=(RECFM=FB,LRECL=1440) //SYSPRINT DD SYSOUT=* //SYSIN DD DUMMY For straight copy tasks, the sort program can often do these faster than IEBGENER. Thus many mainframe shops make use of an option that automatically routes such tasks to the sort ICEGENER program instead of IEBGENER. On some systems it is possible to send email from a batch job by directing the output to the \"`SMTP`\" external writer. On such systems, the technique is as follows: //IEBGENER JOB ACCT,'DATA COPY',MSGCLASS=J,CLASS=A //NORMRC EXEC PGM=IEBGENER //SYSPRINT DD SYSOUT=* //SYSUT1 DD *,LRECL=80 HELO MAIL FROM: RCPT TO: DATA From: To: Subject: Test Mail TEST MAIL FROM MAINFRAME . QUIT /* //SYSUT2 DD SYSOUT=(B,SMTP),LRECL=80 //SYSIN DD DUMMY It is also possible to attach files while sending the email from Mainframe. ===IEBIMAGE=== IEBIMAGE manipulates several types of definitions (AKA images) for the IBM 3800 laser printing subsystem and the IBM 4248 printer. Common uses are for forms control buffers (FCBs), character arrangement tables, character definitions and images of forms to be printed on the output along with the text, for company logos to be printed on the page, or just to print 'graybar' pages (alternating gray & white horizontal backgrounds, to match the previous greenbar paper). With this utility, many different forms or logos could be stored as images, and printed when needed, all using the same standard blank paper, thus eliminating the need to stock many preprinted forms, and the need for operators to stop the printer and change paper. ===IEBISAM=== IEBISAM unloads, loads, copies and prints ISAM datasets. Extracted from IBM manual SC26-7414-08 z/OS DFSMSdfp Utilities: The IEBISAM program is no longer distributed. Starting in z/OS V1R7, ISAM data sets can no longer be processed (created, opened, copied or dumped). ISAM data sets that are still in use must be converted to VSAM key- sequenced data sets. Prior to z/OS V1R7, you could use access method services to allocate a VSAM key-sequenced data set and copy an ISAM data set into it. ===IEBPTPCH=== IEBPTPCH (\"PrinT and PunCH\") prints or punches records from a sequential or partitioned dataset. Some of the tasks that IEBPTPCH can perform include the following: * Printing or punching an entire data set, sequential or partitioned (PDS). * Printing or punching selected PDS members. * Printing or punching selected records from a sequential or partitioned data set. * Printing or punching a PDS directory. * Printing or punching an edited version of a sequential data set or PDS. * Check for empty dataset //IEBPTPCH JOB // EXEC PGM=IEBPTPCH //SYSIN DD * PRINT MAXFLDS=2 TITLE ITEM=('Name',22), ITEM=('GPA',50) TITLE ITEM=(' ',1) RECORD FIELD=(25,1,,22), FIELD=(4,51,,50) /* //SYSPRINT DD SYSOUT=* //SYSUT1 DD * Person 1 307 C Meshel Hall 3.89 Second person 123 Williamson Hall 2.48 3rd person 321 Maag Library 1.52 /* //SYSUT2 DD SYSOUT=* // Empty dataset check: If dataset to be checked is empty then RC=4 else 0. //IEBPTPCH JOB // EXEC PGM=IEBPTPCH //SYSUT1 DD DSN=,DISP=SHR //SYSUT2 DD DUMMY, // DCB=(BLKSIZE=,RECFM=FA) //SYSIN DD * PRINT TYPORG=PS /* //SYSPRINT DD SYSOUT=* // === IEBTCRIN=== Read records from a 2495 Tape Cartridge Reader. ===IEBUPDAT=== Changes records in a sequential dataset or in a member of a partitioned dataset, replaced by, but not compatible with, IEBUPDTE. ===IEBUPDTE=== IEBUPDTE (\"UPDaTE\") incorporates changes to sequential or partitioned datasets. The UNIX `patch` utility is a similar program, but uses different input format markers (e..g, \"./ INSERT ...\" in MVS becomes \"@@...\" in Unix Patch). Some programmers pronounce it \"I.E.B. up- ditty\". The IEBUPDTE utility is used to maintain source libraries. Some of the functions that IEBUPDTE can perform include the following: * Creating and updating libraries * Modifying sequential data sets or PDS members * Changing the organization of a data set from sequential to partitioned or from partitioned to sequential. IEBUPDTE is commonly used to distribute source libraries from tape to DASD. IEBUPDTE uses the same job control statements required by most IEB-type utilities. The only exceptions are as follow: * IEBUPDTE accepts a PARM parameter coded on the EXEC statement, NEW or MOD. NEW indicates that the utility control statements and the input data are contained in the SYSIN DD statement, so no SYSUT1 DD statement is needed. MOD indicates that the SYSIN DD statement contains only utility control statements, without input data. Therefore, the SYSUT1 DD statement is required to define the input data set. * IEBUPDTE reads the input data set from either the SYSUT1 DD statement or from the SYSIN DD statement. The job control used by IEUPDTE are as follows: //stepname EXEC PGM=IEUPDTE,PARM=NEW //SYSPRINT DD SYSOUT=class //SYSUT1 DD ... //SYSUT2 DD ... //SYSIN DD ... ==Scheduler utilities== ===IEFBR14=== IEFBR14 is a dummy program, normally inserted in JCL when the only desired action is allocation or deletion of datasets. An example of an IEFBR14 step: //IEFBR14 JOB ACCT,'DELETE DATASET' //STEP01 EXEC PGM=IEFBR14 //DELDD DD DSN=xxxxx.yyyyy.zzzzz, // DISP=(MOD,DELETE,DELETE),UNIT=DASD The calling sequence for OS/360 contained the return address in Register 14. A branch to Register 14 would thus immediately exit the program. However, before and after executing this program, the operating system would allocate & deallocate datasets as specified in the DD statements, so it is commonly used as a quick way to set up or remove datasets. It consisted initially as a single instruction a \"Branch to Register\" 14. The mnemonic used in the IBM Assembler was BR and hence the name: IEF BR 14. IEF is, of course, the \"prefix\" of OS/360's \"job management\" subsystem. This single instruction program had an error in it \u2014 it didn't set the return code. Hence a second instruction had to be added to clear the return code so that it would exit with the correct status. There was an additional error reported and fixed by IBM on this now two instruction program. This error was due to the IEFBR14 program not being link-edited as reenterable (simultaneously usable by more than one caller). Some hackers have taken IEFBR14 and changed the BR 14 instruction to BR 15, thereby creating \"the shortest loop in the world\", as register 15 contains the address of the IEFBR14 module itself, and a BR 15 instruction would simply re-invoke the module, forever. ==System utilities== These utilities are normally used by systems programmers in maintaining the operation of the system, rather than by programmers in doing application work on the system. ===ICKDSF=== ICKDSF (\"Device Support Facility\") installs, initializes and maintains DASD, either under an operating system, or standalone. ===IEHATLAS=== Assign alternate tracks to defective tracks. ===IEHDASDR=== IEHDASDR can performs several operations for direct access storage devices (DASD) * Initialize a DASD volume, with optional surface checking * Assign alternate tracks to defective tracks * Print tracks on a DASD * Create a backup of a DASD volume on tape * Restore DASD volumes from backup tapes. IBM eventually stopped adding support for new device types to IEHDASDR and directed customers to the free DSF for initializing volumes and to the chargeable DASDR (5740-UT1) and Data Facility/Data Set Services (5740-UT3, DF/DSS) for dump/restore. IBM removed IEHDASDR in MVS/XA. ===IEHINITT=== IEHINITT (\"INITialize Tape\") initializes tapes by writing tape labels. Multiple tapes may be labeled in one run of the utility. IBM standard or ASCII labels may be written. An example of an IEHINITT program: //IEHINITT JOB ACCT,'LABEL TAPES',MSGCLASS=J,CLASS=A //STEP0001 EXEC PGM=IEHINITT,REGION=8M //SYSPRINT DD SYSOUT=A //LABEL DD DCB=DEN=2,UNIT=(3490,1,DEFER) //SYSIN DD * LABEL INITT SER=123450,NUMBTAPE=3 /* This example will label 3 tapes on a 3490 magnetic tape unit. Each tape will receive an IBM standard label. The VOLSER will be incremented by one for each tape labeled. Each tape will be rewound and unloaded after being labeled. ===IEHIOSUP=== Update TTR links for type IV Supervisor Call (SVC) routines in SYS1.SVCLIB. Not applicable to OS/VS2 or later. ===IEHLIST=== IEHLIST is a utility used to list entries in a Partitioned Dataset (PDS) directory or to list the contents of a Volume Table of Contents (VTOC). The IEHLIST utility is used to list the entries contained in any one of the following: * PDS directory * VTOC * Catalog (OS CVOL) An example of an IEHLIST program: //IEHLIST JOB ACCT,'LIST PDS',MSGCLASS=J,CLASS=A //STEP0001 EXEC PGM=IEHLIST,REGION=8M //SYSPRINT DD SYSOUT=A //PDS1 DD DSN=xxxx.yyyy.zzzz,DISP=OLD //SYSIN DD * LISTPDS DSNAME=xxxx.yyyy.zzzz,FORMAT /* This job will produce a formatted listing of the PDS directory of the PDS named xxxx.yyyy.zzzz. An example of an IEHLIST program to list a VTOC is very similar: //IEHLIST JOB ACCT,'LIST VTOC',MSGCLASS=J,CLASS=A //STEP0001 EXEC PGM=IEHLIST,REGION=8M //SYSPRINT DD SYSOUT=A //VOL1 DD VOL=SER=vvvvvv,DISP=OLD //SYSIN DD * LISTVTOC VOL=SER=vvvvvv,FORMAT /* ===IEHMOVE=== IEHMOVE moves or copies collections of data. However, DFSMS (System Managed Storage) environments are now common, and IBM does not recommend using the IEHMOVE utility in those. A move differs from a copy in that following a move the original data set is deleted, or scratched. Some of the tasks that IEHMOVE can perform include the following: *Moving or copying sequential and partitioned data sets *Moving or copying multi- volume data sets *Moving an entire volume of data sets On the surface, IEHMOVE may seen redundant to the IEBGENER and IEBCOPY utilities. However, IEHMOVE is more powerful. The main advantage of using IEHMOVE is that you do not need to specify space or DCB information for the new data sets. This is because IEHMOVE allocates this information based on the existing data sets. Another advantage of IEHMOVE is that you can copy or move groups of data sets as well as entire volumes of data. Because of the ease in moving groups of data sets or volumes, the IEHMOVE utility is generally favored by systems programmers. A sample IEHMOVE job: //stepname EXEC PGM=IEHMOVE,PARM='LINECNT=xx,POWER=n' //SYSPRINT DD SYSOUT=class //SYSUT1 DD UNIT=aaaa,VOL=SER=bbbbbb,DISP=OLD //anyname1 DD UNIT=cccc,VOL=SER=dddddd,DISP=OLD //anyname2 DD UNIT=eeee,VOL=SER=ffffff,DISP=OLD //SYSIN DD ... The DD statements for IEHMOVE, other than SYSPRINT and SYSIN, refer to DASD or magnetic tape volumes instead of individual data sets. However, referencing volumes can pose a problem, since specifying `DISP=OLD` gains exclusive access to a volume. Therefore, while your IEHMOVE job runs, that entire volume (and all datasets on it) is unavailable to other users. This is acceptable for private volumes, such as tape or mountable DASD volumes, but unacceptable public volumes. The SYSUT1 DD statement specifies a DASD volume where three work data set required by IEHMOVE are allocated. You must specify unit and volume information for this DD statement. IEHMOVE was one of the first systems to be developed in PL/S. In this example, three sequential data sets (SEQSET1, SEQSET2, and SEQSET3) are moved from one disk volume to three separate disk volumes. Each of the three receiving volumes is mounted when it is required by IEHMOVE. The source data sets are not cataloged. Space is allocated by IEHMOVE. //MOVEDS JOB ... //STEP1 EXEC PGM=IEHMOVE //SYSPRINT DD SYSOUT=A //SYSUT1 DD UNIT=disk,VOLUME=SER=333333,DISP=OLD //DD1 DD UNIT=(disk,,DEFER),DISP=OLD, // VOLUME=(PRIVATE,,SER=(222222)) //DD2 DD UNIT=(disk,,DEFER),DISP=OLD, // VOLUME=(PRIVATE,,SER=(222333)) //DD3 DD UNIT=(disk,,DEFER),DISP=OLD, // VOLUME=(PRIVATE,,SER=(222444)) //DD4 DD VOLUME=(PRIVATE,RETAIN,SER=(444444)), // UNIT=disk,DISP=OLD //SYSIN DD * MOVE DSNAME=SEQSET1,TO=disk=222222,FROM=disk=444444 MOVE DSNAME=SEQSET2,TO=disk=222333,FROM=disk=444444 MOVE DSNAME=SEQSET3,TO=disk=222444,FROM=disk=444444 /* ===IEHPROGM=== IEHPROGM builds and maintains system control data. It is also used for renaming and scratching (deleting) a data set. Some of the tasks that IEHPROGM can perform include the following: * Deleting (scratching) a data set or PDS member * Renaming a data set or PDS member * Cataloging or uncataloging a data set * Maintaining data set passwords in the system PASSWORD dataset For cataloging: //SYSIN DD * CATLG DSNNAME=data-set-name, VOL=device-name=volume-number /* // ===IFHSTATR=== Select and format SMF records for tape errors. ==Independent Utilities== These programs do not run under the control of an operating system ===IBCDASD=== Format direct access volumes and assign alternate tracks. === IBCDMPRS=== Dump and restore direct access volumes. ===IBCRCVRP=== Assign alternate tracks, recover and replace data. === ICAPRTBL=== Load Forms Control Buffer (FCB) and Universal Character Set (UCS) buffer on printer. ==Service Aids== These are utility program that IBM documents in service aids or diagnosis manuals. The original OS/360 Service aids had names beginning with IFC and IM*, but IBM changed the naming convention to HM* for OS/VS1 and to AM* for OS/VS2. IBM did not change the IFC convention. ===IFCDIPOO=== Initializes the SYS1.LOGREC data set. ===IFCEREPO=== Summarizes and prints records from the SYS1.LOGREC error recording data set. ===GTF (Generalized Trace Facility)=== Traces selected system events such as SVC and I/O interruptions. ===IMAPTFLE=== Generates JCL needed to apply to a PTF and/or applies the PTF. The functions of this program have been subsumed by SMP. ===IMASPZAP=== Verifies and/or replaces instructions and/or data in a load module or program object ===IMBLIST=== Formats and prints object modules, load modules, program objects and CSECT identification records. ===IMBMDMAP=== Maps load modules. The functions of this program have been subsumed by IMBLIST. ===IMCJQDMP=== Stand-alone program to format and print the system job queue. Not applicable to MVS. ===IMCOSJQD=== Format and print the system job queue. Not applicable to MVS. ===IMDPRDMP=== Formats and prints dumps, TSO swap data set, and GTF trace data. ===IMDSADMP=== Stand-alone program to produce a high- speed or low-speed dump of main storage. ==Miscellaneous supporting programs== ===SORT=== The Sort/Merge utility is a program which sorts records in a file into a specified order, or merge pre-sorted files. It is very frequently used; often the most commonly used application program in a mainframe shop. Modern sort/merge programs also can select or omit certain records, summarize records, remove duplicates, reformat records, and produce simple reports. Sort/merge is important enough that there are multiple companies each selling their own sort/merge package for IBM mainframes. IBM's original OS/360 sort/merge program, 360S-SM-023, program name IERRCO00 (alias SORT), supported only IBM's first-generation direct-access storage devices (DASD) and tapes (2400). Support for second-generation disk drives was provided by IBM program products such as 5734-SM1 and the later 5740-SM1 (DFSORT, alias ICEMAN, also SORT). SORT is frequently executed as a stand-alone program, where it normally reads input from a file identified by DD `SORTIN` and writes sorted output to a file identified by DD `SORTOUT`. It is also often called from another application, via the COBOL `SORT` verb or calls to PL/I `PLISRTx` routines, where it may use either `SORTIN` or `SORTOUT` files or be passed records to be sorted by the caller and/or pass sorted records back to the caller one at a time. The operation of SORT is directed by control statements, which are largely compatible among various IBM and third-party sort programs. The `SORT` or `MERGE` statement defines the sort keys\u2014 the fields on which the data is to be sorted or merged. This statement identifies the position, length, and data type of each key. The `RECORD` statement describes the format and length of the records in the input file. Other statements allow the user to specify which records should be included or excluded from the sort and specify other transformations to be performed on the data. Keys can be any combination of EBCDIC or ASCII character data, zoned or packed-decimal, signed or unsigned fixed-point binary, or hexadecimal floating-point. Keys can be located anywhere in the record and do not have to be contiguous. Sorting can be specified on any combination of ascending and descending sequence by key. The OS/360 sort program, IERRCO00, operates by dividing the input data into sections, sorting each section in main memory, and writing the sorted section to intermediate datasets on either direct-access storage devices (DASD) or magnetic tape. Final merge phases then merge the sections to produce the sorted output. SORT uses one of a number of techniques for distributing the sections among secondary storage devices. Usually SORT can choose the optimal technique, but this can be overridden by the user. SORT has three techniques that can be used if the intermediate storage is tape, and two if disk. The tape techniques are: * Balanced (BALN) - more efficient if more tape drives are available for intermediate storage. * Polyphase (POLY) - used if fewer tape drives are available for intermediate storage. * Oscillating (OSCL) - uses more main storage. The size of the input dataset must be known or closely approximated. The disk techniques are: * Balanced Direct Access (BALN) - uses three to six intermediate storage datasets. * Crisscross Direct Access (CRCX) - uses six to seventeen intermediate storage datasets, requires twice the main storage of the Balanced Direct Access technique. ===Linkers=== OS/360 had only the Linkage editor, available in several configurations. DFSMSdfp added the Binder as an alternatives for load modules, and as the only option for program objects. ====Linkage Editor==== The Linkage editor creates and replaces load modules in a partitioned data set from a combination of control cards, object modules other load modules. It can rename or replace a control section (CSECT) and perform several other miscellaneous functions. It was originally available in several configurations depending on storage requirement, but the E level Linkage Editor is no longer available and the F level Linkage Editor is now known simply as the Linkage Editor. In z/OS the Linkage Editor is only present for compatibility. ====Binder==== The binder performs the same functions as the Linkage Editor. In addition, it supports a new format, the program object, which is the functional equivalent of a load module in Partitioned Data Set Extended (PDSE), with many additional capabilities. ===Compilers=== Each programming language used in a computer shop will have one or more associated compilers that translate a source program into a machine-language object module. Then the object module from the compiler must be processed by the linkage editor, IEWL, to create an executable load module. IGYCRCTL is a common example of a compiler; it is the compiler for the current IBM Enterprise COBOL for z/OS product. (There have been several previous IBM COBOL compilers over the years, with different names.) There are many other compilers for various other programming languages. ====IETASM==== Assembler (E) was intended for OS/360 running in very small machines. ====IEUASM==== Assembler (F) was intended for normal OS/360 installations. ====IFOX00==== Assembler (XF) was the system assembler for OS/VS1 and OS/VS2, replacing Assembler (E) and (F), although it was not fully compatible with them. IBM soon made Assembler (XF) the system assembler for DOS and VM as well. ====IEV90==== Assembler (H) and Assembler (H) Version 2 are program product assemblers that are generally faster than Assemblers E, F, and XF, although not fully compatible with any of them. ====ASMA90==== IBM High Level Assembler (HLASM) is essentially a new version of Assembler (H) Version 2 and is the only assembler that IBM supports on z/OS and z/VM. It replaces all of the older assemblers, although it is not fully compatible with them. ===System Modification Program (SMP)=== System Modification Program (SMP) is the vehicle for installing service on OS/360 and successors, replacing, e.g., stand-alone assembly, link edit and IMAPTFLE jobs. Originally an optional facility, it is mandatory for MVS/SP and later, and the program product version, SMP/E, is included in the more recent systems, e.g., z/OS. ==Notes== ==References== ==See also == * Syncsort * Easytrieve ==External links== * DFSMSdfp Utilities * DFSMS Access Method Services for Catalogs * DFSMSdss Storage Administration Guide * MVS UTILITIES Mainframe utility programs Category:Utility software ",
    "title": "Support programs for OS/360 and successors"
}