{
    "id": "52905583",
    "text": "Quantum counting algorithm is a quantum algorithm for efficiently counting the number of solutions for a given search problem. The algorithm is based on the quantum phase estimation algorithm and on Grover's search algorithm. Counting problems are common in diverse fields such as statistical estimation, statistical physics, networking, etc. As for quantum computing, the ability to perform quantum counting efficiently is needed in order to use Grover's search algorithm (because running Grover's search algorithm requires knowing how many solutions exist). Moreover, this algorithm solves the quantum existence problem (namely, deciding whether any solution exists) as a special case. The algorithm was devised by Gilles Brassard, Peter H\u00f8yer and Alain Tapp in 1998. == The problem == Consider a finite set \\\\{0,1\\\\}^n of size N=2^n and a set B of \"solutions\" (that is a subset of \\\\{0,1\\\\}^n ). Define: : \\begin{cases} f : \\left\\\\{0,1\\right\\\\}^n \\to \\\\{0,1\\\\} \\\\\\ f(x) = \\begin{cases} 1 & x \\in B \\\\\\ 0 & x otin B \\end{cases} \\end{cases} In other words, f is the indicator function of B. Calculate the number of solutions M = \\left\\vert f^{-1}(1) \\right\\vert = \\vert B \\vert. === Classical solution === Without any prior knowledge on the set of solutions B (or the structure of the function f), a classical deterministic solution cannot perform better than \\Omega(N), because all the N elements of \\\\{0,1\\\\}^n must be inspected (consider a case where the last element to be inspected is a solution). == The algorithm == Quantum counting circuit ===Setup=== The input consists of two registers (namely, two parts): the upper p qubits comprise the first register, and the lower n qubits are the second register. ===Create superposition=== The initial state of the system is |0\\rangle^{\\otimes p}|0\\rangle^{\\otimes n}. After applying multiple bit Hadamard gate operation on each of the registers separately, the state of the first register is :\\frac{1}{2^{p/2}}(|0\\rangle + |1\\rangle)^{\\otimes p} and the state of the second register is :\\frac{1}{2^{n/2}}(|0\\rangle + |1\\rangle)^{\\otimes n} = \\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}|x\\rangle an equal superposition state in the computational basis. ===Grover operator=== Because the size of the space is \\left\\vert \\\\{0,1\\\\}^n \\right\\vert = 2^n = N and the number of solutions is \\left\\vert B \\right\\vert = M , we can define the normalized states: : |\\alpha\\rangle = \\frac{1}{\\sqrt{N-M}} \\sum_{x otin B}{|x\\rangle}, \\qquad \\text{and} \\qquad |\\beta\\rangle = \\frac{1}{\\sqrt{M}} \\sum_{x \\in B}{|x\\rangle}. Note that : \\sqrt{\\frac{N-M}{N}}|\\alpha\\rangle + \\sqrt{\\frac{M}{N}}|\\beta\\rangle = \\frac{1}{\\sqrt{N}}\\sum_{x=0}^{N-1}{|x\\rangle}, which is the state of the second register after the Hadamard transform. Geometric visualization of Grover's algorithm shows that in the two-dimensional space spanned by |\\alpha\\rangle and |\\beta\\rangle, the Grover operator is a counterclockwise rotation; hence, it can be expressed as : G = \\begin{bmatrix} \\cos \\theta & -\\sin \\theta \\\\\\ \\sin \\theta & \\cos \\theta\\end{bmatrix} in the orthonormal basis \\\\{|\\alpha\\rangle, |\\beta\\rangle\\\\}. From the properties of rotation matrices we know that G is a unitary matrix with the two eigenvalues e^{\\pm i \\theta}. ===Estimating the value of \\theta=== From here onwards, we follow the quantum phase estimation algorithm scheme: we apply controlled Grover operations followed by inverse quantum fourier transform; and according to the analysis, we will find the best p-bit approximation to the real number \\theta (belonging to the eigenvalues e^{\\pm i \\theta} of the Grover operator) with probability higher than \\frac{4}{\\pi^2}. Note that the second register is actually in a superposition of the eigenvectors of the Grover operator (while in the original quantum phase estimation algorithm, the second register is the required eigenvector). This means that with some probability, we approximate \\theta, and with some probability, we approximate 2\\pi - \\theta; those two approximations are equivalent. === Analysis === Assuming that the size N of the space is at least twice the number of solutions (namely, assuming that M \\leq \\tfrac{N}{2} ), a result of the analysis of Grover's algorithm is: : \\sin {\\frac{\\theta}{2}} = \\sqrt{\\frac{M}{N}}. Thus, if we find \\theta, we can also find the value of M (because N is known). The error : \\frac{\\vert \\Delta M \\vert}{N} = \\left \\vert \\sin^2 \\left( \\frac{\\theta + \\Delta \\theta}{2} \\right) - \\sin^2 \\left( \\frac{\\theta}{2} \\right) \\right \\vert is determined by the error within estimation of the value of \\theta. The quantum phase estimation algorithm finds, with high probability, the best p-bit approximation of \\theta; this means that if p is large enough, we will have \\Delta \\theta \\approx 0, hence \\vert \\Delta M \\vert \\approx 0 . == Uses == ===Grover's search algorithm for an initially-unknown number of solutions=== In Grover's search algorithm, the number of iterations that should be done is \\frac{\\pi}{4}\\sqrt{\\frac{N}{M}}. Thus, if N is known and M is calculated by the quantum counting algorithm, the number of iterations for Grover's algorithm is easily calculated. ===Speeding up NP-complete problems=== The quantum counting algorithm can be used to speed up solution to problems which are NP-complete. An example of an NP-complete problem is the Hamiltonian cycle problem, which is the problem of determining whether a graph G=(V,E) has a Hamiltonian cycle. A simple solution to the Hamiltonian cycle problem is checking, for each ordering of the vertices of G, whether it is a Hamiltonian cycle or not. Searching through all the possible orderings of the graph's vertices can be done with quantum counting followed by Grover's algorithm, achieving a speedup of the square root, similar to Grover's algorithm. This approach finds a Hamiltonian cycle (if exists); for determining whether a Hamiltonian cycle exists, the quantum counting algorithm itself is sufficient (and even the quantum existence algorithm, described below, is sufficient). ===Quantum existence problem=== Quantum existence problem is a special case of quantum counting where we do not want to calculate the value of M, but we only wish to know whether M eq 0 or not. A trivial solution to this problem is directly using the quantum counting algorithm: the algorithm yields M, so by checking whether M eq 0 we get the answer to the existence problem. This approach involves some overhead information because we are not interested in the value of M. Using a setup with small number of qubits in the upper register will not produce an accurate estimation of the value of \\theta, but will suffice to determine whether M equals zero or not. == See also == * Quantum phase estimation algorithm * Grover's algorithm * Counting problem (complexity) == References == Category:Quantum algorithms ",
    "title": "Quantum counting algorithm"
}