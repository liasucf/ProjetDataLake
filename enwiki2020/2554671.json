{
    "id": "2554671",
    "text": "In computer science, overhead is any combination of excess or indirect computation time, memory, bandwidth, or other resources that are required to perform a specific task. It is a special case of engineering overhead. Overhead can be a deciding factor in software design, with regard to structure, error correction, and feature inclusion. Examples of computing overhead may be found in functional programming, data transfer, and data structures. ==Software design== ===Choice of implementation=== A programmer/software engineer may have a choice of several algorithms, encodings, data types or data structures, each of which have known characteristics. When choosing among them, their respective overhead should also be considered. ===Tradeoffs=== In software engineering, overhead can influence the decision whether or not to include features in new products, or indeed whether to fix bugs. A feature that has a high overhead may not be included \u2013 or needs a big financial incentive to do so. Often, even though software providers are well aware of bugs in their products, the payoff of fixing them is not worth the reward, because of the overhead. For example, an implicit data structure or succinct data structure may provide low space overhead, but at the cost of slow performance (space/time tradeoff). ===Run- time complexity of software=== Algorithmic complexity is generally specified using Big O Notation. This makes no comment on how long something takes to run or how much memory it uses, but how its increase depends on the size of the input. Overhead is deliberately not part of this calculation, since it varies from one machine to another, whereas the fundamental running time of an algorithm does not. This should be contrasted with algorithmic efficiency, which takes into account all kinds of resources \u2013 a combination (though not a trivial one) of complexity and overhead. ==Examples== ===Computer Programming (run-time and computational overhead)=== Invoking a function introduces a small run-time overhead. Sometimes the compiler can minimize this overhead by inlining some of these function calls. ===CPU Caches=== In a CPU cache, the \"cache size\" (or capacity) refers to how much data a cache stores. For instance, a \"4KB cache\" is a cache that holds 4KB of data. The \"4KB\" in this example excludes overhead bits such as frame, address, and tag information. Presentation for course in Computer Architecture. ===Communications (data transfer overhead)=== Reliably sending a payload of data over a communications network requires sending more than just payload itself. It also involves sending various control and signalling data (TCP) required to reach the destination. This creates a so-called protocol overhead as the additional data does not contribute to the intrinsic meaning of the message.Common Performance Issues in Network Applications Part 1: Interactive Applications, Windows XP Technical Articles, MicrosoftProtocol Overhead in IP/ATM Networks, Minnesota Supercomputer Center In telephony, number dialing and call set-up time are overheads. In 2-way (but half-duplex) radios, the use of \"over\" and other signalling needed to avoid collisions is an overhead. Protocol overhead can be expressed as a percentage of non-application bytes (protocol and frame synchronization) divided by the total number of bytes in the message. ===Encodings and data structures (size overhead)=== The encoding of information and data introduces overhead too. The date and time \"2011-07-12 07:18:47\" can be expressed as Unix time with the 32-bit signed integer `1310447927`, consuming only 4 bytes. Represented as ISO 8601 formatted UTF-8 encoded string `2011-07-12 07:18:47` the date would consume 19 bytes, a size overhead of 375% over the binary integer representation. As XML this date can be written as follows with an overhead of 218 characters, while adding the semantic context that it is a CHANGEDATE with index 1. 2011 07 12 07 18 47 The 349 bytes, resulting from the UTF-8 encoded XML, correlates to a size overhead of 8625% over the original integer representation. ==See also== *Rule of least power *Universal Turing machine ==References== Category:Software engineering ",
    "title": "Overhead (computing)"
}