{
    "id": "60381359",
    "text": "In automata theory, an alternating timed automaton (ATA) is a mix of both timed automaton and alternating finite automaton. That is, it is a sort of automata which can measure time and in which there exists universal and existential transition. ATAs are more expressive than timed automaton. one clock alternating timed automaton (OCATA) is the restriction of ATA allowing the use of a single clock. OCATAs allow to express timed languages which can not be expressed using timed-automaton. == Definition == An alternating timed automaton is defined as a timed automaton, where the transitions are more complex. === Difference from a timed-automaton === Given a set X, let \\mathcal B^+(X) the set of positive Boolean combination of elements of X. I.e. the set containing the elements of X, and containing \\phi\\land\\psi and \\phi\\lor\\psi, for \\phi,\\psi\\in\\mathcal B^+(X). For each letter a and location \\ell, let \\mathcal B_{a,\\ell} be a set of clock constraints such that their zones partition \\mathbb R_{\\ge 0}^{|X|}, with |X| the number of clocks. Given a clock valuation u, let c(a,\\ell, u) be the only clock constraint of \\mathcal B_{a,\\ell} which is satisfied by u. An alternating timed-automaton contains a transition function, which associates to a 3-tuple (\\ell,a,c), with c\\in\\mathcal B_{a,\\ell}, to an element of \\mathcal B^+(L\\times\\mathcal P(C)). For example, (\\ell_1,\\emptyset)\\lor((\\ell_2,\\\\{x\\\\})\\land(\\ell_2,\\\\{y\\\\})) is an element of \\mathcal B^+(L\\times\\mathcal P(C)). Intuitively, it means that the run may either continue by moving to location \\ell_1, and resetting no clock. Or by moving to location \\ell_2 and should be successful when either x or y is reset. === Formal definition === Formally, an alternating timed automaton is a tuple \\mathcal A=\\langle \\Sigma,L,L_0,C,F,E\\rangle that consists of the following components: * \u03a3 is a finite set called the alphabet or actions of \\mathcal A. * L is a finite set. The elements of L are called the locations or states' of \\mathcal A. * C is a finite set called the clocks of \\mathcal A. * L_0\\subseteq L is the set of start locations. * F\\subseteq L is the set of accepting locations. * E\\subseteq L\\times\\Sigma\\times\\mathcal B(C)\\to\\mathcal B^+(L\\times \\mathcal P(C)) is the transitions function of \\mathcal A. It is a partial function, defined as explained in the previous section. Any Boolean expression can be rewritten into an equivalent expression in disjunctive normal form. In the representation of a ATA, each disjunction is represented by a different arrow. Each conjunct of a disjunction is represented by a set of arrows with the same tail and multiple heads. The tail is labelled by the letter and each head is labelled by the set of clocks it resets. == Run == We now define a run of an alternating timed automaton over a timed word w=(\\sigma_1,t_1),(\\sigma_2,t_2),\\dots,. There are two equivalent way to define a run, either as a tree or as a game. === Run as a tree === In this definition of a run, a run is not anymore a list of pairs, but a rooted tree. The node of the trooted tree are labelled by pairs with a location and a clock valuation. The tree is defined as follows: * the root of the tree is of the form (\\ell_0, u_0) with \\ell_0\\in L_0, * Consider a node n of the tree at depth i, with label (\\ell, u). Without loss of generality, let us assume that E(a_{i+1},\\ell,c(a,\\ell, u)) is in disjunctive normal form, i.e. it is of the form \\bigvee_{i=1}^n\\bigwedge_{j=1}^{m_i}(\\ell_{i,j}, r_{i,j}). Then the node n has m_i children, for some 1\\le i\\le n. The j-th child is labelled by (\\ell_{i,j},( u+t_{i+1}-t_{i})[r_{i,j}\\to 0]. The definition of an accepting runs differs depending on whether the timed word is finite or infinite. If the timed word is finite, then the run is accepting if the label of each leaf contains an accepting location. If the timed word is infinite, then a run is accepting if each branch contains an infinite number of accepting location. === Run as a game === A run can also be defined as a two player game G_{A,w}. Let us call the two players \"player\" and \"opponent\". The goal of the player is to create an accepting run and the goal of the opponent is to create a rejecting (non-accepting) run. Each state of the game is a tuple composed of a location, a clock valuation, a position in the word, and potentially an element of \\mathcal B^+(L\\times\\mathcal P(C)). Intuitively, a tuple (\\ell, u,i,b) means that the run has read i letters, is in location \\ell, with clock value u, and that the transition will be as described by b. The run is defined as follow: * The initial state is of the form (\\ell_0, u_0, 0), for some \\ell_0\\in L_0. * given a state (\\ell, u,i), if the length of the word is i, the run ends. Otherwise, its successor state is (\\ell, u,i,c(a_{i+1},\\ell, u)). * The successor of a state (\\ell, u,i,(\\ell',r)) is the state (\\ell', u+t_{i}-t_{i-1}[r\\to0],i+1), * The successor of a state (\\ell, u,i,\\phi\\lor\\psi) is chosen by the player, it is either (\\ell, u,i,\\phi) or (\\ell, u,i,\\psi), * The successor of a state (\\ell, u,i,\\phi\\land\\psi) is chosen by the opponent, it is either (\\ell, u,i,\\phi) or (\\ell, u,i,\\psi). The set of successive states starting in a state of the form (\\ell, u,i) and ending in before the next such state is called a phase. The definition of an accepting run is the same than for timed automata. == Subclass of ATA == === One clock alternating timed automaton === A one clock alternating timed automaton (OCATA) is an alternating timed automaton using a single clock. The expressivity of OCATAs and of timed-automaton are incomparable. For example, the language over the alphabet \\\\{a\\\\} such that there is never exactly one time unit between two letters can not be recognized by a timed-automaton. However, the OCATA pictured nearbyOCATA accepting the language in which no two letters occurs at 1 time unit of interval accepts itOCATA accepting the language in which no two letters occurs at 1 time unit of interval. In this alternating timed automaton, two branches are started. A branch restarts the clock x, and ensures that each time in the future when a letter is emitted, the clock x is distinct from 1. This ensure that between this letter and the next ones, the time elapsed is not one. The second branch only waits for other letters to be emitted and do the same checking. === Purely-Universal and Purely-Exisential ATA === An ATA is said to be purely-universal (respectively, purely- exisential) if its transition function does not use disjunction (respectively, conjunction). Purely-existential ATAs are as expressive as non-deterministic timed-automaton. == Closure == The class of language accepted by ATAs and by OCATAs is closed under complement. The construction is explained for the case where there is a single initial location. Given an ATA \\mathcal A=\\langle \\Sigma,L,\\\\{q_0\\\\},C,F,E\\rangle accepting a timed language L, its complement language L^c is accepted by an automaton A^c which is essentially \\langle \\Sigma,L,\\\\{q_0\\\\},C,L\\setminus F,E'\\rangle, where E'(\\ell,a,c) is defined as E(\\ell,a,c)) where disjunction and conjunctions are reversed and E'(q_0,a,c) simulates the run from each of the locations of L_0 simultaneously. It follows that the class of language accepted by ATAs and by OCATAs are accepted by unions and intersection. The union of two languages is constructed by taking disjoint copies of the automata accepting both language. The intersection can be constructed from union and concatenation. == Complexity == The emptiness problem, the universality problem and the containability problem for OCATA is decidable but is a nonelementary problem. Those three problems are undecidable over ATAs. ==References== Category:Automata (computation) Category:Model checking ",
    "title": "Alternating timed automaton"
}