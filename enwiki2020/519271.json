{
    "id": "519271",
    "text": "In numerical analysis, inverse iteration (also known as the inverse power method) is an iterative eigenvalue algorithm. It allows one to find an approximate eigenvector when an approximation to a corresponding eigenvalue is already known. The method is conceptually similar to the power method. It appears to have originally been developed to compute resonance frequencies in the field of structural mechanics. Ernst Pohlhausen, Berechnung der Eigenschwingungen statisch-bestimmter Fachwerke, ZAMM - Zeitschrift f\u00fcr Angewandte Mathematik und Mechanik 1, 28-42 (1921). The inverse power iteration algorithm starts with an approximation \\mu for the eigenvalue corresponding to the desired eigenvector and a vector b_0, either a randomly selected vector or an approximation to the eigenvector. The method is described by the iteration : b_{k+1} = \\frac{(A - \\mu I)^{-1}b_k}{C_k}, where C_k are some constants usually chosen as C_k= \\|(A - \\mu I)^{-1}b_k \\|. Since eigenvectors are defined up to multiplication by constant, the choice of C_k can be arbitrary in theory; practical aspects of the choice of C_k are discussed below. At every iteration, the vector b_k is multiplied by the matrix (A - \\mu I)^{-1} and normalized. It is exactly the same formula as in the power method, except replacing the matrix A by (A - \\mu I)^{-1}. The closer the approximation \\mu to the eigenvalue is chosen, the faster the algorithm converges; however, incorrect choice of \\mu can lead to slow convergence or to the convergence to an eigenvector other than the one desired. In practice, the method is used when a good approximation for the eigenvalue is known, and hence one needs only few (quite often just one) iterations. == Theory and convergence == The basic idea of the power iteration is choosing an initial vector b (either an eigenvector approximation or a random vector) and iteratively calculating Ab, A^{2}b, A^{3}b,.... Except for a set of zero measure, for any initial vector, the result will converge to an eigenvector corresponding to the dominant eigenvalue. The inverse iteration does the same for the matrix (A - \\mu I)^{-1}, so it converges to the eigenvector corresponding to the dominant eigenvalue of the matrix (A - \\mu I)^{-1}. Eigenvalues of this matrix are (\\lambda_1 - \\mu)^{-1},...,(\\lambda_n - \\mu)^{-1}, where \\lambda_i are eigenvalues of A. The largest of these numbers corresponds to the smallest of (\\lambda_1 - \\mu),...,(\\lambda_n - \\mu). The eigenvectors of A and of (A - \\mu I)^{-1} are the same, since Av=\\lambda v \\Leftrightarrow (A-\\mu I)v = \\lambda v - \\mu v \\Leftrightarrow (\\lambda - \\mu)^{-1} v = (A-\\mu I)^{-1} v Conclusion: The method converges to the eigenvector of the matrix A corresponding to the closest eigenvalue to \\mu . In particular, taking \\mu=0 we see that (A)^{-1}b_k converges to the eigenvector corresponding to the eigenvalue of A with the smallest absolute value . === Speed of convergence === Let us analyze the rate of convergence of the method. The power method is known to converge linearly to the limit, more precisely: \\mathrm{Distance}( b^\\mathrm{ideal}, b^{k}_\\mathrm{Power~Method})=O \\left( \\left| \\frac{\\lambda_\\mathrm{subdominant} }{\\lambda_\\mathrm{dominant} } \\right|^k \\right), hence for the inverse iteration method similar result sounds as: \\mathrm{Distance}( b^\\mathrm{ideal}, b^{k}_\\mathrm{Inverse~iteration})=O \\left( \\left| \\frac{\\mu -\\lambda_{\\mathrm{closest~ to~ }\\mu} }{\\mu - \\lambda_{\\mathrm{second~ closest~ to~} \\mu} } \\right|^k \\right). This is a key formula for understanding the method's convergence. It shows that if \\mu is chosen close enough to some eigenvalue \\lambda , for example \\mu- \\lambda = \\epsilon each iteration will improve the accuracy |\\epsilon| /|\\lambda +\\epsilon - \\lambda_{\\mathrm{closest~ to~} \\lambda} | times. (We use that for small enough \\epsilon \"closest to \\mu\" and \"closest to \\lambda \" is the same.) For small enough |\\epsilon| it is approximately the same as |\\epsilon| /|\\lambda - \\lambda_{\\mathrm{closest~ to~} \\lambda}| . Hence if one is able to find \\mu , such that the \\epsilon will be small enough, then very few iterations may be satisfactory. === Complexity === The inverse iteration algorithm requires solving a linear system or calculation of the inverse matrix. For non-structured matrices (not sparse, not Toeplitz,...) this requires O(n^{3}) operations. == Implementation options == The method is defined by the formula: : b_{k+1} = \\frac{(A - \\mu I)^{-1}b_k}{C_k}, There are, however, multiple options for its implementation. === Calculate inverse matrix or solve system of linear equations === We can rewrite the formula in the following way: : (A - \\mu I) b_{k+1} = \\frac{b_k}{C_k}, emphasizing that to find the next approximation b_{k+1} we may solve a system of linear equations. There are two options: one may choose an algorithm that solves a linear system, or one may calculate the inverse (A - \\mu I)^{-1} and then apply it to the vector. Both options have complexity O(n3), the exact number depends on the chosen method. The choice depends also on the number of iterations. Naively, if at each iteration one solves a linear system, the complexity will be k*O(n3), where k is number of iterations; similarly, calculating the inverse matrix and applying it at each iteration is of complexity k*O(n3). Note, however, that if the eigenvalue estimate \\mu remains constant, then we may reduce the complexity to O(n3) + k*O(n2) with either method. Calculating the inverse matrix once, and storing it to apply at each iteration is of complexity O(n3) + k*O(n2). Storing an LU decomposition of (A - \\mu I) and using forward and back substitution to solve the system of equations at each iteration is also of complexity O(n3) + k*O(n2). Inverting the matrix will typically have a greater initial cost, but lower cost at each iteration. Conversely, solving systems of linear equations will typically have a lesser initial cost, but require more operations for each iteration. === Tridiagonalization, Hessenberg form === If it is necessary to perform many iterations (or few iterations, but for many eigenvectors), then it might be wise to bring the matrix to the upper Hessenberg form first (for symmetric matrix this will be tridiagonal form). Which costs \\begin{matrix}\\frac{10}{3}\\end{matrix} n^3 + O(n^2) arithmetic operations using a technique based on Householder reduction), with a finite sequence of orthogonal similarity transforms, somewhat like a two-sided QR decomposition..Lloyd N. Trefethen and David Bau, Numerical Linear Algebra (SIAM, 1997). (For QR decomposition, the Householder rotations are multiplied only on the left, but for the Hessenberg case they are multiplied on both left and right.) For symmetric matrices this procedure costs \\begin{matrix}\\frac{4}{3}\\end{matrix} n^3 + O(n^2) arithmetic operations using a technique based on Householder reduction. Solution of the system of linear equations for the tridiagonal matrix costs O(n) operations, so the complexity grows like O(n^3) + kO(n), where k is the iteration number, which is better than for the direct inversion. However, for few iterations such transformation may not be practical. Also transformation to the Hessenberg form involves square roots and the division operation, which are not universally supported by hardware. === Choice of the normalization constant C_k === On general purpose processors (e.g. produced by Intel) the execution time of addition, multiplication and division is approximately equal. But on embedded and/or low energy consuming hardware (digital signal processors, FPGA, ASIC) division may not be supported by hardware, and so should be avoided. Choosing C_k=2^{n_k} allows fast division without explicit hardware support, as division by a power of 2 may be implemented as either a bit shift (for fixed-point arithmetic) or subtraction of k from the exponent (for floating-point arithmetic). When implementing the algorithm using fixed-point arithmetic, the choice of the constant C_k is especially important. Small values will lead to fast growth of the norm of b_k and to overflow; large values of C_k will cause the vector b_k to tend toward zero. == Usage == The main application of the method is the situation when an approximation to an eigenvalue is found and one needs to find the corresponding approximate eigenvector. In such a situation the inverse iteration is the main and probably the only method to use. === Methods to find approximate eigenvalues === Typically, the method is used in combination with some other method which finds approximate eigenvalues: the standard example is the bisection eigenvalue algorithm, another example is the Rayleigh quotient iteration, which is actually the same inverse iteration with the choice of the approximate eigenvalue as the Rayleigh quotient corresponding to the vector obtained on the previous step of the iteration. There are some situations where the method can be used by itself, however they are quite marginal. === Norm of matrix as approximation to the dominant eigenvalue === The dominant eigenvalue can be easily estimated for any matrix. For any induced norm it is true that \\left \\| A \\right \\| \\ge |\\lambda| , for any eigenvalue \\lambda. So taking the norm of the matrix as an approximate eigenvalue one can see that the method will converge to the dominant eigenvector. === Estimates based on statistics === In some real-time applications one needs to find eigenvectors for matrices with a speed of millions of matrices per second. In such applications, typically the statistics of matrices is known in advance and one can take as an approximate eigenvalue the average eigenvalue for some large matrix sample. Better, one may calculate the mean ratio of the eigenvalues to the trace or the norm of the matrix and estimate the average eigenvalue as the trace or norm multiplied by the average value of that ratio. Clearly such a method can be used only with discretion and only when high precision is not critical. This approach of estimating an average eigenvalue can be combined with other methods to avoid excessively large error. == See also == *Power iteration *Rayleigh quotient iteration * List of eigenvalue algorithms ==References== Category:Numerical linear algebra ",
    "title": "Inverse iteration"
}