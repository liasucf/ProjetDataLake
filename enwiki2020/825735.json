{
    "id": "825735",
    "text": "Verlet integration () is a numerical method used to integrate Newton's equations of motion. It is frequently used to calculate trajectories of particles in molecular dynamics simulations and computer graphics. The algorithm was first used in 1791 by Delambre and has been rediscovered many times since then, most recently by Loup Verlet in the 1960s for use in molecular dynamics. It was also used by Cowell and Crommelin in 1909 to compute the orbit of Halley's Comet, and by Carl St\u00f8rmer in 1907 to study the trajectories of electrical particles in a magnetic field (hence it is also called St\u00f6rmer's method). The Verlet integrator provides good numerical stability, as well as other properties that are important in physical systems such as time reversibility and preservation of the symplectic form on phase space, at no significant additional computational cost over the simple Euler method. ==Basic St\u00f6rmer\u2013Verlet== For a second-order differential equation of the type \\ddot{\\vec x}(t) = \\vec A\\big(\\vec x(t)\\big) with initial conditions \\vec x(t_0) = \\vec x_0 and \\dot{\\vec x}(t_0) = \\vec v_0, an approximate numerical solution \\vec x_n \\approx \\vec x(t_n) at the times t_n = t_0 + n\\,\\Delta t with step size \\Delta t > 0 can be obtained by the following method: * set \\vec x_1 = \\vec x_0 + \\vec v_0\\,\\Delta t + \\frac12 \\vec A(\\vec x_0)\\,\\Delta t^2, * for n = 1, 2, ... iterate *: \\vec x_{n+1} = 2 \\vec x_n - \\vec x_{n-1} + \\vec A(\\vec x_n)\\,\\Delta t^2. ===Equations of motion=== Newton's equation of motion for conservative physical systems is :M \\ddot{\\vec x}(t) = F\\big(\\vec x(t)\\big) = - abla V\\big(\\vec x(t)\\big), or individually :m_k \\ddot{\\vec x}_k(t) = F_k\\big(\\vec x(t)\\big) = - abla_{\\vec x_k} V\\big(\\vec x(t)\\big), where : t is the time, : \\vec x(t) = \\big(\\vec x_1(t), \\ldots, \\vec x_N(t)\\big) is the ensemble of the position vector of N objects, : V is the scalar potential function, : F is the negative gradient of the potential, giving the ensemble of forces on the particles, : M is the mass matrix, typically diagonal with blocks with mass m_k for every particle. This equation, for various choices of the potential function V, can be used to describe the evolution of diverse physical systems, from the motion of interacting molecules to the orbit of the planets. After a transformation to bring the mass to the right side and forgetting the structure of multiple particles, the equation may be simplified to :\\ddot{\\vec x}(t) = A\\big(\\vec x(t)\\big) with some suitable vector-valued function A representing the position-dependent acceleration. Typically, an initial position \\vec x(0) = \\vec x_0 and an initial velocity \\vec v(0) = \\dot{\\vec x}(0) = \\vec v_0 are also given. ===Verlet integration (without velocities)=== To discretize and numerically solve this initial value problem, a time step \\Delta t > 0 is chosen, and the sampling-point sequence t_n = n\\,\\Delta t considered. The task is to construct a sequence of points \\vec x_n that closely follow the points \\vec x(t_n) on the trajectory of the exact solution. Where Euler's method uses the forward difference approximation to the first derivative in differential equations of order one, Verlet integration can be seen as using the central difference approximation to the second derivative: : \\frac{\\Delta^2\\vec x_n}{\\Delta t^2} = \\frac{\\frac{\\vec x_{n+1} - \\vec x_n}{\\Delta t} - \\frac{\\vec x_n - \\vec x_{n-1}}{\\Delta t}}{\\Delta t} = \\frac{\\vec x_{n+1} - 2 \\vec x_n + \\vec x_{n-1}}{\\Delta t^2} = \\vec a_n = \\vec A(\\vec x_n). Verlet integration in the form used as the St\u00f6rmer methodwebpage with a description of the St\u00f6rmer method. uses this equation to obtain the next position vector from the previous two without using the velocity as : \\vec x_{n+1} = 2 \\vec x_n - \\vec x_{n-1} + \\vec a_n\\,\\Delta t^2, \\qquad \\vec a_n = \\vec A(\\vec x_n). ===Discretisation error=== The time symmetry inherent in the method reduces the level of local errors introduced into the integration by the discretization by removing all odd-degree terms, here the terms in \\Delta t of degree three. The local error is quantified by inserting the exact values \\vec x(t_{n-1}), \\vec x(t_n), \\vec x(t_{n+1}) into the iteration and computing the Taylor expansions at time t = t_n of the position vector \\vec{x}(t \\pm \\Delta t) in different time directions: :\\begin{align} \\vec{x}(t + \\Delta t) &= \\vec{x}(t) + \\vec{v}(t)\\Delta t + \\frac{\\vec{a}(t) \\Delta t^2}{2} \\+ \\frac{\\vec{b}(t) \\Delta t^3}{6} + \\mathcal{O}(\\Delta t^4)\\\\\\ \\vec{x}(t - \\Delta t) &= \\vec{x}(t) - \\vec{v}(t)\\Delta t + \\frac{\\vec{a}(t) \\Delta t^2}{2} \\- \\frac{\\vec{b}(t) \\Delta t^3}{6} + \\mathcal{O}(\\Delta t^4), \\end{align} where \\vec{x} is the position, \\vec{v} = \\dot{\\vec x} the velocity, \\vec{a} = \\ddot{\\vec x} the acceleration, and \\vec{b} the jerk (third derivative of the position with respect to the time). Adding these two expansions gives :\\vec{x}(t + \\Delta t) = 2\\vec{x}(t) - \\vec{x}(t - \\Delta t) + \\vec{a}(t) \\Delta t^2 + \\mathcal{O}(\\Delta t^4). We can see that the first- and third- order terms from the Taylor expansion cancel out, thus making the Verlet integrator an order more accurate than integration by simple Taylor expansion alone. Caution should be applied to the fact that the acceleration here is computed from the exact solution, \\vec a(t) = A\\big(\\vec x(t)\\big), whereas in the iteration it is computed at the central iteration point, \\vec a_n = A(\\vec x_n). In computing the global error, that is the distance between exact solution and approximation sequence, those two terms do not cancel exactly, influencing the order of the global error. ===A simple example=== To gain insight into the relation of local and global errors, it is helpful to examine simple examples where the exact solution, as well as the approximate solution, can be expressed in explicit formulas. The standard example for this task is the exponential function. Consider the linear differential equation \\ddot x(t) = w^2 x(t) with a constant w. Its exact basis solutions are e^{wt} and e^{-wt}. The St\u00f6rmer method applied to this differential equation leads to a linear recurrence relation :x_{n+1} - 2x_n + x_{n-1} = h^2 w^2 x_n, or :x_{n+1} - 2\\left(1 + \\tfrac12(wh)^2\\right) x_n + x_{n-1} = 0. It can be solved by finding the roots of its characteristic polynomial q^2 - 2\\left(1 + \\tfrac12(wh)^2\\right)q + 1 = 0. These are :q_\\pm = 1 + \\tfrac12(wh)^2 \\pm wh \\sqrt{1 + \\tfrac14(wh)^2}. The basis solutions of the linear recurrence are x_n = q_+^n and x_n = q_-^n. To compare them with the exact solutions, Taylor expansions are computed: :\\begin{align} q_+ &= 1 + \\tfrac12(wh)^2 + wh\\left(1 + \\tfrac18(wh)^2 - \\tfrac{3}{128}(wh)^4 + \\mathcal O(h^6)\\right)\\\\\\ &= 1 + (wh) + \\tfrac12(wh)^2 + \\tfrac18(wh)^3 - \\tfrac{3}{128}(wh)^5 + \\mathcal O(h^7). \\end{align} The quotient of this series with the one of the exponential e^{wh} starts with 1 - \\tfrac1{24}(wh)^3 + \\mathcal O(h^5), so :\\begin{align} q_+ &= \\left(1 - \\tfrac1{24}(wh)^3 + \\mathcal O(h^5)\\right)e^{wh}\\\\\\ &= e^{-\\frac{1}{24}(wh)^3 + \\mathcal O(h^5)}\\,e^{wh}. \\end{align} From there it follows that for the first basis solution the error can be computed as :\\begin{align} x_n = q_+^{\\;n} &= e^{-\\frac{1}{24}(wh)^2\\,wt_n + \\mathcal O(h^4)}\\,e^{wt_n}\\\\\\ &= e^{wt_n}\\left(1 - \\tfrac{1}{24}(wh)^2\\,wt_n + \\mathcal O(h^4)\\right)\\\\\\ &= e^{wt_n} + \\mathcal O(h^2 t_n e^{wt_n}). \\end{align} That is, although the local discretization error is of order 4, due to the second order of the differential equation the global error is of order 2, with a constant that grows exponentially in time. ===Starting the iteration=== Note that at the start of the Verlet iteration at step n = 1, time t = t_1 = \\Delta t, computing \\vec x_2, one already needs the position vector \\vec x_1 at time t = t_1. At first sight, this could give problems, because the initial conditions are known only at the initial time t_0 = 0. However, from these the acceleration \\vec a_0 = \\vec A(\\vec x_0) is known, and a suitable approximation for the position at the first time step can be obtained using the Taylor polynomial of degree two: : \\vec x_1 = \\vec{x}_0 + \\vec{v}_0 \\Delta t + \\tfrac12 \\vec a_0 \\Delta t^2 \\approx \\vec{x}(\\Delta t) + \\mathcal{O}(\\Delta t^3). The error on the first time step then is of order \\mathcal O(\\Delta t^3). This is not considered a problem because on a simulation over a large number of time steps, the error on the first time step is only a negligibly small amount of the total error, which at time t_n is of the order \\mathcal O(e^{Lt_n} \\Delta t^2), both for the distance of the position vectors \\vec x_n to \\vec x(t_n) as for the distance of the divided differences \\tfrac{\\vec x_{n+1} - \\vec x_n}{\\Delta t} to \\tfrac{\\vec x(t_{n+1}) - \\vec x(t_n)}{\\Delta t}. Moreover, to obtain this second-order global error, the initial error needs to be of at least third order. ===Non- constant time differences=== A disadvantage of the St\u00f6rmer\u2013Verlet method is that if the time step (\\Delta t) changes, the method does not approximate the solution to the differential equation. This can be corrected using the formula : \\vec x_{i+1} = \\vec x_i \\+ (\\vec x_i - \\vec x_{i-1}) (\\Delta t_i / \\Delta t_{i-1}) \\+ \\vec a_i \\Delta t_i^2. A more exact derivation uses the Taylor series (to second order) at t_i for times t_{i+1} = t_i + \\Delta t_i and t_{i-1} = t_i - \\Delta t_{i-1} to obtain after elimination of \\vec v_i : \\frac{\\vec x_{i+1} - \\vec x_i}{\\Delta t_i} \\+ \\frac{\\vec x_{i-1} - \\vec x_i}{\\Delta t_{i-1}} = \\vec a_i\\,\\frac{\\Delta t_{i} + \\Delta t_{i-1}}2, so that the iteration formula becomes : \\vec x_{i+1} = \\vec x_i \\+ (\\vec x_i - \\vec x_{i-1}) \\frac{\\Delta t_i}{\\Delta t_{i-1}} \\+ \\vec a_i\\,\\frac{\\Delta t_{i} + \\Delta t_{i-1}}2\\,\\Delta t_i. ===Computing velocities \u2013 St\u00f6rmer\u2013Verlet method=== The velocities are not explicitly given in the basic St\u00f6rmer equation, but often they are necessary for the calculation of certain physical quantities like the kinetic energy. This can create technical challenges in molecular dynamics simulations, because kinetic energy and instantaneous temperatures at time t cannot be calculated for a system until the positions are known at time t + \\Delta t. This deficiency can either be dealt with using the velocity Verlet algorithm or by estimating the velocity using the position terms and the mean value theorem: : \\vec{v}(t) = \\frac{\\vec{x}(t + \\Delta t) - \\vec{x}(t - \\Delta t)}{2\\Delta t} \\+ \\mathcal{O}(\\Delta t^2). Note that this velocity term is a step behind the position term, since this is for the velocity at time t, not t + \\Delta t, meaning that \\vec v_n = \\tfrac{\\vec x_{n+1} - \\vec x_{n-1}}{2\\Delta t} is a second-order approximation to \\vec{v}(t_n). With the same argument, but halving the time step, \\vec v_{n+1/2} = \\tfrac{\\vec x_{n+1} - \\vec x_n}{\\Delta t} is a second-order approximation to \\vec{v}(t_{n+1/2}), with t_{n+1/2} = t_n + \\tfrac12 \\Delta t. One can shorten the interval to approximate the velocity at time t + \\Delta t at the cost of accuracy: :\\vec{v}(t + \\Delta t) = \\frac{\\vec{x}(t + \\Delta t) - \\vec{x}(t)}{\\Delta t} + \\mathcal{O}(\\Delta t). == Velocity Verlet == A related, and more commonly used, algorithm is the velocity Verlet algorithm, similar to the leapfrog method, except that the velocity and position are calculated at the same value of the time variable (leapfrog does not, as the name suggests). This uses a similar approach, but explicitly incorporates velocity, solving the problem of the first time step in the basic Verlet algorithm: :\\vec{x}(t + \\Delta t) = \\vec{x}(t) + \\vec{v}(t)\\, \\Delta t + \\frac{1}{2} \\,\\vec{a}(t) \\Delta t^2, :\\vec{v}(t + \\Delta t) = \\vec{v}(t) + \\frac{\\vec{a}(t) + \\vec{a}(t + \\Delta t)}{2} \\Delta t. It can be shown that the error in the velocity Verlet is of the same order as in the basic Verlet. Note that the velocity algorithm is not necessarily more memory-consuming, because it's not necessary to keep track of the velocity at every time step during the simulation. The standard implementation scheme of this algorithm is: # Calculate \\vec{v}\\left(t + \\tfrac12\\,\\Delta t\\right) = \\vec{v}(t) + \\tfrac12\\,\\vec{a}(t)\\,\\Delta t. # Calculate \\vec{x}(t + \\Delta t) = \\vec{x}(t) + \\vec{v}\\left(t + \\tfrac12\\,\\Delta t\\right)\\, \\Delta t. # Derive \\vec{a}(t + \\Delta t) from the interaction potential using \\vec{x}(t + \\Delta t). # Calculate \\vec{v}(t + \\Delta t) = \\vec{v}\\left(t + \\tfrac12\\,\\Delta t\\right) + \\tfrac12\\,\\vec{a}(t + \\Delta t)\\Delta t. Eliminating the half-step velocity, this algorithm may be shortened to # Calculate \\vec{x}(t + \\Delta t) = \\vec{x}(t) + \\vec{v}(t)\\,\\Delta t + \\tfrac12 \\,\\vec{a}(t)\\,\\Delta t^2. # Derive \\vec{a}(t + \\Delta t) from the interaction potential using \\vec{x}(t + \\Delta t). # Calculate \\vec{v}(t + \\Delta t) = \\vec{v}(t) + \\tfrac12\\,\\big(\\vec{a}(t) + \\vec{a}(t + \\Delta t)\\big)\\Delta t. Note, however, that this algorithm assumes that acceleration \\vec{a}(t + \\Delta t) only depends on position \\vec{x}(t + \\Delta t) and does not depend on velocity \\vec{v}(t + \\Delta t). One might note that the long-term results of velocity Verlet, and similarly of leapfrog are one order better than the semi-implicit Euler method. The algorithms are almost identical up to a shift by half a time step in the velocity. This is easily proven by rotating the above loop to start at step 3 and then noticing that the acceleration term in step 1 could be eliminated by combining steps 2 and 4. The only difference is that the midpoint velocity in velocity Verlet is considered the final velocity in semi-implicit Euler method. The global error of all Euler methods is of order one, whereas the global error of this method is, similar to the midpoint method, of order two. Additionally, if the acceleration indeed results from the forces in a conservative mechanical or Hamiltonian system, the energy of the approximation essentially oscillates around the constant energy of the exactly solved system, with a global error bound again of order one for semi- explicit Euler and order two for Verlet-leapfrog. The same goes for all other conserved quantities of the system like linear or angular momentum, that are always preserved or nearly preserved in a symplectic integrator. The velocity Verlet method is a special case of the Newmark-beta method with \\beta = 0 and \\gamma = 1/2. === Algorithmic representation === Since velocity Verlet is a generally useful algorithm in 3D applications, a general solution written in C++ could look like below. A simplified drag force is used to demonstrate change in acceleration, however it is only needed if acceleration is not constant. struct Body { Vec3d pos { 0.0, 0.0, 0.0 }; Vec3d vel { 2.0, 0.0, 0.0 }; // 2m/s along x-axis Vec3d acc { 0.0, 0.0, 0.0 }; // no acceleration at first double mass = 1.0; // 1kg double drag = 0.1; // rho*C*Area - simplified drag for this example /** * Update pos and vel using \"Velocity Verlet\" integration * @param dt DeltaTime / time step [eg: 0.01] */ void update(double dt) { Vec3d new_pos = pos + vel*dt + acc*(dt*dt*0.5); Vec3d new_acc = apply_forces(); // only needed if acceleration is not constant Vec3d new_vel = vel + (acc+new_acc)*(dt*0.5); pos = new_pos; vel = new_vel; acc = new_acc; } Vec3d apply_forces() const { Vec3d grav_acc = Vec3d{0.0, 0.0, -9.81 }; // 9.81m/s^2 down in the Z-axis Vec3d drag_force = 0.5 * drag * (vel * abs(vel)); // D = 0.5 * (rho * C * Area * vel^2) Vec3d drag_acc = drag_force / mass; // a = F/m return grav_acc - drag_acc; } }; ==Error terms== The local error in position of the Verlet integrator is O(\\Delta t^4) as described above, and the local error in velocity is O(\\Delta t^2). The global error in position, in contrast, is O(\\Delta t^2), and the global error in velocity is O(\\Delta t^2). These can be derived by noting the following: :\\mathrm{error}\\bigl(x(t_0 + \\Delta t)\\bigr) = O(\\Delta t^4) and :x(t_0 + 2\\Delta t) = 2x(t_0 + \\Delta t) - x(t_0) + \\Delta t^2 x(t_0 + \\Delta t) + O(\\Delta t^4). Therefore :\\mathrm{error}\\bigl(x(t_0 + 2\\Delta t)\\bigr) = 2\\mathrm{error}\\bigl(x(t_0 + \\Delta t)\\bigr) + O(\\Delta t^4) = 3\\,O(\\Delta t^4). Similarly: :\\mathrm{error}\\bigl(x(t_0 + 3\\Delta t)\\bigl) = 6\\,O(\\Delta t^4), :\\mathrm{error}\\bigl(x(t_0 + 4\\Delta t)\\bigl) = 10\\,O(\\Delta t^4), :\\mathrm{error}\\bigl(x(t_0 + 5\\Delta t)\\bigl) = 15\\,O(\\Delta t^4), which can be generalized to (it can be shown by induction, but it is given here without proof): :\\mathrm{error}\\bigl(x(t_0 + n\\Delta t)\\bigr) = \\frac{n(n+1)}{2}\\,O(\\Delta t^4). If we consider the global error in position between x(t) and x(t + T), where T = n\\Delta t, it is clear that :\\mathrm{error}\\bigl(x(t_0 + T)\\bigr) = \\left(\\frac{T^2}{2\\Delta t^2} + \\frac{T}{2\\Delta t}\\right) O(\\Delta t^4), and therefore, the global (cumulative) error over a constant interval of time is given by :\\mathrm{error}\\bigr(x(t_0 + T)\\bigl) = O(\\Delta t^2). Because the velocity is determined in a non-cumulative way from the positions in the Verlet integrator, the global error in velocity is also O(\\Delta t^2). In molecular dynamics simulations, the global error is typically far more important than the local error, and the Verlet integrator is therefore known as a second- order integrator. ==Constraints== Systems of multiple particles with constraints are simpler to solve with Verlet integration than with Euler methods. Constraints between points may be, for example, potentials constraining them to a specific distance or attractive forces. They may be modeled as springs connecting the particles. Using springs of infinite stiffness, the model may then be solved with a Verlet algorithm. In one dimension, the relationship between the unconstrained positions \\tilde{x}_i^{(t)} and the actual positions x_i^{(t)} of points i at time t can be found with the algorithm :d_1 = x_2^{(t)} - x_1^{(t)}, :d_2 = \\|d_1\\|, :d_3 = \\frac{d_2 - r}{d_2}, :x_1^{(t + \\Delta t)} = \\tilde{x}_1^{(t + \\Delta t)} + \\frac{1}{2} d_1 d_3, :x_2^{(t + \\Delta t)} = \\tilde{x}_2^{(t + \\Delta t)} - \\frac{1}{2} d_1 d_3. Verlet integration is useful because it directly relates the force to the position, rather than solving the problem using velocities. Problems, however, arise when multiple constraining forces act on each particle. One way to solve this is to loop through every point in a simulation, so that at every point the constraint relaxation of the last is already used to speed up the spread of the information. In a simulation this may be implemented by using small time steps for the simulation, using a fixed number of constraint-solving steps per time step, or solving constraints until they are met by a specific deviation. When approximating the constraints locally to first order, this is the same as the Gauss\u2013Seidel method. For small matrices it is known that LU decomposition is faster. Large systems can be divided into clusters (for example, each ragdoll = cluster). Inside clusters the LU method is used, between clusters the Gauss\u2013Seidel method is used. The matrix code can be reused: The dependency of the forces on the positions can be approximated locally to first order, and the Verlet integration can be made more implicit. Sophisticated software, such as SuperLUSuperLU User's Guide. exists to solve complex problems using sparse matrices. Specific techniques, such as using (clusters of) matrices, may be used to address the specific problem, such as that of force propagating through a sheet of cloth without forming a sound wave. Another way to solve holonomic constraints is to use constraint algorithms. ==Collision reactions== One way of reacting to collisions is to use a penalty-based system, which basically applies a set force to a point upon contact. The problem with this is that it is very difficult to choose the force imparted. Use too strong a force, and objects will become unstable, too weak, and the objects will penetrate each other. Another way is to use projection collision reactions, which takes the offending point and attempts to move it the shortest distance possible to move it out of the other object. The Verlet integration would automatically handle the velocity imparted by the collision in the latter case; however, note that this is not guaranteed to do so in a way that is consistent with collision physics (that is, changes in momentum are not guaranteed to be realistic). Instead of implicitly changing the velocity term, one would need to explicitly control the final velocities of the objects colliding (by changing the recorded position from the previous time step). The two simplest methods for deciding on a new velocity are perfectly elastic and inelastic collisions. A slightly more complicated strategy that offers more control would involve using the coefficient of restitution. == See also == *Courant\u2013Friedrichs\u2013Lewy condition *Energy drift *Symplectic integrator *Leapfrog integration *Beeman's algorithm == Literature == ==External links== *Verlet Integration Demo and Code as a Java Applet *Advanced Character Physics by Thomas Jakobsen *Theory of Molecular Dynamics Simulations \u2013 bottom of page Category:Numerical differential equations Category:Articles with example C++ code ",
    "title": "Verlet integration"
}