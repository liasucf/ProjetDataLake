{
    "id": "1498076",
    "text": "In computer science and numerical analysis, unit in the last place or unit of least precision (ULP) is the spacing between floating-point numbers, i.e., the value the least significant digit (rightmost digit) represents if it is 1. It is used as a measure of accuracy in numeric calculations.David Goldberg: What Every Computer Scientist Should Know About Floating-Point Arithmetic, section 1.2 Relative Error and Ulps, ACM Computing Surveys, Vol 23, No 1, pp.8, March 1991. ==Definition== One definition is: In radix b with precision p, if be \u2264 |x| < be+1, then ULP(x) = bmax(e,emin)\u2212p+1. Another definition, suggested by John Harrison, is slightly different: ULP(x) is the distance between the two closest straddling floating-point numbers a and b (i.e., those with a \u2264 x \u2264 b and a \u2260 b), assuming that the exponent range is not upper-bounded.Muller, Jean-Michel (2005-11). \"On the definition of ulp(x)\". INRIA Technical Report 5504. ACM Transactions on Mathematical Software, Vol. V, No. N, November 2005. Retrieved in 2012-03 from http://ljk.imag.fr/membres/Carine.Lucas/TPScilab/JMMuller/ulp-toms.pdf. These definitions differ only at signed powers of the radix. The IEEE 754 specification--followed by all modern floating-point hardware--requires that the result of an elementary arithmetic operation (addition, subtraction, multiplication, division, and square root since 1985, and FMA since 2008) be correctly rounded, which implies that in rounding to nearest, the rounded result is within 0.5 ULP of the mathematically exact result, using John Harrison's definition; conversely, this property implies that the distance between the rounded result and the mathematically exact result is minimized (but for the halfway cases, it is satisfied by two consecutive floating-point numbers). Reputable numeric libraries compute the basic transcendental functions to between 0.5 and about 1 ULP. Only a few libraries compute them within 0.5 ULP, this problem being complex due to the Table-maker's dilemma. ==Examples== ===Example 1=== Let x be a positive floating-point number and assume that the active rounding attribute is round to nearest, ties to even, denoted RN. If ULP(x) is less than or equal to 1, then . Otherwise, or , depending on the value of the least significant digit and the exponent of x. This is demonstrated in the following Haskell code typed at an interactive prompt: > until (\\x -> x == x+1) (+1) 0 :: Float 1.6777216e7 > it-1 1.6777215e7 > it+1 1.6777216e7 Here we start with 0 in single precision and repeatedly add 1 until the operation does not change the value. Since the significand for a single-precision number contains 24 bits, the first integer that is not exactly representable is 224+1, and this value rounds to 224 in round to nearest, ties to even. Thus the result is equal to 224. ===Example 2=== The following example in Java approximates as a floating point value by finding the two double values bracketing : : // \u03c0 with 20 decimal digits BigDecimal \u03c0 = new BigDecimal(\"3.14159265358979323846\"); // truncate to a double floating point double p0 = \u03c0.doubleValue(); // -> 3.141592653589793 (hex: 0x1.921fb54442d18p1) // p0 is smaller than \u03c0, so find next number representable as double double p1 = Math.nextUp(p0); // -> 3.1415926535897936 (hex: 0x1.921fb54442d19p1) Then is determined as : // ulp(\u03c0) is the difference between p1 and p0 BigDecimal ulp = new BigDecimal(p1).subtract(new BigDecimal(p0)); // -> 4.44089209850062616169452667236328125E-16 // (this is precisely 2**(-51)) // same result when using the standard library function double ulpMath = Math.ulp(p0); // -> 4.440892098500626E-16 (hex: 0x1.0p-51) ===Example 3=== Another example, in Python, also typed at an interactive prompt, is: >>> x = 1.0 >>> p = 0 >>> while x != x + 1: ... x = x * 2 ... p = p + 1 ... >>> x 9007199254740992.0 >>> p 53 >>> x + 2 + 1 9007199254740996.0 In this case, we start with and repeatedly double it until . Similarly to Example 1, the result is 253 because the double-precision floating-point format uses a 53-bit significand. ==Language support== The Boost C++ libraries provides the functions `boost::math::float_next`, `boost::math::float_prior`, `boost::math::nextafter` and `boost::math::float_advance` to obtain nearby (and distant) floating-point values, and `boost::math::float_distance(a, b)` to calculate the floating-point distance between two doubles. The C language library provides functions to calculate the next floating-point number in some given direction: `nextafterf` and `nexttowardf` for `float`, `nextafter` and `nexttoward` for `double`, `nextafterl` and `nexttowardl` for `long double`, declared in ``. It also provides the macros `FLT_EPSILON`, `DBL_EPSILON`, `LDBL_EPSILON`, which represent the positive difference between 1.0 and the next greater representable number in the corresponding type (i.e. the ULP of one). The Java standard library provides the functions and . They were introduced with Java 1.5. The Swift standard library provides access to the next floating-point number in some given direction via the instance properties `nextDown` and `nextUp`. It also provides the instance property `ulp` and the type property `ulpOfOne` (which corresponds to C macros like `FLT_EPSILON`) for Swift's floating-point types. ==See also== * IEEE 754 * ISO/IEC 10967, part 1 requires an ulp function * Least significant bit (LSB) * Machine epsilon ==References== ==Bibliography== *Goldberg, David (1991-03). \"Rounding Error\" in \"What Every Computer Scientist Should Know About Floating-Point Arithmetic\". Computing Surveys, ACM, March 1991. Retrieved from http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html#689. * Category:Computer arithmetic Category:Floating point ",
    "title": "Unit in the last place"
}