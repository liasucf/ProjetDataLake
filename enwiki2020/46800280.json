{
    "id": "46800280",
    "text": "Revision theory is a subfield of philosophical logic. It consists of a general theory of definitions, including (but not limited to) circular and interdependent concepts. A circular definition is one in which the concept being defined occurs in the statement defining it\u2014for example, defining a G as being blue and to the left of a G. Revision theory provides formal semantics for defined expressions, and formal proof systems study the logic of circular expressions. Definitions are important in philosophy and logic. Although circular definitions have been regarded as logically incorrect or incoherent, revision theory demonstrates that they are meaningful and can be studied with mathematical and philosophical logic. It has been used to provide circular analyses of philosophical and logical concepts. ==History== Revision theory is a generalization of the revision theories of truth developed Anil Gupta, Hans Herzberger, and Nuel Belnap.See, respectively, Gupta (1982), Herzberger (1982), and Belnap (1982). In the revision theories of Gupta and Herzberger, revision is supposed to reflect intuitive evaluations of sentences that use the truth predicate. Some sentences are stable in their evaluations, such as the truth-teller sentence, :The truth-teller is true. Assuming the truth- teller is true, it is true, and assuming that it is false, it is false. Neither status will change. On the other hand, some sentences oscillate, such as the liar, :The liar sentence is not true. On the assumption that the liar is true, one can show that it is false, and on the assumption that it is false, one can show that it is true. This instability is reflected in revision sequences for the liar. The generalization to circular definitions was developed by Gupta, in collaboration with Belnap. Their book, The Revision Theory of Truth, presents an in-depth development of the theory of circular definitions, as well as an overview and critical discussion of philosophical views on truth and the relation between truth and definition. ==Philosophical background== The philosophical background of revision theory is developed by Gupta and Belnap.Gupta and Belnap (1993) Other philosophers, such as Aladdin Yaq\u016bb, have developed philosophical interpretations of revision theory in the context of theories of truth, but not in the general context of circular definitions.Yaq\u016bb (1993) Gupta and Belnap maintain that circular concepts are meaningful and logically acceptable. Circular definitions are formally tractable, as demonstrated by the formal semantics of revision theory. As Gupta and Belnap put it, \"the moral we draw from the paradoxes is that the domain of the meaningful is more extensive than it appears to be, that certain seemingly meaningless concepts are in fact meaningful.\"Gupta and Belnap (1993, 278) The meaning of a circular predicate is not an extension, as is often assigned to non-circular predicates. Its meaning, rather, is a rule of revision that determines how to generate a new hypothetical extension given an initial one. These new extensions are at least as good as the originals, in the sense that, given one extension, the new extension contains exactly the things that satisfy the definiens for a particular circular predicate. In general, there is no unique extension on which revision will settle.This point is discussed further by Gupta and Belnap (1993, 121), Shapiro (2006), and Gupta (2011, 160-161). Revision theory offers an alternative to the standard theory of definitions. The standard theory maintains that good definitions have two features. First, defined symbols can always be eliminated, replaced by what defines them. Second, definitions should be conservative in the sense that adding a definition should not result in new consequences in the original language. Revision theory rejects the first but maintains the second, as demonstrated for both of the strong senses of validity presented below. The logician Alfred Tarski presented two criteria for evaluating definitions as analyses of concepts: formal correctness and material adequacy. The criterion of formal correctness states that in a definition, the definiendum must not occur in the definiens. The criterion of material adequacy says that the definition must be faithful to the concept being analyzed. Gupta and Belnap recommend siding with material adequacy in cases in which the two criteria conflict.Gupta and Belnap (1993, 277) To determine whether a circular definition provides a good analysis of a concept requires evaluating the material adequacy of the definition. Some circular definitions will be good analyses, while some will not. Either way, formal correctness, in Tarski's sense, will be violated. ==Semantics for circular predicates== The central semantic idea of revision theory is that a definition, such as that of being a G, provides a rule of revision that tells one what the new extension for the definiendum G should be, given a hypothetical extension of the definiendum and information concerning the undefined expressions. Repeated application of a rule of revision generates sequences of hypotheses, which can be used to define logics of circular concepts. In work on revision theory, it is common to use the symbol, =_{df}, to indicate a definition, with the left-hand side being the definiendum and the right-hand side the definiens. The example : Being a G is defined as being both blue and to the left of a G can then be written as : Being a G=_{df} being both blue and to the left of a G. Given a hypothesis about the extension of G, one can obtain a new extension for G appealing to the meaning of the undefined expressions in the definition, namely blue and to the left of. We begin with a ground language, L, that is interpreted via a classical ground model M, which is a pair of a domain D and an interpretation function I.This section is based on Gupta and Belnap (1993). Suppose that the set of definitions \\mathcal{D} is the following, : \\begin{align} G_1\\overline{x} & =_{Df} A_{G_1}(\\overline{x}) \\\\\\ & {}\\,\\,\\,\\vdots \\\\\\ G_n\\overline{x} & =_{Df} A_{G_n}(\\overline{x}) \\\\\\ & {}\\,\\,\\,\\vdots \\end{align} where each A_{G_i} is a formula that may contain any of the definienda G_j, including G_i itself. It is required that in the definitions, only the displayed variables, \\overline{x}, are free in the definientia, the formulas A_{G_i}. The language is expanded with these new predicates, G_1,\\ldots,G_n,\\ldots, to form L+. When the set \\mathcal{D} contains few defined predicates, it is common to use the notation, G\\overline{x}=_{Df} A(\\overline{x},G) to emphasize that A may contain G. A hypothesis h is a function from the definienda of to tuples of \\mathcal{D}. The model M+h is just like the model M except that h interprets each definiendum according to the following biconditional, the left-hand side of which is read as \u201cG_i(\\overline{t}) is true in M+h.\u201d : M+h\\models G_i(\\overline{t}) \\text{ iff } I(\\overline{t})\\in h(G_i) The set \\mathcal{D} of definitions yields a rule of revision, or revision operator, \\delta_{M, \\mathcal{D}}. Revision operators obey the following equivalence for each definiendum, G, in \\mathcal{D}. : M+\\delta_{M, \\mathcal{D}}(h) \\models G(\\overline{t}) \\text{ iff } M+h\\models A_G(\\overline{t}) A tuple will satisfy a definiendum G after revision just in case it satisfies the definiens for G, namely A_G, prior to revision. This is to say that the tuples that satisfy A_G according to a hypothesis will be exactly those that satisfy G according to the revision of that hypothesis. The classical connectives are evaluated in the usual, recursive way in M+h. Only the evaluation of a defined predicate appeals to the hypotheses. ==Sequences== Revision sequences are sequences of hypotheses satisfying extra conditions.This section is based on Gupta and Belnap (1993) and Kremer (2014). We will focus here on sequences that are \\omega-long, since transfinite revision sequences require the additional specification of what to do at limit stages. Let \\mathcal{S} be a sequence of hypotheses, and let \\mathcal{S}_{\\alpha} be the \\alpha-th hypothesis in \\mathcal{S}. An \\omega-long sequence \\mathcal{S} of hypotheses is a revision sequence just in case for all n, : \\mathcal{S}_{n+1}=\\delta_{M, \\mathcal{D}}(\\mathcal{S}_{n}). Recursively define iteration as * \\delta_{M, \\mathcal{D}}^0(h)=h and * \\delta_{M, \\mathcal{D}}^{n+1}(h)=\\delta_{M, \\mathcal{D}}^{n}(\\delta_{M, \\mathcal{D}}(h)). The \\omega-long revision sequence starting from h can be written as follows. : h, \\delta_{M, \\mathcal{D}}(h), \\delta_{M, \\mathcal{D}}^2(h), \\ldots One sense of validity, S_0 validity, can be defined as follows. A sentence A is valid in S_0 in M on {D} iff there exists an n such that for all h and for all m\\geq n, M+\\delta_{M, \\mathcal{D}}^{m}(h)\\models A. A sentence A is valid on D just in case it is valid in all M. Validity in S_0 can be recast in terms of stability in \\omega-long sequences. A sentence A is stably true in a revision sequence just in case there is an {\\alpha} such that for all \\beta\\geq\\alpha, M+{\\mathcal{S}_\\beta}\\models A. A sentence A is stably false in a revision sequence just in case there is an {\\alpha} such that for all \\beta\\geq\\alpha, M+{\\mathcal{S}_\\beta} ot\\models A. In these terms, a sentence A is valid in S_0 in M on just in case A is stably true in all \\omega-long revision sequences on M. ==Examples== For the first example, let \\mathcal{D}_1 be Gx=_{Df} (x=a\\ \\&\\ \\sim Gx) \\lor (x=b\\ \\&\\ Gb). Let the domain of the ground model M be , and let I(a)=a and I(b)=b. There are then four possible hypotheses for M: \\emptyset, , , . The first few steps of the revision sequences starting from those hypotheses are illustrated by the following table. {| class=\"wikitable\" style=\"text-align:center\" |+ Sample revision for \\mathcal{D}_1 !stage 0 !stage 1 !stage 2 !stage 3 |- |\\emptyset | |\\emptyset | |- | |\\emptyset | |\\emptyset |- | | | | |- | | | | |} As can be seen in the table, a goes in and out of the extension of G. It never stabilizes. On the other hand, b either stays in or stays out. It is stable, but whether it is stably true or stably false depends on the initial hypothesis. Next, let \\mathcal{D}_2 be Hx=_{Df} Hx\\lor\\sim Hx. As shown in the following table, all hypotheses for the ground model of the previous example are revised to the set . {| class=\"wikitable\" style=\"text-align:center\" |+ Sample revision for \\mathcal{D}_2 !stage 0 !stage 1 !stage 2 !stage 3 |- |\\emptyset | | | |- | | | | |- | | | | |- | | | | |} For a slightly more complex revision pattern, let {L} contain < and all the numerals, \\overline{k}, and let the ground model be \\mathbb{N}, whose domain is the natural numbers, \\omega, with interpretation I such that I(\\overline{k})=k for all numerals and I(<) is the usual ordering on natural numbers. Let \\mathcal{D}_3 be Jx=_{Df} \\forall y(y< x\\supset Jy). Let the initial hypothesis h be \\emptyset. In this case, the sequence of extensions builds up stage by stage. : \\varnothing,\\ \\\\{0\\\\},\\ \\\\{0,1\\\\},\\ \\\\{0,1,2,\\\\},\\ \\ldots Although for every n, J\\overline{n} is valid in \\mathbb{N}, \\forall x Jx is not valid in \\mathbb{N}. Suppose the initial hypothesis contains 0, 2, and all the odd numbers. After one revision, the extension of J will be . Subsequent revisions will build up the extension as with the previous example. More generally, if the extension of J is not all of \\mathbb{N}, then one revision will cut the extension of J down to a possibly empty initial segment of the natural numbers and subsequent revisions will build it back up. ==Proof system== There is a Fitch-style natural deduction proof system, C_0, for circular definitions.A presentation of C_0 can be found in chapter 5 of Gupta and Belnap (1993). The system uses indexed formulas, {A}^{i}, where i can be any integer. One can think of the indices as representing relative position in a revision sequence. The premises and conclusions of the rules for the classical connectives all have the same index. For example, here are the conjunction and negation introduction rules. | B^i | C^i | (B\\&C;)^i \\&In | |__ B^{i} | | \\vdots | | \\bot^{i} | \\sim B^{i} \\simIn For each definition, G\\overline{x}=_{Df} A_G(\\overline{x}), in D, there is a pair of rules. | A_{G}(\\overline{t})^{i} | G(\\overline{t})^{i+1} DfIn | G(\\overline{t})^{i+1} | A_{G}(\\overline{t})^{i} DfElim In these rules, it is assumed that \\overline{t} are free for \\overline{x} in A_G. Finally, for formulas B of {L}, there is one more rule, the index shift rule. | B^{i} | B^{j} IS In this rule, i and j can be any distinct indices. This rule reflects the fact that formulas from the ground language do not change their interpretation throughout the revision process. The system C_0 is sound and complete with respect to S_0 validity, meaning a sentence is valid in S_0 just in case it is derivable in C_0. Recently Riccardo Bruni has developed a Hilbert-style axiom system and a sequent system that are both sound and complete with respect to S_0.Bruni (2013) ==Transfinite revision== For some definitions, S_0 validity is not strong enough.The definitions of this section are taken from Gupta and Belnap (1993). For example, in definition \\mathcal{D}_3, even though every number is eventually stably in the extension of J, the universally quantified sentence \\forall x Jx is not valid. The reason is that for any given sentence to be valid, it must stabilize to true after finitely many revisions. On the other hand, \\forall x Jx needs infinitely many revisions, unless the initial hypothesis already assigns all the natural numbers as the extension of J. Natural strengthenings of S_0 validity, and alternatives to it, use transfinitely long revision sequences. Let On be the class of all ordinals. The definitions will focus on sequences of hypotheses that are On-long. Suppose \\mathcal{S} is an On-long sequence of hypotheses. A tuple \\overline{d} is stably in the extension of a defined predicate G at a limit ordinal \\beta in a sequence \\mathcal{S} just in case there is an \\alpha\\leq\\beta such that for all \\gamma with \\alpha\\leq \\gamma<\\beta, \\overline{d}\\in \\mathcal{S}_\\gamma. Similarly, a tuple \\overline{d} is stably out of the extension of G at a limit ordinal \\beta just in case there is a stage \\alpha such that for all \\gamma with \\alpha\\leq\\gamma<\\beta, \\overline{d} ot\\in\\mathcal{S}_\\gamma. Otherwise \\overline{d} is unstable at \\beta in \\mathcal{S}. Informally, a tuple is stably in an extension at a limit, just in case there's a stage after which the tuple is in the extension up until the limit, and a tuple is stably out just in case there's a stage after which it remains out going to the limit stage. A hypothesis h coheres with \\mathcal{S} at a limit ordinal \\beta iff for all tuples \\overline{d}, if \\overline{d} is stably in [stably out of] the extension of G at \\beta in \\mathcal{S}, then \\overline{d}\\in[ ot\\in] h(G). An On-long sequence \\mathcal{S} of hypotheses is a revision sequence iff for all \\alpha, * if \\alpha=\\beta+1, then \\mathcal{S}_{\\alpha}=\\delta_{M, \\mathcal{D}}(\\mathcal{S}_\\beta), and * if \\alpha is a limit, then \\mathcal{S}_{\\alpha} coheres with \\mathcal{S} at \\alpha. Just as with the \\omega sequences, the successor stages of the sequence are generated by the revision operator. At limit stages, however, the only constraint is that the limit hypothesis cohere with what came before. The unstable elements are set according to a limit rule, the details of which are left open by the set of definitions. Limit rules can be categorized into two classes, constant and non-constant, depending on whether they do different things at different limit stages. A constant limit rule does the same thing to unstable elements at each limit. One particular constant limit rule, the Herzberger rule, excludes all unstable elements from extensions. According to another constant rule, the Gupta rule, unstable elements are included in extensions just in case they were in \\mathcal{S}_0. Non-constant limit rules vary the treatment of unstable elements at limits. Two senses of validity can be defined using On-long sequences. The first, S^{*} validity, is defined in terms of stability. A sentence A is valid in S^{*} in M on \\mathcal{D} iff for all On-long revision sequences {S}, there is a stage \\alpha such that A is stably true in \\mathcal{S} after stage \\alpha. A sentence A is S^{*} valid on \\mathcal{D} just in case for all classical ground models M, A is S^{*} valid in M on \\mathcal{D}. The second sense of validity, S^{\\\\#} validity, uses near stability rather than stability. A sentence {A} is nearly stably true in a sequence \\mathcal{S} iff there is an \\alpha such that for all \\beta\\geq\\alpha, there is a natural number n such that for all m\\geq n, M+\\delta_{M, \\mathcal{D}}^{m}(\\mathcal{S}_{\\beta})\\models A. A sentence {A} is nearly stably false in a sequence \\mathcal{S} iff there is an \\alpha such that for all \\beta\\geq\\alpha, there is a natural number n such that for all m\\geq n, M+\\delta_{M, \\mathcal{D}}^{m}(\\mathcal{S}_{\\beta}) ot\\models A. A nearly stable sentence may have finitely long periods of instability following limits, after which it settles down until the next limit. A sentence A is valid in S^{\\\\#} in M on iff for all On-long revision sequences {S}, there is a stage \\alpha such that A is nearly stably true in \\mathcal{S} after stage \\alpha. A sentence A is valid in S^{\\\\#} in on just in case it is valid in S^{\\\\#} in all ground models. If a sentence is valid in S^{*}, then it is valid in S^{\\\\#}, but not conversely. An example using \\mathcal{D}_3 shows this for validity in a model. The sentence \\forall x Jx is not valid in \\mathbb{N} in S_0, but it is valid in S^{\\\\#}. An attraction of S^{\\\\#} validity is that it generates a simpler logic than S^{*}. The proof system C_0 is sound for S^{\\\\#}, but it is not, in general, complete. In light of the completeness of C_0, if a sentence is valid in S_0, then it is valid in S^{\\\\#}, but the converse does not hold in general. Validity in S_0 and in S^{*} are, in general, incomparable. Consequently, C_0 is not sound for S^{*}. ==Finite definitions== While S^{\\\\#} validity outstrips S_0 validity, in general, there is a special case in which the two coincide, finite definitions. Loosely speaking, a definition is finite if all revision sequences stop producing new hypotheses after a finite number of revisions. To put it more precisely, we define a hypothesis h as reflexive just in case there is an n>0 such that h=\\delta_{M, \\mathcal{D}}^{n}(h). A definition is finite iff for all models M, for all hypotheses h, there is a natural number n, such that \\delta_{M, \\mathcal{D}}^{n}(h) is reflexive. Gupta showed that if \\mathcal{D} is finite, then S^{\\\\#} validity and S_0 validity coincide. There is no known syntactic characterization of the set of finite definitions, and finite definitions are not closed under standard logical operations, such as conjunction and disjunction. Maricarmen Martinez has identified some syntactic features under which the set of finite definitions is closed..Martinez (2001) She has shown that if {L} contains only unary predicates, apart from identity, contains no function symbols, and the definienda of \\mathcal{D} are all unary, then \\mathcal{D} is finite. While many standard logical operations do not preserve finiteness, it is preserved by the operation of self-composition.This was shown by Gupta (2006b). For a definition G\\overline{x}=_{Df} A(\\overline{x},G), define self-composition recursively as follows. * A^0(\\overline{x},G)= G\\overline{x} and * A^{n+1}(\\overline{x},G)= A^{n}(\\overline{x},G)[A(\\overline{t},G)/G\\overline{t}]. The latter says that A^{n+1} is obtained by replacing all instances of G\\overline{t} in A^n, with A(\\overline{t},G). If \\mathcal{D} is a finite definition and \\mathcal{D}^n is the result of replacing each definiens B in \\mathcal{D} with B^n, then \\mathcal{D}^n is a finite definition as well. ==Notable formal features== Revision theory distinguishes material equivalence from definitional equivalence.This point is noted by Gupta and Belnap (1993). The sets of definitions use the latter. In general, definitional equivalence is not the same as material equivalence. Given a definition : Gx=_{Df} A(x,G), its material counterpart, : \\forall x(Gx\\equiv A(x,G)), will not, in general, be valid.One can extend revision theory with a unary operator so that the definitional equivalence will be reflected in the object languages by a valid equivalence, \\forall x(Gx\\equiv \\Box A(x,G)). This was shown by Standefer (2015). The definition : Gx=_{Df} \\sim Gx illustrates the invalidity. Its definiens and definiendum will not have the same truth value after any revision, so the material biconditional will not be valid. For some definitions, the material counterparts of the defining clauses are valid. For example, if the definientia of contain only symbols from the ground language, then the material counterparts will be valid. The definitions given above are for the classical scheme. The definitions can be adjusted to work with any semantic scheme.See Gupta and Belnap (1993) for this point. This includes three-valued schemes, such as Strong Kleene, with exclusion negation, whose truth table is the following. {| class=\"wikitable\" |+ Exclusion negation !align=\"center\"|\\lnot !align=\"center\"| |- |align=\"center\"|\\textbf{t} |align=\"center\"|\\textbf{f} |- |align=\"center\"|\\textbf{n} |align=\"center\"|\\textbf{f} |- |align=\"center\"|\\textbf{f} |align=\"center\"|\\textbf{t} |} Notably, many approaches to truth, such as Saul Kripke\u2019s Strong Kleene theory, cannot be used with exclusion negation in the language. Revision theory, while in some respects similar to the theory of inductive definitions, differs in several ways.This is shown by Gupta and Belnap (1993). Most importantly, revision need not be monotonic, which is to say that extensions at later stages need not be supersets of extensions at earlier stages, as illustrated by the first example above. Relatedly, revision theory does not postulate any restrictions on the syntactic form of definitions. Inductive definitions require their definientia to be positive, in the sense that definienda can only appear in definientia under an even number of negations. (This assumes that negation, conjunction, disjunction, and the universal quantifier are the primitive logical connectives, and the remaining classical connectives are simply defined symbols.) The definition : Gx =_{Df} (x \\text{ is even }\\&\\ Gx) \\vee (x\\text{ is odd }\\&\\ \\sim Gx) is acceptable in revision theory, although not in the theory of inductive definitions. Inductive definitions are semantically interpreted via fixed points, hypotheses h for which h=\\delta_{M, \\mathcal{D}}(h). In general, revision sequences will not reach fixed points. If the definientia of \\mathcal{D} are all positive, then revision sequences will reach fixed points, as long as the initial hypothesis has the feature that h(G)\\subseteq \\delta_{M, \\mathcal{D}}(h)(G), for each G. In particular, given such a \\mathcal{D}, if the initial hypothesis assigns the empty extension to all definienda, then the revision sequence will reach the minimal fixed point. The sets of valid sentences on some definitions can be highly complex, in particular \\Pi^1_2. This was shown by Philip Kremer and Aldo Antonelli.See Kremer (1993) and Antonelli (1994a), respectively. There is, consequently, no proof system for S^{\\\\#} validity. ==Truth== The most famous application of revision theory is to the theory of truth, as developed in Gupta and Belnap (1993), for example. The circular definition of truth is the set of all the Tarski biconditionals, \u2018A\u2019 is true iff A, where \u2018iff\u2019 is understood as definitional equivalence, =_{Df}, rather than material equivalence. Each Tarski biconditional provides a partial definition of the concept of truth. The concept of truth is circular because some Tarski biconditionals use an ineliminable instance of \u2018is true\u2019 in their definiens. For example, suppose that b is the name of a truth-teller sentence, b is true. This sentence has as its Tarski biconditional: b is true iff b is true. The truth predicate on the right cannot be eliminated. This example depends on there being a truth-teller in the language. This and other examples show that truth, defined by the Tarski biconditionals, is a circular concept. Some languages, such as the language of arithmetic, will have vicious self-reference. The liar and other pathological sentences are guaranteed to be in the language with truth. Other languages with truth can be defined that lack vicious self-reference.See Gupta (1982) for an example. In such a language, any revision sequence {S} for truth is bound to reach a stage where {S}_{\\alpha}={S}_{\\alpha+1}, so the truth predicate behaves like a non-circular predicate.Gupta and Belnap (1993, 202-205) The result is that, in such languages, truth has a stable extension that is defined over all sentences of the language. This is in contrast to many other theories of truth, for example the minimal Strong Kleene and minimal supervaluational theories. The extension and anti-extension of the truth predicate in these theories will not exhaust the set of sentences of the language. The difference between S^{\\\\#} and S^{*} is important when considering revision theories of truth. Part of the difference comes across in the semantical laws, which are the following equivalences, where T is a truth predicate.The corner quotes are used to indicate a generic naming device, e.g. quotation names or G\u00f6del numbering. * \\forall A(T(\\ulcorner\\sim A\\urcorner)\\equiv \\sim T(\\ulcorner A\\urcorner)) * \\forall A, B(T(\\ulcorner{A\\& B}\\urcorner)\\equiv T(\\ulcorner{A}\\urcorner)\\& T(\\ulcorner{B}\\urcorner)) * \\forall A, B(T(\\ulcorner{A\\lor B}\\urcorner)\\equiv T(\\ulcorner{A}\\urcorner)\\lor T(\\ulcorner{B}\\urcorner)) * \\forall A(T(\\ulcorner\\forall x A\\urcorner)\\equiv \\forall t T(\\ulcorner A[x/t]\\urcorner)) These are all valid in S^{\\\\#}, although the last is valid only when the domain is countable and every element is named. In S^{*}, however, none are valid. One can see why the negation law fails by considering the liar, a=\\ulcorner{\\sim Ta}\\urcorner. The liar and all finite iterations of the truth predicate to it are unstable, so one can set T\\ulcorner{Ta}\\urcorner and T\\ulcorner{\\sim Ta}\\urcorner to have the same truth value at some limits, which results in \\sim T\\ulcorner{Ta}\\urcorner and T\\ulcorner{\\sim Ta}\\urcorner having different truth values. This is corrected after revision, but the negation law will not be stably true. It is a consequence of a theorem of Vann McGee that the revision theory of truth in S^{\\\\#} is \\omega-inconsistent.McGee (1985) The S^{*} theory is not \\omega- inconsistent. There is an axiomatic theory of truth that is related to the S^{\\\\#} theory in the language of arithmetic with truth. The Friedman-Sheard theory (FS) is obtained by adding to the usual axioms of Peano arithmetic * the axiom \\forall s,t(T(\\ulcorner{s=t}\\urcorner)\\equiv s=t), * the semantical laws, * the induction axioms with the truth predicate, and * the two rules ** if \\vdash A, then \\vdash T(\\ulcorner A\\urcorner), and ** if \\vdash T(\\ulcorner A\\urcorner), then \\vdash A.The original presentation of FS used different axioms and rules. See Halbach (2011) for more details. By McGee's theorem, this theory is \\omega-inconsistent. FS does not, however, have as theorems any false purely arithmetical sentences.Halbach (2011, 173) FS has as a theorem global reflection for Peano arithmetic, : \\forall x((\\mathrm{Sent}(x)\\ \\&\\ \\mathrm{Bew}_{PA}(x))\\supset Tx), where \\mathrm{Bew}_{PA} is a provability predicate for Peano arithmetic and \\mathrm{Sent} is a predicate true of all and only sentences of the language with truth. Consequently, it is a theorem of FS that Peano arithmetic is consistent. FS is a subtheory of the theory of truth for arithmetic, the set of sentences valid in S^{\\\\#}. A standard way to show that FS is consistent is to use an \\omega-long revision sequence.Halbach (2011, \u00a714.1) There has been some work done on axiomatizing the S^{*} theory of truth for arithmetic.Horsten et al. (2012) ==Other applications== Revision theory has been used to study circular concepts apart from truth and to provide alternative analyses of concepts, such as rationality. A non-well- founded set theory is a set theory that postulates the existence of a non- well-founded set, which is a set x that has an infinite descending chain along the membership relation, : \\cdots x_{n+1}\\in x_n\\in \\cdots \\in x_1\\in x. Antonelli has used revision theory to construct models of non-well-founded set theory.Antonelli (1994b) One example is a set theory that postulates a set whose sole member is itself, x=\\\\{x\\\\}. Infinite-time Turing machines are models of computation that permit computations to go on for infinitely many steps. They generalize standard Turing machines used in the theory of computability. Benedikt L\u00f6we has shown that there are close connections between computations of infinite-time Turing machines and revision processes.L\u00f6we (2001) Rational choice in game theory has been analyzed as a circular concept. Andr\u00e9 Chapuis has argued that the reasoning agents use in rational choice exhibits an interdependence characteristic of circular concepts.Chapuis (2003) Revision theory can be adapted to model other sorts of phenomena. For example, vagueness has been analyzed in revision-theoretic terms by Conrad Asmus.Asmus (2013) To model a vague predicate on this approach, one specifies pairs of similar objects and which objects are non- borderline cases, and so are unrevisable. The borderline objects change their status with respect to a predicate depending on the status of the objects to which they are similar. Revision theory has been used by Gupta to explicate the logical contribution of experience to one's beliefs.Gupta (2006a) According to this view, the contribution of experience is represented by a rule of revision that takes as input on an agent's view, or concepts and beliefs, and yields as output perceptual judgments. These judgments can be used to update the agent's view. ==See also== * Anil Gupta * Circular definition * Definition * Paradox * Philosophical logic * Truth ==References== * Antonelli, A. (1994a). The complexity of revision. Notre Dame Journal of Formal Logic, 35(1):67\u201372. * Antonelli, A. (1994b). Non-well-founded sets via revision rules. Journal of Philosophical Logic, 23(6):633\u2013679. * Asmus, C. M. (2013). Vagueness and revision sequences. Synthese, 190(6):953\u2013974. * Belnap, N. (1982). Gupta's rule of revision theory of truth. Journal of Philosophical Logic, 11(1):103\u2013116. * Bruni, R. (2013). Analytic calculi for circular concepts by finite revision. Studia Logica, 101(5):915\u2013932. * Chapuis, A. (2003). An application of circular definitions: Rational decision. In L\u00f6we, B., R \u0308asch, T., and Malzkorn, W., editors, Foundations of the Formal Sciences II, pages 47\u201354. Kluwer. * Gupta, A. (1982). Truth and paradox. Journal of Philosophical Logic, 11(1). A revised version, with a brief postscript, is reprinted in Martin (1984). * Gupta, A. (2006a). Empiricism and Experience. Oxford University Press. * Gupta, A. (2006b). Finite circular definitions. In Bolander, T., Hendricks, V. F., and Andersen, S. A., editors, Self-Reference, pages 79\u201393. CSLI Publications. * Gupta, A. (2011). Truth, Meaning, Experience. Oxford University Press. * Gupta, A. and Belnap, N. (1993). The Revision Theory of Truth. MIT Press. * Halbach, V. (2011). Axiomatic Theories of Truth. Cambridge University Press. * Herzberger, H. G. (1982). Notes on naive semantics. Journal of Philosophical Logic, 11(1):61\u2013102. Reprinted in Martin (1984). * Horsten, L., Leigh, G. E., Leitgeb, H., and Welch, P. (2012). Revision revisited. Review of Symbolic Logic, 5(4):642\u2013665. * Kremer, P. (1993). The Gupta-Belnap systems S^{\\\\#} and S^{*} are not axiomatisable. Notre Dame Journal of Formal Logic, 34(4):583\u2013596. * L\u00f6we, B. (2001). Revision sequences and computers with an infinite amount of time. Journal of Logic and Computation, 11(1):25\u201340. doi: 10.1093/log- com/11.1.25. * Martin, R. L., editor (1984). Recent Essays on Truth and the Liar Paradox. Oxford University Press. * Martinez, M. (2001). Some closure properties of finite definitions. Studia Logica, 68(1):43\u201368. * McGee, V. (1985). How truthlike can a predicate be? A negative result. Journal of Philosophical Logic, 14(4):399\u2013410. * Shapiro, L. (2006). The rationale behind revision-rule semantics. Philosophical Studies, 129(3):477\u2013515. * Standefer, S. (2015). Solovay-type theorems for circular definitions. Review of Symbolic Logic, pages 1\u201321. forthcoming * Yaq\u016bb, A. M. (1993). The Liar Speaks the Truth: A Defense of the Revision Theory of Truth. Oxford University Press. ==External links== * Kremer, P. (2014) The Revision Theory of Truth. In Zalta, E. N., editor, The Stanford Encyclopedia of Philosophy. Summer 2014 edition. Category:Philosophical logic ",
    "title": "Revision theory"
}