{
    "id": "1426292",
    "text": "Unix-like operating systems identify a user by a value called a user identifier, often abbreviated to user ID or UID. The UID, along with the group identifier (GID) and other access control criteria, is used to determine which system resources a user can access. The password file maps textual user names to UIDs. UIDs are stored in the inodes of the Unix file system, running processes, tar archives, and the now-obsolete Network Information Service. In POSIX-compliant environments, the command-line command `id` gives the current user's UID, as well as more information such as the user name, primary user group and group identifier (GID). == Process attributes == The POSIX standard introduced three different UID fields into the process descriptor table, to allow privileged processes to take on different roles dynamically: ===Effective user ID=== The effective UID (`euid`) of a process is used for most access checks. It is also used as the owner for files created by that process. The effective GID (`egid`) of a process also affects access control and may also affect file creation, depending on the semantics of the specific kernel implementation in use and possibly the mount options used. According to BSD Unix semantics, the group ownership given to a newly created file is unconditionally inherited from the group ownership of the directory in which it is created. According to AT&T; UNIX System V semantics (also adopted by Linux variants), a newly created file is normally given the group ownership specified by the `egid` of the process that creates the file. Most filesystems implement a method to select whether BSD or AT&T; semantics should be used regarding group ownership of a newly created file; BSD semantics are selected for specific directories when the S_ISGID (s-gid) permission is set. ==== TC: Version v11.16.7 (152.7030ee7e42) - User ID 5473292403148240 ==== Linux also has a file system user ID (`fsuid`) which is used explicitly for access control to the file system. It matches the `euid` unless explicitly set otherwise. It may be root's user ID only if `ruid`, `suid`, or `euid` is root. Whenever the `euid` is changed, the change is propagated to the `fsuid`. The intent of `fsuid` is to permit programs (e.g., the NFS server) to limit themselves to the file system rights of some given `uid` without giving that `uid` permission to send them signals. Since kernel 2.0, the existence of `fsuid` is no longer necessary because Linux adheres to SUSv3 rules for sending signals, but `fsuid` remains for compatibility reasons.Kerrisk, Michael. The Linux Programming Interface. No Starch Press, 2010, p. 171. ===Saved user ID=== The saved user ID (`suid`) is used when a program running with elevated privileges needs to do some unprivileged work temporarily; changing `euid` from a privileged value (typically `0`) to some unprivileged value (anything other than the privileged value) causes the privileged value to be stored in `suid`. Later, a program's `euid` can be set back to the value stored in `suid`, so that elevated privileges can be restored; an unprivileged process may set its `euid` to one of only three values: the value of `ruid`, the value of `suid`, or the value of `euid`. ===Real user ID=== The real UID (`ruid`) and real GID (`rgid`) identify the real owner of the process and affect the permissions for sending signals. A process without superuser privileges may signal another process only if the sender's `ruid` or `euid` matches receiver's `ruid` or `suid`. Because a child process inherits its credentials from its parent, a child and parent may signal each other. == Conventions == === Type === POSIX requires the UID to be an integer type. Most Unix-like operating systems represent the UID as an unsigned integer. The size of UID values varies amongst different systems; some UNIX OS's used 15-bit values, allowing values up to 32767, while others such as Linux (before version 2.4) supported 16-bit UIDs, making 65536 unique IDs possible. The majority of modern Unix-like systems (e.g., Solaris-2.0 in 1990, Linux 2.4 in 2001) have switched to 32-bit UIDs, allowing 4,294,967,296 (232) unique IDs. === Reserved ranges === The Linux Standard Base Core Specification specifies that UID values in the range 0 to 99 should be statically allocated by the system, and shall not be created by applications, while UIDs from 100 to 499 should be reserved for dynamic allocation by system administrators and post install scripts. Debian Linux not only reserves the range 100\u2013999 for dynamically allocated system users and groups, but also centrally and statically allocates users and groups in the range 60000-64999 and further reserves the range 65000\u201365533. On FreeBSD, porters who need a UID for their package can pick a free one from the range 50 to 999 and then register the static allocation.http://www.freebsd.org/doc/en/books/porters-handbook/users- and-groups.html Some POSIX systems allocate UIDs for new users starting from 500 (macOS, Red Hat Enterprise Linux till version 6), others start at 1000 (Red Hat Enterprise Linux since version 7, openSUSE, Debian). On many Linux systems, these ranges are specified in `/etc/login.defs`, for `useradd` and similar tools. Central UID allocations in enterprise networks (e.g., via LDAP and NFS servers) may limit themselves to using only UID numbers well above 1000, and outside the range 60000\u201365535, to avoid potential conflicts with UIDs locally allocated on client computers. === Special values === * 0: The superuser normally has a UID of zero (0). * \u22121: The value `(uid_t) -1` is reserved by POSIX to identify an omitted argument. * 65535: This value is still avoided because it was the API error return value when uid_t was 16 bits. * Nobody: Historically, the user \"nobody\" was assigned UID `-2` by several operating systems, although other values such as 215\u22121 = 32,767 are also in use, such as by OpenBSD. For compatibility between 16-bit and 32-bit UIDs, many Linux distributions now set it to be 216\u22122 = 65,534; the Linux kernel defaults to returning this value when a 32-bit UID does not fit into the return value of the 16-bit system calls. An alternative convention assigns the last UID of the range statically allocated for system use (0-99) to nobody: 99. == Alternatives == NFSv4 was intended to help avoid numeric identifier collisions by identifying users (and groups) in protocol packets using textual \u201cuser@domain\u201d names rather than integer numbers. However, as long as operating-system kernels and local file systems continue to use integer user identifiers, this comes at the expense of additional translation steps (using idmap daemon processes), which can introduce additional failure points if local UID mapping mechanisms or databases get configured incorrectly, lost, or out of sync. The \u201c@domain\u201d part of the user name could be used to indicate which authority allocated a particular name, for example in form of * a Kerberos realm name * an Active Directory domain name * the name of an operating-system vendor (for distribution-specific allocations) * the name of a computer (for device-specific allocations) But in practice many existing implementations only allow setting the NFSv4 domain to a fixed value, thereby rendering it useless. ==See also== * setuid * Sticky bit * Group identifier * Process identifier * File system permissions * Open (system call) * Mount (Unix) * FAT access rights * Security Identifier (SID) \u2013 the Windows NT equivalent ==References== Category:Unix Category:Unix file system technology ",
    "title": "User identifier"
}