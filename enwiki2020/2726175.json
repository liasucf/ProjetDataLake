{
    "id": "2726175",
    "text": "ID/LP Grammars are a subset of Phrase Structure Grammars, differentiated from other formal grammars by distinguishing between immediate dominance (ID) and linear precedence (LP) constraints. Whereas traditional phrase structure rules incorporate dominance and precedence into a single rule, ID/LP Grammars maintains separate rule sets which need not be processed simultaneously. ID/LP Grammars are used in Computational Linguistics. For example, a typical phrase structure rule such as S -> NP \\; VP, indicating that an S-node dominates an NP-node and a VP-node, and that the NP precedes the VP in the surface string. In ID/LP Grammars, this rule would only indicate dominance, and a linear precedence statement, such as NP\\prec VP, would also be given. The idea first came to prominence as part of Generalized Phrase Structure Grammar; the ID/LP Grammar approach is also used in head-driven phrase structure grammar, lexical functional grammar, and other unification grammars. Current work in the Minimalist Program also attempts to distinguish between dominance and ordering. For instance, recent papers by Noam Chomsky have proposed that, while hierarchical structure is the result of the syntactic structure-building operation Merge, linear order is not determined by this operation, and is simply the result of externalization (oral pronunciation, or, in the case of sign language, manual signing). == Defining Dominance and Precedence == === Immediate Dominance === Immediate dominance is the asymmetrical relationship between the mother node of a parse tree and its daughters, where the mother node (to the left of the arrow) is said to immediately dominate the daughter nodes (those to the right of the arrow), but the daughters do not immediately dominate the mother. The daughter nodes are also dominated by any node that immediately dominates the mother node, however this is not an immediate dominance relation. For example, the context free rule A \\rightarrow B\\ C\\ D, shows that the node labelled A (mother node) immediately dominates nodes labelled B, C, and D, (daughter nodes) and nodes labelled B, C, and D can be immediately dominated by a node labelled A. The node labelled A immediately dominates the nodes B, C, and D, and the node labelled B immediately dominates C' and D'. also dominates C' and D', but not immediately === Linear Precedence === Linear precedence is the order relationship of sister nodes. LP constraints specify in what order sister nodes under the same mother can appear. Nodes that surface earlier in strings precede their sisters. LP can be shown in phrase structure rules in the form A \\rightarrow B\\ C\\ D to mean B precedes C precedes D, as shown in the tree below. Tree generated by PS rule A-> B C D A rule that has ID constraints but not LP is written with commas between the daughter nodes, for example A \\rightarrow B,\\ C,\\ D. Since there is no fixed order for the daughter nodes, it is possible that all three of the trees shown here are generated by this rule. Three trees generated by the PS rule A-> B, C, D Alternatively, these relationships can be expressed through linear precedence statements, such as B \\prec C, to mean that anytime B and C are sisters, B must precede C. The principle of transitivity can be applied to LP relations which means that if B \\prec C and C \\prec D, then B \\prec D as well. LP relationships are asymmetric: if B precedes C, C can never precede B. An LP relationship where there can be no intervening nodes is called immediate precedence, while an LP where there can be intervening nodes (those derived from the principle of transitivity) are said to have weak precedence.Daniels, M. (2005). Generalized ID/LP grammar: a formalism for parsing linearization- based HPSG grammars. (Electronic Thesis or Dissertation). Retrieved from https://etd.ohiolink.edu/ === Grammaticality in ID/LP Grammars === For a string to be grammatical in an ID/LP Grammar, it must belong to a local subtree that follows at least one ID rule and all LP statements of the grammar. If every possible string generated by the grammar fits this criteria, than it is an ID/LP Grammar. Additionally, for a grammar to be able to be written in ID/LP format, it must have the property of Exhaustive Constant Partial Ordering (ECPO): namely that at least part of the ID/LP relations in one rule is observed in all other rules. For example, the set of rules: > (1) A \\rightarrow B\\ C\\ D > (2) B \\rightarrow D\\ C\\ A does not have the ECPO property, because (1) says that C must always precede D, while (2) says that D must always precede C. === Advantages of ID/LP Grammars === Since LP statements apply regardless of the ID rule context, they allow us to make generalizations across the whole grammar. For example, given the LP statement V\\prec DP , where V is the head of a VP, this means that in any clause in any sentence, V will always surface before its DP sister in any context, as seen in the following examples. > Lucy won the race. Simplified syntax tree for the sentence \"Lucy won the race\" > Ava told Sara to read a book. > A rough tree for the sentence \"Ava told Sara to read a book\" This can be generalized into a rule that holds across English, X\\prec YP, where X is the head of any phrase and YP is its complement. Non-ID/LP Grammars are unable to make such generalizations across the whole grammar, and so must repeat ordering restrictions for each individual context. Separating LP requirements from ID rules also accounts for the phenomena of free word order in natural language. For example, in English it is possible to put adverbs before or after a verb and have both strings be grammatical. > John suddenly screamed. John screamed suddenly. A traditional PS rule would require two separate rules, but this can be described by the single ID/LP rule VP \\rightarrow V, AdvP.This property of ID/LP Grammars enables easier cross linguistic generalizations by describing the language specific differences in constituent order with LP statements, separately from the ID rules that are similar across languages. == Parsing in ID/LP Grammars == Two parsing algorithms used to parse ID/LP Grammars are the Earley Parser and Shieber's algorithm. === Earley Parser in ID/LP Grammars === ID and LP rules impose constraints on sentence strings; when dealing with large strings, the constraints of these rules can cause the parsed string to become infinite, thus making parsing difficult. The Earley Parser solves this by altering the format of an ID/LP Grammar into a Context Free Grammar (CFG), dividing the ID/LP Grammar into an Ordered Context Free Grammar (CFG) and Unordered Context Free Grammar (UCFG). This allows the two algorithms to parse strings more efficiently; in particular, the Earley Parser uses a point tracking method that follows a linear path established by the LP rules. In a CFG, LP rules do not allow repeated constituents in the parsed string, but an UCFG allows repeated constituents within the parsed strings. If the ID/LP Grammar is converted to a UCFG then the LP rules do not dominate during the parsing process, however, it still follows the point tracking method. ==== Earley Parsing in CFG ==== After the ID/LP Grammar has been converted to the equivalent form within a CFG, the algorithm will analyze the string. Let \\Chi stand for start and \\alpha, \\beta, \\iota stand for the elements of the string and it also represents Syntactic Categories. The algorithm then analyzes the string and identifies the following: # The original position of the dot; it usually begins with the left-most element of the string. # The current position of the dot; this predicts the following element. # The production of the completed string. (1) \\Chi\\longrightarrow\\cdot\\alpha\\beta\\iota (2) \\Chi\\longrightarrow\\alpha\\cdot\\beta\\iota (\\betais being predicted) (3) \\Chi\\longrightarrow\\alpha\\beta\\iota\\cdot The parsed strings are then used together to form a Parse List for example: \\Iota_0\\ldots\\Iota_n which the list will help determine whether the completed production element (\\Chi\\longrightarrow\\alpha\\beta\\iota) is accepted within the main string. It does this by looking whether the produced individual strings are found in the Parse List. If one or all of the individual strings are not found within the Parse List, then the overall string will fail. If one or all of the individual strings are found in the Parse List, then the overall string will be accepted. ==== Earley Parsing in UCFG ==== The UCFG is the appropriate equivalent to convert the ID/LP Grammar into in order to use the Earley Parser. This algorithm read strings similarly to how it parses CFG, however, in this case the order of elements is not enforced; resulting in lack of LP rule enforcement. This allows some elements to be repeated within the parsed strings and the UCFG accepts empty multi-sets along with filled multi-sets within its strings. For example: # The origin position of the dot; it is between the empty set and the filled set. # The current position of the dot which predicts the following set; the element that the dot passed will move into the empty set. # The production of the completed string. In this case, the position of the two sets in the origin position will swap; the filled set is on the left edge and the empty set is on the right edge. (1) \\Chi\\longrightarrow\\\\{\\\\}\\cdot\\\\{\\alpha,\\beta,\\iota\\\\} (2) \\Chi\\longrightarrow\\\\{\\alpha\\\\}\\cdot\\\\{\\beta,\\iota\\\\} (\\\\{\\beta,\\iota\\\\}are being predicted) (3) \\Chi\\longrightarrow\\\\{\\alpha,\\beta,\\iota\\\\}\\cdot\\\\{\\\\} When parsing a string that contains a number of unordered elements, the Earley Parser treats it as a Permutation, Y!, and generates each string individually instead of using one string to represent the repeated parsed strings. Whenever the dot moves over one element, the algorithm begins to generate parsed strings of the elements on the right edge in random positions until there are no more elements in the right edge set. Let X0 represent the original string and X1 as the first parsed string; for example: \\Chi_0:[\\Chi\\longrightarrow\\\\{\\\\}\\cdot\\\\{t, v, w,z\\\\},0] \\Chi_1:[\\Chi\\longrightarrow\\\\{t\\\\}\\cdot\\\\{v,w,z\\\\},0] string X1 will produce, 3! = 6, different parsed strings of the right edge set: (1) [\\Chi\\longrightarrow t.vwz, 0] (4) [\\Chi\\longrightarrow t.zvw, 0] (2) [\\Chi\\longrightarrow t.vzw, 0] (5) [\\Chi\\longrightarrow t.wvz, 0] (3) [\\Chi\\longrightarrow t.zwv, 0] (6) [\\Chi\\longrightarrow t.wzv, 0] The Earley Parser applies each string to the individual rules of a grammar and this results in very large sets.The large sets is partly resulted in the conversion of ID/LP Grammar into an equivalent grammar, however, parsing the overall ID/LP Grammar is difficult to begin with. === Shieber's Algorithm === The foundation of Shieber's Algorithm is based on the Earley Parser for CFG, however, it does not require the ID/LP Grammar to be converted into a different grammar in order to be parsed. ID rules can be parsed in a separate form, S ->ID {V, NP, S}, from the LP rules, V < S. Shieber compared parsing of a CFG to an ordered ID/LP Grammar string and Barton compared the parsing of a UCFG to an unordered ID/LP Grammar string. ==== Direct Parsing of an Ordered ID/LP Grammar ==== Parsing an ID/LP Grammar, directly, generates a set list that will determine whether the production of the string will be accepted or fail. The algorithm follows 6 Steps (the symbols used can also represents the Syntactic Categories): # For all of the ID rules, add [S,\\Tau,\\beta,0]to the initial item in the parse list, \\Iota_0. # If all of the elements in \\Iota_0, [\\Zeta,\\lambda,\\theta,0], and the elements, [\\Alpha,\\alpha,\\\\{Z\\\\}\\cup\\beta,0], of \\Iota_0does not allow Z to be preceded by \\beta,Z prec \\beta, and Z is not an element of \\beta, Z ot\\in \\beta; then the following string,[\\Alpha,\\alpha Z,\\beta,0 ] can be added to \\Iota_0. # If all items, [\\Alpha,\\alpha,\\\\{Z\\\\}\\cup\\beta,0], are elements of \\Iota_0, then Z prec \\beta, and Z ot\\in \\beta and all of Z\\longrightarrow_\\mathrm{ID}\\lambda then the next item can be added to this list, [Z,T,\\lambda,0]. # This step will build the set list, \\Iota_n, more. Every item, [A,\\alpha,\\\\{q\\\\}\\cup\\beta,i], that is an element of \\Iota_{n-1} and where q=q_n, q prec \\beta and q ot\\in \\beta then the following item is added, [A,\\alpha q,\\beta,i], to \\Iota_n. # If items, [Z,\\lambda,\\theta,i], are elements of \\Iota_n and items, [A,\\alpha \\\\{Z\\\\}\\cup\\beta,k], are elements of \\Iota_iwhere Z prec \\beta, and Z ot\\in \\beta; the string, [A,\\alpha Z,\\beta,k], is added to \\Iota_n. # If the items, [A,\\alpha,\\\\{Z\\\\}\\cup\\beta,i], is an element of \\Iota_n where Z prec \\beta, and Z ot\\in \\beta; the string, [Z,T,\\lambda,n], is added to \\Iota_n. Steps 2-3 are repeated exhaustively until no more new items can be added and then continue on to Step 4. Steps 5-6 are also exhaustively repeated until no further new items can be added to the set list. The string will be accepted if a string behaves or resembles the production, [S,\\alpha,\\theta,0]is an element of \\Iota_n. For example: : S\\longrightarrow_\\mathrm{ID}\\\\{C,D,F\\\\} : C\\longrightarrow_\\mathrm{ID}\\\\{c\\\\} : D\\longrightarrow_\\mathrm{ID}\\\\{d\\\\} : F\\longrightarrow_\\mathrm{ID}\\\\{f\\\\} : C\\prec D {| class=\"wikitable\" |+ Table 1.0 ! Set Lists ! Items |- |\\Iota_0 |[S,T,\\\\{C,D,F\\\\},0], [C,T,\\\\{c\\\\},0], [F,T,\\\\{f\\\\},0] |- |\\Iota_1 |[C,c,\\emptyset,0], [S,C,\\\\{D,F\\\\},0], [D,T,\\\\{d\\\\},1], [F,T,\\\\{f\\\\},1] |- |\\Iota_2 |[F,f,\\emptyset,1], [S,CF,\\\\{D\\\\},0], [D,T,\\\\{d\\\\},2] |- |\\Iota_3 |[D,d,\\emptyset,2], [S,CDF,\\emptyset,0] |} The complete production of \\Iota_3,[S,CDF,\\emptyset,0],is accepted and produces the following production string: [_S[_C c][_D d][_F f . ==== Direct Parsing of an Unordered ID/LP Grammar ==== The Unordered ID/LP Grammar follow the above, 6 step algorithm, in order to parse the strings. The noticeable difference is in the productions of each set list; there is one string that represents the many individual strings within one list. The table below shows the set list of Table 1.0, [S,T,\\\\{C,D,F\\\\},0], in an unordered grammar: {| class=\"wikitable\" |+ Table 2.0 !Set List !Items |- |\\Iota_0 |[S,T,C\\cdot d,f,\\emptyset, 0] |- |\\Iota_1 |[S,T\\cdot c,d,f,\\emptyset, 0] |- |\\Iota_2 |[S,T,C,d\\cdot F,\\emptyset, 0] |- |\\Iota_3 |[S,T,C,D,F\\cdot\\emptyset, 0] |} The complete production string, [S,T,C,D,F\\cdot\\emptyset, 0],results in a similar string as the ordered ID/LP Grammar; however, the order of the items within the string is not enforced. The final string is accepted as it matches the original string's elements. Notice how the Unordered version of ID/LP Grammar contains mush less strings than the UCFG; Shieber's Algorithm use one string to represent the multiple different strings for repeated elements. Both algorithms can parse Ordered Grammars equally, however, Shieber's Algorithm seems to be more efficient when parsing an Unordered Grammar. == See also == *Generalized Phrase Structure Grammar *Computational Linguistics *Parsing *Earley Parser == References == Category:Grammar frameworks Category:Generative linguistics ",
    "title": "ID/LP grammar"
}