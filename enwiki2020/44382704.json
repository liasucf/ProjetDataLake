{
    "id": "44382704",
    "text": "Formal definitions of the lambda calculus. Lambda calculus is a programming language based on lambda abstraction and function application. Two definitions of the language are given here. * Standard definition * Definition using mathematical formulas. == Standard definition == This formal definition was given by Alonzo Church. === Definition === Lambda expressions are composed of * variables v_{1}, v_{2}, ..., v_{n}, ... * the abstraction symbols lambda '\\lambda ' and dot '.' * parentheses ( ) The set of lambda expressions, \\Lambda , can be defined inductively: #If x is a variable, then x \\in \\Lambda #If x is a variable and M \\in \\Lambda , then (\\lambda x . M) \\in \\Lambda #If M, N \\in \\Lambda , then (M \\ N) \\in \\Lambda Instances of rule 2 are known as abstractions and instances of rule 3 are known as applications. -- Corrections === Notation === To keep the notation of lambda expressions uncluttered, the following conventions are usually applied. * Outermost parentheses are dropped: M \\ N instead of (M \\ N) * Applications are assumed to be left associative: M \\ N \\ P may be written instead of ((M \\ N) \\ P) * The body of an abstraction extends as far right as possible: \\lambda x . M \\ N means \\lambda x . (M \\ N) and not (\\lambda x . M) \\ N * A sequence of abstractions is contracted: \\lambda x . \\lambda y . \\lambda z . N is abbreviated as \\lambda x y z . N === Free and bound variables === The abstraction operator, \\lambda , is said to bind its variable wherever it occurs in the body of the abstraction. Variables that fall within the scope of an abstraction are said to be bound. All other variables are called free. For example, in the following expression y is a bound variable and x is free: \\lambda y . x \\ x \\ y. Also note that a variable is bound by its \"nearest\" abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: \\lambda x . y (\\lambda x . z \\ x) The set of free variables of a lambda expression, M, is denoted as \\operatorname{FV}(M) and is defined by recursion on the structure of the terms, as follows: # \\operatorname{FV}(x) = \\\\{ x \\\\}, where x is a variable # \\operatorname{FV}(\\lambda x . M) = \\operatorname{FV}(M) \\backslash \\\\{ x \\\\} # \\operatorname{FV}(M \\ N) = \\operatorname{FV}(M) \\cup \\operatorname{FV}(N) An expression that contains no free variables is said to be closed. Closed lambda expressions are also known as combinators and are equivalent to terms in combinatory logic. === Reduction === The meaning of lambda expressions is defined by how expressions can be reduced.de Queiroz, Ruy J.G.B. \"A Proof-Theoretic Account of Programming and the Role of Reduction Rules.\" Dialectica 42(4), pages 265-282, 1988. There are three kinds of reduction: * \u03b1-conversion: changing bound variables (alpha); * \u03b2-reduction: applying functions to their arguments (beta); * \u03b7-reduction: which captures a notion of extensionality (eta). We also speak of the resulting equivalences: two expressions are \u03b2-equivalent, if they can be \u03b2-converted into the same expression, and \u03b1/\u03b7-equivalence are defined similarly. The term redex, short for reducible expression, refers to subterms that can be reduced by one of the reduction rules. For example, (\\lambda x . M) \\ N is a \u03b2-redex in expressing the substitution of N for x in M; if x is not free in M, \\lambda x . M \\ x is an \u03b7-redex. The expression to which a redex reduces is called its reduct; using the previous example, the reducts of these expressions are respectively M[x := N] and M. ==== \u03b1-conversion ==== Alpha-conversion, sometimes known as alpha-renaming, allows bound variable names to be changed. For example, alpha-conversion of \\lambda x . x might yield \\lambda y . y. Terms that differ only by alpha-conversion are called \u03b1-equivalent. Frequently in uses of lambda calculus, \u03b1-equivalent terms are considered to be equivalent. The precise rules for alpha-conversion are not completely trivial. First, when alpha-converting an abstraction, the only variable occurrences that are renamed are those that are bound to the same abstraction. For example, an alpha-conversion of \\lambda x . \\lambda x . x could result in \\lambda y . \\lambda x . x, but it could not result in \\lambda y . \\lambda x . y. The latter has a different meaning from the original. Second, alpha-conversion is not possible if it would result in a variable getting captured by a different abstraction. For example, if we replace x with y in \\lambda x . \\lambda y . x, we get \\lambda y . \\lambda y . y, which is not at all the same. In programming languages with static scope, alpha-conversion can be used to make name resolution simpler by ensuring that no variable name masks a name in a containing scope (see alpha renaming to make name resolution trivial). ===== Substitution ===== Substitution, written E[V := R], is the process of replacing all free occurrences of the variable V in the expression E with expression R. Substitution on terms of the lambda calculus is defined by recursion on the structure of terms, as follows (note: x and y are only variables while M and N are any \u03bb expression). : \\begin{align} x[x := N] &\\equiv N\\\\\\ y[x := N] &\\equiv y\\text{, if } x eq y \\end{align} :\\begin{align} (M_{1} \\ M_{2})[x := N] &\\equiv (M_{1}[x := N]) \\ (M_{2}[x := N])\\\\\\ (\\lambda x . M)[x := N] &\\equiv \\lambda x . M\\\\\\ (\\lambda y . M)[x := N] &\\equiv \\lambda y . (M[x := N])\\text{, if }x eq y\\text{, provided }y otin FV(N) \\end{align} To substitute into a lambda abstraction, it is sometimes necessary to \u03b1-convert the expression. For example, it is not correct for (\\lambda x . y)[y := x] to result in (\\lambda x . x), because the substituted x was supposed to be free but ended up being bound. The correct substitution in this case is (\\lambda z . x), up to \u03b1-equivalence. Notice that substitution is defined uniquely up to \u03b1-equivalence. ==== \u03b2-reduction ==== \u03b2-reduction captures the idea of function application. \u03b2-reduction is defined in terms of substitution: the \u03b2-reduction of ((\\lambda V . E) \\ E') is E[V := E']. For example, assuming some encoding of 2, 7, \\times , we have the following \u03b2-reduction: ((\\lambda n . \\ n \\times 2) \\ 7) \\rightarrow 7 \\times 2. ==== \u03b7-reduction ==== \u03b7-reduction expresses the idea of extensionality, which in this context is that two functions are the same if and only if they give the same result for all arguments. \u03b7-reduction converts between \\lambda x . (f x) and f whenever x does not appear free in f. === Normalization === The purpose of \u03b2-reduction is to calculate a value. A value in lambda calculus is a function. So \u03b2-reduction continues until the expression looks like a function abstraction. A lambda expression that cannot be reduced further, by either \u03b2-redex, or \u03b7-redex is in normal form. Note that alpha-conversion may convert functions. All normal forms that can be converted into each other by \u03b1-conversion are defined to be equal. See the main article on Beta normal form for details. {| class=\"wikitable\" |- ! Normal Form Type !! Definition. |- | Normal Form || No \u03b2- or \u03b7-reductions are possible. |- | Head Normal Form || In the form of a lambda abstraction whose body is not reducible. |- | Weak Head Normal Form || In the form of a lambda abstraction. |} == Evaluation strategy == Whether a term is normalising or not, and how much work needs to be done in normalising it if it is, depends to a large extent on the reduction strategy used. The distinction between reduction strategies relates to the distinction in functional programming languages between eager evaluation and lazy evaluation. ;Full \u03b2-reductions: Any redex can be reduced at any time. This means essentially the lack of any particular reduction strategy\u2014with regard to reducibility, \"all bets are off\". ;Applicative order: The leftmost, innermost redex is always reduced first. Intuitively this means a function's arguments are always reduced before the function itself. Applicative order always attempts to apply functions to normal forms, even when this is not possible. :Most programming languages (including Lisp, ML and imperative languages like C and Java) are described as \"strict\", meaning that functions applied to non- normalising arguments are non-normalising. This is done essentially using applicative order, call by value reduction (see below), but usually called \"eager evaluation\". ;Normal order: The leftmost, outermost redex is always reduced first. That is, whenever possible the arguments are substituted into the body of an abstraction before the arguments are reduced. ;Call by value: Only the outermost redexes are reduced: a redex is reduced only when its right hand side has reduced to a value (variable or lambda abstraction). ;Call by name: As normal order, but no reductions are performed inside abstractions. For example, \\lambda x . (\\lambda x . x) x is in normal form according to this strategy, although it contains the redex (\\lambda x . x) x. ;Call by need: As normal order, but function applications that would duplicate terms instead name the argument, which is then reduced only \"when it is needed\". Called in practical contexts \"lazy evaluation\". In implementations this \"name\" takes the form of a pointer, with the redex represented by a thunk. Applicative order is not a normalising strategy. The usual counterexample is as follows: define \\Omega = \\omega\\omega where \\omega = \\lambda x . xx. This entire expression contains only one redex, namely the whole expression; its reduct is again \\Omega. Since this is the only available reduction, \\Omega has no normal form (under any evaluation strategy). Using applicative order, the expression KI\\Omega = (\\lambda x . \\lambda y . x) (\\lambda x . x)\\Omega is reduced by first reducing \\Omega to normal form (since it is the rightmost redex), but since \\Omega has no normal form, applicative order fails to find a normal form for KI\\Omega. In contrast, normal order is so called because it always finds a normalising reduction, if one exists. In the above example, KI\\Omega reduces under normal order to I, a normal form. A drawback is that redexes in the arguments may be copied, resulting in duplicated computation (for example, (\\lambda x . xx) ((\\lambda x . x)y) reduces to ((\\lambda x . x) y) ((\\lambda x . x)y) using this strategy; now there are two redexes, so full evaluation needs two more steps, but if the argument had been reduced first, there would now be none). The positive tradeoff of using applicative order is that it does not cause unnecessary computation, if all arguments are used, because it never substitutes arguments containing redexes and hence never needs to copy them (which would duplicate work). In the above example, in applicative order (\\lambda x . xx) ((\\lambda x . x)y) reduces first to (\\lambda x . xx)y and then to the normal order yy, taking two steps instead of three. Most purely functional programming languages (notably Miranda and its descendants, including Haskell), and the proof languages of theorem provers, use lazy evaluation, which is essentially the same as call by need. This is like normal order reduction, but call by need manages to avoid the duplication of work inherent in normal order reduction using sharing. In the example given above, (\\lambda x . xx) ((\\lambda x . x)y) reduces to ((\\lambda x . x)y) ((\\lambda x . x)y), which has two redexes, but in call by need they are represented using the same object rather than copied, so when one is reduced the other is too. == Syntax definition in BNF == Lambda Calculus has a simple syntax. A lambda calculus program has the syntax of an expression where, {| class=\"wikitable\" |- ! Name !! BNF !! Description |- | Abstraction || ::= \u03bb . || Anonymous function definition. |- | Application term || ::= || |- | Application || ::= || A function call. |- | Item || ::= || |- | Variable || ::= || E.g. x, y, fact, sum, ... |- | Grouping || ::= ( ) || Bracketed expression. |} The variable list is defined as, := | , A variable as used by computer scientists has the syntax, ::= ::= ::= ::= | | _ Mathematicians will sometimes restrict a variable to be a single alphabetic character. When using this convention the comma is omitted from the variable list. A lambda abstraction has a lower precedence than an application, so; : \\lambda x.y\\ z = \\lambda x.(y\\ z) Applications are left associative; : x\\ y\\ z = (x\\ y)\\ z An abstraction with multiple parameters is equivalent to multiple abstractions of one parameter. : \\lambda x.y.z = \\lambda x.\\lambda y.z where, * x is a variable * y is a variable list * z is an expression == Definition as mathematical formulas == The problem of how variables may be renamed is difficult. This definition avoids the problem by substituting all names with canonical names, which are constructed based on the position of the definition of the name in the expression. The approach is analogous to what a compiler does, but has been adapted to work within the constraints of mathematics. === Semantics === The execution of a lambda expression proceeds using the following reductions and transformations, # \u03b1-conversion - \\operatorname{alpha-conv}(a) \\to \\operatorname{canonym}[A, P] = \\operatorname{canonym}[a[A], P] # \u03b2-reduction - \\operatorname{beta- redex}[\\lambda p.b\\ v] = b[p:=v] # \u03b7-reduction - x ot \\in \\operatorname{FV}(f) \\to \\operatorname{eta-redex}[\\lambda x.(f \\ x)] = f where, * canonym is a renaming of a lambda expression to give the expression standard names, based on the position of the name in the expression. * Substitution Operator, b[p:=v] is the substitution of the name p by the lambda expression v in lambda expression b. * Free Variable Set \\operatorname{FV}(f) is the set of variables that do not belong to a lambda abstraction in f. Execution is performing \u03b2-reductions and \u03b7-reductions on subexpressions in the canonym of a lambda expression until the result is a lambda function (abstraction) in the normal form. All \u03b1-conversions of a \u03bb-expression are considered to be equivalent. === Canonym - Canonical Names === Canonym is a function that takes a lambda expression and renames all names canonically, based on their positions in the expression. This might be implemented as, : \\begin{align} \\operatorname{canonym}[L, Q] &= \\operatorname{canonym}[L, O, Q] \\\\\\ \\operatorname{canonym}[\\lambda p.b, M, Q] &= \\lambda \\operatorname{name}(Q).\\operatorname{canonym}[b, M[p:=Q], Q+N] \\\\\\ \\operatorname{canonym}[X \\ Y, x, Q] &= \\operatorname{canonym}[X, x, Q+F] \\ \\operatorname{canonym}[Y, x, E+S] \\\\\\ \\operatorname{canonym}[x, M, Q] &= \\operatorname{name}(M[x]) \\end{align} Where, N is the string \"N\", F is the string \"F\", S is the string \"S\", + is concatenation, and \"name\" converts a string into a name === Map operators === Map from one value to another if the value is in the map. O is the empty map. # O[x] = x # M[x:=y][x] = y # x e z \\to M[x:=y][z] = M[z] === Substitution operator === If L is a lambda expression, x is a name, and y is a lambda expression; L[x:=y] means substitute x by y in L. The rules are, # (\\lambda p.b)[x := y] = \\lambda p.b[x := y] # (X \\, Y)[x := y] = X[x := y] \\, Y[x := y] # z = x \\to (z)[x := y] = y # z e x \\to (z)[x := y] = z Note that rule 1 must be modified if it is to be used on non canonically renamed lambda expressions. See Changes to the substitution operator. === Free and bound variable sets === The set of free variables of a lambda expression, M, is denoted as FV(M). This is the set of variable names that have instances not bound (used) in a lambda abstraction, within the lambda expression. They are the variable names that may be bound to formal parameter variables from outside the lambda expression. The set of bound variables of a lambda expression, M, is denoted as BV(M). This is the set of variable names that have instances bound (used) in a lambda abstraction, within the lambda expression. The rules for the two sets are given below. {| class=\"wikitable\" |- ! \\mathrm{FV}(M) \\- Free Variable Set ! Comment ! \\mathrm{BV}(M) \\- Bound Variable Set ! Comment |- | \\mathrm{FV}(x) = \\\\{x\\\\} | where x is a variable | \\mathrm{BV}(x) = \\emptyset | where x is a variable |- | \\mathrm{FV}(\\lambda x.M) = \\mathrm{FV}(M) \\setminus \\\\{x\\\\} | Free variables of M excluding x | \\mathrm{BV}(\\lambda x.M) = \\mathrm{BV}(M) \\cup \\\\{x\\\\} | Bound variables of M plus x. |- | \\mathrm{FV}(M \\ N) = \\mathrm{FV}(M) \\cup \\mathrm{FV}(N) | Combine the free variables from the function and the parameter | \\mathrm{BV}(M \\ N) = \\mathrm{BV}(M) \\cup \\mathrm{BV}(N) | Combine the bound variables from the function and the parameter |} Usage; * The Free Variable Set, FV is used above in the definition of the \u03b7-reduction. * The Bound Variable Set, BV, is used in the rule for \u03b2-redex of non canonical lambda expression. === Evaluation strategy === This mathematical definition is structured so that it represents the result, and not the way it gets calculated. However the result may be different between lazy and eager evaluation. This difference is described in the evaluation formulas. The definitions given here assume that the first definition that matches the lambda expression will be used. This convention is used to make the definition more readable. Otherwise some if conditions would be required to make the definition precise. Running or evaluating a lambda expression L is, : \\operatorname{eval}[\\operatorname{canonym}[L], Q] where Q is a name prefix possibly an empty string and eval is defined by, : \\begin{align} \\operatorname{eval}[x\\ y] &= \\operatorname{eval}[\\operatorname{apply}[\\operatorname{eval}[x]\\ \\operatorname{strategy}[y ] \\\\\\ \\operatorname{apply}[(\\lambda x.y)\\ z] &= \\operatorname{canonym}[\\operatorname{beta-redex}[(\\lambda x.y)\\ z], x] \\\\\\ \\operatorname{apply}[x] &= x \\text{ if x does match the above.}\\\\\\ \\operatorname{eval}[\\lambda x.(f\\ x)] &= \\operatorname{eval}[\\operatorname{eta-redex}[\\lambda x.(f\\ x) \\\\\\ \\operatorname{eval}[L] &= L \\\\\\ \\operatorname{lazy}[X] &= X \\\\\\ \\operatorname{eager}[X] &= \\operatorname{eval}[X] \\end{align} Then the evaluation strategy may be chosen as either, : \\begin{align} \\operatorname{strategy} &= \\operatorname{lazy} \\\\\\ \\operatorname{strategy} &= \\operatorname{eager} \\end{align} The result may be different depending on the strategy used. Eager evaluation will apply all reductions possible, leaving the result in normal form, while lazy evaluation will omit some reductions in parameters, leaving the result in \"weak head normal form\". ==== Normal form ==== All reductions that can be applied have been applied. This is the result obtained from applying eager evaluation. : \\begin{align} \\operatorname{normal}[(\\lambda x.y)\\ z] &= \\operatorname{false} \\\\\\ \\operatorname{normal}[\\lambda x.(f\\ x)] &= \\operatorname{false} \\\\\\ \\operatorname{normal}[x\\ y] &= \\operatorname{normal}[x] \\land \\operatorname{normal}[y] \\end{align} In all other cases, : \\operatorname{normal}[x] = \\operatorname{true} ==== Weak head normal form ==== Reductions to the function (the head) have been applied, but not all reductions to the parameter have been applied. This is the result obtained from applying lazy evaluation. : \\begin{align} \\operatorname{whnf}[(\\lambda x.y)\\ z] &= \\operatorname{false} \\\\\\ \\operatorname{whnf}[\\lambda x.(f\\ x)] &= \\operatorname{false} \\\\\\ \\operatorname{whnf}[x\\ y] &= \\operatorname{whnf}[x] \\end{align} In all other cases, : \\operatorname{whnf}[x] = \\operatorname{true} == Derivation of standard from the math definition == The standard definition of lambda calculus uses some definitions which may be considered as theorems, which can be proved based on the definition as mathematical formulas. The canonical naming definition deals with the problem of variable identity by constructing a unique name for each variable based on the position of the lambda abstraction for the variable name in the expression. This definition introduces the rules used in the standard definition and relates explains them in terms of the canonical renaming definition. ===Free and bound variables=== The lambda abstraction operator, \u03bb, takes a formal parameter variable and a body expression. When evaluated the formal parameter variable is identified with the value of the actual parameter. Variables in a lambda expression may either be \"bound\" or \"free\". Bound variables are variable names that are already attached to formal parameter variables in the expression. The formal parameter variable is said to bind the variable name wherever it occurs free in the body. Variable (names) that have already been matched to formal parameter variable are said to be bound. All other variables in the expression are called free. For example, in the following expression y is a bound variable and x is free: \\lambda y.x \\ x \\ y. Also note that a variable is bound by its \"nearest\" lambda abstraction. In the following example the single occurrence of x in the expression is bound by the second lambda: \\lambda x.y \\ (\\lambda x.z \\ x) === Changes to the substitution operator === In the definition of the Substitution Operator the rule, * (\\lambda p.b)[x := y] = \\lambda p.b[x := y] must be replaced with, # (\\lambda x.b)[x := y] = \\lambda x.b # z e x\\ \\to (\\lambda z.b)[x := y] = \\lambda z.b[x := y] This is to stop bound variables with the same name being substituted. This would not have occurred in a canonically renamed lambda expression. For example the previous rules would have wrongly translated, :(\\lambda x.x \\ z)[x:=y] = (\\lambda x.y \\ z) The new rules block this substitution so that it remains as, :(\\lambda x.x \\ z)[x:=y] = (\\lambda x.x \\ z) === Transformation === The meaning of lambda expressions is defined by how expressions can be transformed or reduced. There are three kinds of transformation: * \u03b1-conversion: changing bound variables (alpha); * \u03b2-reduction: applying functions to their arguments (beta), calling functions; * \u03b7-reduction: which captures a notion of extensionality (eta). We also speak of the resulting equivalences: two expressions are \u03b2-equivalent, if they can be \u03b2-converted into the same expression, and \u03b1/\u03b7-equivalence are defined similarly. The term redex, short for reducible expression, refers to subterms that can be reduced by one of the reduction rules. ==== \u03b1-conversion ==== Alpha-conversion, sometimes known as alpha-renaming, allows bound variable names to be changed. For example, alpha-conversion of \\lambda x.x might give \\lambda y.y. Terms that differ only by alpha-conversion are called \u03b1-equivalent. In an \u03b1-conversion, names may be substituted for new names if the new name is not free in the body, as this would lead to the capture of free variables. :(y ot \\in FV(b) \\land a(\\lambda x.b) = \\lambda y.b[x:=y]) \\to \\operatorname{alpha-con}(a) Note that the substitution will not recurse into the body of lambda expressions with formal parameter x because of the change to the substitution operator described above. See example; {| class=\"wikitable\" ! \u03b1-conversion ! \u03bb-expression ! Canonically named ! Comment |- | | \\lambda z. \\lambda y.(z \\ y) | \\lambda \\operatorname{P}. \\lambda \\operatorname{PN}.(\\operatorname{P} \\operatorname{PN}) | Original expressions. |- | correctly rename y to k, (because k is not used in the body) | \\lambda z. \\lambda k.(z \\ k) | \\lambda \\operatorname{P}. \\lambda \\operatorname{PN}.(\\operatorname{P} \\operatorname{PN}) | No change to canonical renamed expression. |- | naively rename y to z, (wrong because z free in \\lambda y.(z \\ y)) | \\lambda z. \\lambda z.(z \\ z) | \\lambda \\operatorname{P}. \\lambda \\operatorname{PN}.({\\color{Red}\\operatorname{PN}} \\operatorname{PN}) | z is captured. |} ==== \u03b2-reduction (capture avoiding) ==== \u03b2-reduction captures the idea of function application (also called a function call), and implements the substitution of the actual parameter expression for the formal parameter variable. \u03b2-reduction is defined in terms of substitution. If no variable names are free in the actual parameter and bound in the body, \u03b2-reduction may be performed on the lambda abstraction without canonical renaming. : (\\forall z: z ot \\in FV(y) \\lor z ot \\in BV(b)) \\to \\operatorname{beta-redex}[\\lambda x.b \\ y] = b[x:=y] Alpha renaming may be used on b to rename names that are free in y but bound in b, to meet the pre-condition for this transformation. See example; {| class=\"wikitable\" ! \u03b2-reduction ! \u03bb-expression ! Canonically named ! Comment |- | | (\\lambda x.\\lambda y.(\\lambda z.(\\lambda x.z \\ x)(\\lambda y.z \\ y)) (x \\ y)) | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.(\\lambda \\operatorname{PNF}.(\\lambda \\operatorname{PNFNF}.\\operatorname{PNF} \\operatorname{PNFNF})(\\lambda \\operatorname{PNFNS}.\\operatorname{PNF} \\operatorname{PNFNS})) (\\operatorname{P} \\operatorname{PN})) | Original expressions. |- | Naive beta 1, | (\\lambda x.\\lambda y.((\\lambda x.(x \\ y) x)(\\lambda y.(x \\ y) y))) | {| |- | Canonical | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.((\\lambda \\operatorname{PNF}.({\\color{Blue}\\operatorname{P}} \\operatorname{PN}) \\operatorname{PNF})(\\lambda \\operatorname{PNS}.(\\operatorname{P} {\\color{Blue}\\operatorname{PN}}) \\operatorname{PNS}))) |- | Natural | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.((\\lambda \\operatorname{PNF}.({\\color{Red}\\operatorname{PNF}} \\operatorname{PN}) \\operatorname{PNF})(\\lambda \\operatorname{PNS}.(\\operatorname{P} {\\color{Red}\\operatorname{PNS})} \\operatorname{PNS}))) |} | x (P) and y (PN) have been captured in the substitution. |- | Alpha rename inner, x -> a, y -> b | (\\lambda x.\\lambda y.(\\lambda z.(\\lambda x.z \\ a)(\\lambda b.z \\ b)) (x \\ y)) | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.(\\lambda \\operatorname{PNF}.(\\lambda \\operatorname{PNFNF}.\\operatorname{PNF} \\operatorname{PNFNF})(\\lambda \\operatorname{PNFNS}.\\operatorname{PNF} \\operatorname{PNFNS})) (\\operatorname{P} \\operatorname{PN})) | |- | Beta 2, | (\\lambda x.\\lambda y.((\\lambda a.(x \\ y) a)(\\lambda b.(x \\ y) b))) | {| |- | Canonical | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.((\\lambda \\operatorname{PNF}.(\\operatorname{P} \\operatorname{PN}) \\operatorname{PNF})(\\lambda \\operatorname{PNS}.(\\operatorname{P} \\operatorname{PN}) \\operatorname{PNS}))) |- | Natural | (\\lambda \\operatorname{P}.\\lambda \\operatorname{PN}.((\\lambda \\operatorname{PNF}.(\\operatorname{P} \\operatorname{PN}) \\operatorname{PNF})(\\lambda \\operatorname{PNS}.(\\operatorname{P} \\operatorname{PN}) \\operatorname{PNS}))) |} | x and y not captured. |} :\\begin{array}{r} ((\\lambda x.z \\ x)(\\lambda y.z \\ y))[z := (x \\ y)] \\\\\\ ((\\lambda a.z \\ a)(\\lambda b.z \\ b))[z := (x \\ y)] \\end{array} In this example, # In the \u03b2-redex, ## The free variables are, \\operatorname{FV}(x \\ y) = \\\\{x, y\\\\} ## The bound variables are, \\operatorname{BV}((\\lambda x.z \\ x)(\\lambda y.z \\ y)) = \\\\{x, y\\\\} # The naive \u03b2-redex changed the meaning of the expression because x and y from the actual parameter became captured when the expressions were substituted in the inner abstractions. # The alpha renaming removed the problem by changing the names of x and y in the inner abstraction so that they are distinct from the names of x and y in the actual parameter. ## The free variables are, \\operatorname{FV}(x \\ y) = \\\\{x, y\\\\} ## The bound variables are, \\operatorname{BV}((\\lambda a.z \\ a)(\\lambda b.z \\ b)) = \\\\{a, b\\\\} # The \u03b2-redex then proceeded with the intended meaning. ==== \u03b7-reduction ==== \u03b7-reduction expresses the idea of extensionality, which in this context is that two functions are the same if and only if they give the same result for all arguments. \u03b7-reduction may be used without change on lambda expressions that are not canonically renamed. : x ot \\in \\mathrm{FV}(f) \\to \\text{\u03b7-redex}[\\lambda x.(f x)] = f The problem with using an \u03b7-redex when f has free variables is shown in this example, {| class=\"wikitable\" |- ! Reduction !! Lambda expression !! \u03b2-reduction |- | | (\\lambda x.(\\lambda y.y \\, x) \\, x) \\, a | \\lambda a.a \\, a |- | Naive \u03b7-reduction | (\\lambda y.y \\, x) \\, a | \\lambda a.a \\, x |} This improper use of \u03b7-reduction changes the meaning by leaving in \\lambda y.y \\, x unsubstituted. == References == Category:Lambda calculus ",
    "title": "Lambda calculus definition"
}