{
    "id": "45538",
    "text": "The Mersenne Twister is a pseudorandom number generator (PRNG). It is by far the most widely used general-purpose PRNG.E.g. Marsland S. (2011) Machine Learning (CRC Press), \u00a74.1.1. Also see the section \"Adoption in software systems\". Its name derives from the fact that its period length is chosen to be a Mersenne prime. The Mersenne Twister was developed in 1997 by and . It was designed specifically to rectify most of the flaws found in older PRNGs. The most commonly used version of the Mersenne Twister algorithm is based on the Mersenne prime 219937\u22121. The standard implementation of that, MT19937, uses a 32-bit word length. There is another implementation (with five variants) that uses a 64-bit word length, MT19937-64; it generates a different sequence. ==Adoption in software systems== The Mersenne Twister is the default PRNG for the following software systems: Dyalog APL, Microsoft Excel,. GAUSS,GAUSS 14 Language Reference GLib,Random Numbers: GLib Reference Manual GNU Multiple Precision Arithmetic Library, GNU Octave, GNU Scientific Library, gretl,\"uniform\". Gretl Function Reference. IDL, Julia, CMU Common Lisp, Embeddable Common Lisp, Steel Bank Common Lisp, Maple, MATLAB, Free Pascal, PHP, Python, R, Ruby, SageMath,Probability Distributions \u2014 Sage Reference Manual v7.2: Probablity Scilab, Stata.New random-number generator\u201464-bit Mersenne Twister It is also available in Apache Commons, in standard C++ (since C++11), and in Mathematica. Mathematica Documentation Add-on implementations are provided in many program libraries, including the Boost C++ Libraries, the CUDA Library, and the NAG Numerical Library. The Mersenne Twister is one of two PRNGs in SPSS: the other generator is kept only for compatibility with older programs, and the Mersenne Twister is stated to be \"more reliable\". The Mersenne Twister is similarly one of the PRNGs in SAS: the other generators are older and deprecated. The Mersenne Twister is the default PRNG in Stata, the other one is KISS, for compatibility with older versions of Stata.Stata help: set rng -- Set which random-number generator (RNG) to use ==Advantages== * Permissively-licensed and patent-free for all variants except CryptMT. * Passes numerous tests for statistical randomness, including the Diehard tests and most, but not all of the TestU01 tests.P. L'Ecuyer and R. Simard, \"TestU01: \"A C library for empirical testing of random number generators\", ACM Transactions on Mathematical Software, 33, 4, Article 22 (August 2007). * A very long period of 219937 \u2212 1\\. Note that while a long period is not a guarantee of quality in a random number generator, short periods, such as the 232 common in many older software packages, can be problematic.Note: 219937 is approximately 4.3 \u00d7 106001; this is many orders of magnitude larger than the estimated number of particles in the observable universe, which is 1087. * k-distributed to 32-bit accuracy for every 1 \u2264 k \u2264 623 (for a definition of k-distributed, see below) * Implementations generally create random numbers faster than true random methods. A study found that the Mersenne Twister creates 64-bit floating point random numbers approximately twenty times faster than the hardware-implemented, processor-based RDRAND instruction set. ==Disadvantages== * Relatively large state buffer, of 2.5 KiB, unless the TinyMT variant (discussed below) is used. * Mediocre throughput by modern standards, unless the SFMT variant (discussed below) is used. * Exhibits two clear failures (linear complexity) in both Crush and BigCrush in the TestU01 suite. The test, like Mersenne Twister, is based on F2 algebra. There are a number of other generators that pass all the tests (and numerous generators that fail badly). * Multiple instances that differ only in seed value (but not other parameters) are not generally appropriate for Monte- Carlo simulations that require independent random number generators, though there exists a method for choosing multiple sets of parameter values. * Poor diffusion: can take a long time to start generating output that passes randomness tests, if the initial state is highly non-random\u2014particularly if the initial state has many zeros. A consequence of this is that two instances of the generator, started with initial states that are almost the same, will usually output nearly the same sequence for many iterations, before eventually diverging. The 2002 update to the MT algorithm has improved initialization, so that beginning with such a state is very unlikely. The GPU version (MTGP) is said to be even better. * Contains subsequences with more 0's than 1's. This adds to the poor diffusion property to make recovery from many-zero states difficult. * Is not cryptographically secure, unless the CryptMT variant (discussed below) is used. The reason is that observing a sufficient number of iterations (624 in the case of MT19937, since this is the size of the state vector from which future iterations are produced) allows one to predict all future iterations. ==Alternatives== An alternative generator, WELL (\"Well Equidistributed Long-period Linear\"), offers quicker recovery, and equal randomness, and nearly equal speed.P. L'Ecuyer, \"Uniform Random Number Generators\", International Encyclopedia of Statistical Science, Lovric, Miodrag (Ed.), Springer-Verlag, 2010. Marsaglia's xorshift generators and variants are the fastest in the class of LFSRs. 64-bit MELGs (\"64-bit Maximally Equidistributed F2-Linear Generators with Mersenne Prime Period\") are completely optimized in terms of the k-distribution properties. The ACORN family (published 1989) is another k-distributed PRNG, which shows similar computational speed to MT, and better statistical properties as it satisfies all the current (2019) TestU01 criteria; when used with appropriate choices of parameters, ACORN can have arbitrarily long period and precision. ==k-distribution== A pseudorandom sequence xi of w-bit integers of period P is said to be k-distributed to v-bit accuracy if the following holds. : Let truncv(x) denote the number formed by the leading v bits of x, and consider P of the k v-bit vectors :: (\\text{trunc}_v(x_i), \\, \\text{trunc}_v(x_{i+1}), \\, ..., \\, \\text{trunc}_v(x_{i+k-1})) \\quad (0\\leq i< P) . : Then each of the 2kv possible combinations of bits occurs the same number of times in a period, except for the all-zero combination that occurs once less often. ==Algorithmic detail== Visualisation of generation of pseudo-random 32-bit integers using a Mersenne Twister. The 'Extract number' section shows an example where integer 0 has already been output and the index is at integer 1. 'Generate numbers' is run when all integers have been output. For a w-bit word length, the Mersenne Twister generates integers in the range [0, 2w\u22121]. The Mersenne Twister algorithm is based on a matrix linear recurrence over a finite binary field F2. The algorithm is a twisted generalised feedback shift register (twisted GFSR, or TGFSR) of rational normal form (TGFSR(R)), with state bit reflection and tempering. The basic idea is to define a series x_i through a simple recurrence relation, and then output numbers of the form x_i T, where T is an invertible F2 matrix called a tempering matrix. The general algorithm is characterized by the following quantities (some of these explanations make sense only after reading the rest of the algorithm): * w: word size (in number of bits) * n: degree of recurrence * m: middle word, an offset used in the recurrence relation defining the series x, 1 \u2264 m < n * r: separation point of one word, or the number of bits of the lower bitmask, 0 \u2264 r \u2264 w - 1 * a: coefficients of the rational normal form twist matrix * b, c: TGFSR(R) tempering bitmasks * s, t: TGFSR(R) tempering bit shifts * u, d, l: additional Mersenne Twister tempering bit shifts/masks with the restriction that 2nw \u2212 r \u2212 1 is a Mersenne prime. This choice simplifies the primitivity test and k-distribution test that are needed in the parameter search. The series x is defined as a series of w-bit quantities with the recurrence relation: :x_{k+n} := x_{k+m} \\oplus \\left( ({x_k}^u \\mid\\mid {x_{k+1}}^l) A \\right) \\qquad \\qquad k=0,1,\\ldots where \\mid\\mid denotes concatenation of bit vectors (with upper bits on the left), \\oplus the bitwise exclusive or (XOR), {x_k}^u means the upper w - r bits of x_k, and x_{k+1}^l means the lower r bits of x_{k+1}. The twist transformation A is defined in rational normal form as: A = \\begin{pmatrix} 0 & I_{w - 1} \\\\\\ a_{w-1} & (a_{w - 2}, \\ldots , a_0) \\end{pmatrix} with In \u2212 1 as the (n \u2212 1) \u00d7 (n \u2212 1) identity matrix. The rational normal form has the benefit that multiplication by A can be efficiently expressed as: (remember that here matrix multiplication is being done in F2, and therefore bitwise XOR takes the place of addition) \\boldsymbol{x}A = \\begin{cases}\\boldsymbol{x} \\gg 1 & x_0 = 0\\\\\\\\(\\boldsymbol{x} \\gg 1) \\oplus \\boldsymbol{a} & x_0 = 1\\end{cases} where x0 is the lowest order bit of x. As like TGFSR(R), the Mersenne Twister is cascaded with a tempering transform to compensate for the reduced dimensionality of equidistribution (because of the choice of A being in the rational normal form). Note that this is equivalent to using the matrix A where A=T^{-1} AT for T an invertible matrix, and therefore the analysis of characteristic polynomial mentioned below still holds. As with A, we choose a tempering transform to be easily computable, and so do not actually construct T itself. The tempering is defined in the case of Mersenne Twister as :y := x \u2295 ((x >> u) & d) :y := y \u2295 ((y << s) & b) :y := y \u2295 ((y << t) & c) :z := y \u2295 (y >> l) where x is the next value from the series, y a temporary intermediate value, z the value returned from the algorithm, with <<, >> as the bitwise left and right shifts, and & as the bitwise and. The first and last transforms are added in order to improve lower-bit equidistribution. From the property of TGFSR, s + t \\ge \\lfloor w/2 \\rfloor - 1 is required to reach the upper bound of equidistribution for the upper bits. The coefficients for MT19937 are: * (w, n, m, r) = (32, 624, 397, 31) * a = 9908B0DF16 * (u, d) = (11, FFFFFFFF16) * (s, b) = (7, 9D2C568016) * (t, c) = (15, EFC6000016) * l = 18 Note that 32-bit implementations of the Mersenne Twister generally have d = FFFFFFFF16. As a result, the d is occasionally omitted from the algorithm description, since the bitwise and with d in that case has no effect. The coefficients for MT19937-64 are: * (w, n, m, r) = (64, 312, 156, 31) * a = B5026F5AA96619E916 * (u, d) = (29, 555555555555555516) * (s, b) = (17, 71D67FFFEDA6000016) * (t, c) = (37, FFF7EEE00000000016) * l = 43 ===Initialization=== The state needed for a Mersenne Twister implementation is an array of n values of w bits each. To initialize the array, a w-bit seed value is used to supply x0 through xn \u2212 1 by setting x0 to the seed value and thereafter setting :xi = f \u00d7 (xi\u22121 \u2295 (xi\u22121 >> (w\u22122))) + i for i from 1 to n\u22121. The first value the algorithm then generates is based on xn, not on x0. The constant f forms another parameter to the generator, though not part of the algorithm proper. The value for f for MT19937 is 1812433253 and for MT19937-64 is 6364136223846793005. ===Comparison with classical GFSR=== In order to achieve the 2nw \u2212 r \u2212 1 theoretical upper limit of the period in a TGFSR, \u03c6B(t) must be a primitive polynomial, \u03c6B(t) being the characteristic polynomial of B = \\begin{pmatrix} 0 & I_{w} & \\cdots & 0 & 0 \\\\\\ \\vdots & & & & \\\\\\ I_{w} & \\vdots & \\ddots & \\vdots & \\vdots \\\\\\ \\vdots & & & & \\\\\\ 0 & 0 & \\cdots & I_{w} & 0 \\\\\\ 0 & 0 & \\cdots & 0 & I_{w - r} \\\\\\ S & 0 & \\cdots & 0 & 0 \\end{pmatrix} \\begin{matrix} \\\\\\ \\\\\\ \\leftarrow m\\hbox{-th row} \\\\\\ \\\\\\ \\\\\\ \\\\\\ \\end{matrix} S = \\begin{pmatrix} 0 & I_{r} \\\\\\ I_{w - r} & 0 \\end{pmatrix} A The twist transformation improves the classical GFSR with the following key properties: * The period reaches the theoretical upper limit 2nw \u2212 r \u2212 1 (except if initialized with 0) * Equidistribution in n dimensions (e.g. linear congruential generators can at best manage reasonable distribution in five dimensions) ===Pseudocode=== The following pseudocode implements the general Mersenne Twister algorithm. The constants w, n, m, r, a, u, d, s, b, t, c, l, and f are as in the algorithm description above. It is assumed that int represents a type sufficient to hold values with w bits: // Create a length n array to store the state of the generator int[0..n-1] MT int index := n+1 const int lower_mask = (1 << r) - 1 // That is, the binary number of r 1's const int upper_mask = lowest w bits of (not lower_mask) // Initialize the generator from a seed function seed_mt(int seed) { index := n MT[0] := seed for i from 1 to (n - 1) { // loop over each element MT[i] := lowest w bits of (f * (MT[i-1] xor (MT[i-1] >> (w-2))) + i) } } // Extract a tempered value based on MT[index] // calling twist() every n numbers function extract_number() { if index >= n { if index > n { error \"Generator was never seeded\" // Alternatively, seed with constant value; 5489 is used in reference C code } twist() } int y := MT[index] y := y xor ((y >> u) and d) y := y xor ((y << s) and b) y := y xor ((y << t) and c) y := y xor (y >> l) index := index + 1 return lowest w bits of (y) } // Generate the next n values from the series x_i function twist() { for i from 0 to (n-1) { int x := (MT[i] and upper_mask) \\+ (MT[(i+1) mod n] and lower_mask) int xA := x >> 1 if (x mod 2) != 0 { // lowest bit of x is 1 xA := xA xor a } MT[i] := MT[(i + m) mod n] xor xA } index := 0 } ==Variants== ===CryptMT=== CryptMT is a stream cipher and cryptographically secure pseudorandom number generator which uses Mersenne Twister internally. It was developed by Matsumoto and Nishimura alongside Mariko Hagita and Mutsuo Saito. It has been submitted to the eSTREAM project of the eCRYPT network. Unlike Mersenne Twister or its other derivatives, CryptMT is patented. ===MTGP=== MTGP is a variant of Mersenne Twister optimised for graphics processing units published by Mutsuo Saito and Makoto Matsumoto. The basic linear recurrence operations are extended from MT and parameters are chosen to allow many threads to compute the recursion in parallel, while sharing their state space to reduce memory load. The paper claims improved equidistribution over MT and performance on a very old GPU (Nvidia GTX260 with 192 cores) of 4.7 ms for 5\u00d7107 random 32-bit integers. ===SFMT=== The SFMT (SIMD-oriented Fast Mersenne Twister) is a variant of Mersenne Twister, introduced in 2006, designed to be fast when it runs on 128-bit SIMD. * It is roughly twice as fast as Mersenne Twister. * It has a better equidistribution property of v-bit accuracy than MT but worse than WELL (\"Well Equidistributed Long-period Linear\"). * It has quicker recovery from zero-excess initial state than MT, but slower than WELL. * It supports various periods from 2607\u22121 to 2216091\u22121. Intel SSE2 and PowerPC AltiVec are supported by SFMT. It is also used for games with the Cell BE in the PlayStation 3. ===TinyMT=== TinyMT is a variant of Mersenne Twister, proposed by Saito and Matsumoto in 2011. TinyMT uses just 127 bits of state space, a significant decrease compared to the original's 2.5 KiB of state. However, it has a period of 2127\u22121, far shorter than the original, so it is only recommended by the authors in cases where memory is at a premium. ==References== ==Further reading== * . * . ==External links== * The academic paper for MT, and related articles by Makoto Matsumoto * Mersenne Twister home page, with codes in C, Fortran, Java, Lisp and some other languages * Mersenne Twister examples \u2014a collection of Mersenne Twister implementations, in several programming languages - at GitHub * SFMT in Action: Part I \u2013 Generating a DLL Including SSE2 Support \u2013 at Code Project Category:Pseudorandom number generators Category:Articles with example pseudocode Category:Japanese inventions ",
    "title": "Mersenne Twister"
}