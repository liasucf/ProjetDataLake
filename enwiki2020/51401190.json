{
    "id": "51401190",
    "text": "In computer science, a quaject is an object-like data structure containing both data and code (or pointers to code), exposed as an interface in the form of callentries, and can accept a list of callentries to other quajects for callbacks and callouts. They were developed by Alexia Massalin in 1989 for the Synthesis kernel, and named for the Qua! Machine, a unique hardware platform built by Massalin. The origin of the term 'qua' is unclear; Massalin claims humorously that it is a sound made by koalas. The main purpose of quajects is to provide an abstraction to manage self-modifying code, by allowing runtime code optimizing on a per-object basis. While the original Synthesis kernel required quajects to be written in hand-developed assembly language, this was done to avoid developing a complex compiler; Massalin noted that just-in-time compilation (JIT) for a high-level programming language that permits runtime code generation, as in Lisp or Smalltalk, can also apply this approach, though she also asserted that the complexity of such a compiler was likely to be prohibitive. Quajects differ from more conventional objects in two key ways: first, they always use a form of the dependency injection pattern to manage both interfaces to other quajects, and continuations out of the quaject; the list of callentry references for this is part of quaject creation, and may be updated during the quaject's lifetime. Second, and more critically, a given quaject's set of methods can be unique to the specific quaject; methods for a type or class of quajects are stored as one or more templates, rather than as fixed code. While shared methods can be accessed through a common table of pointers, individual quajects can also have methods that are generated specifically to tailor the performance for that quaject's behavior. ==References== Category:Computer science Category:Operating system technology ",
    "title": "Quaject"
}