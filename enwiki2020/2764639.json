{
    "id": "2764639",
    "text": "In computer networking, STREAMS is the native framework in Unix System V for implementing character device drivers, network protocols, and inter-process communication. In this framework, a stream is a chain of coroutines that pass messages between a program and a device driver (or between a pair of programs). STREAMS originated in Version 8 Research Unix, as Streams (not capitalized). STREAMS's design is a modular architecture for implementing full-duplex I/O between kernel and device drivers. Its most frequent uses have been in developing terminal I/O (line discipline) and networking subsystems. In System V Release 4, the entire terminal interface was reimplemented using STREAMS. An important concept in STREAMS is the ability to push drivers custom code modules which can modify the functionality of a network interface or other device together to form a stack. Several of these drivers can be chained together in order. == History == STREAMS was based on the Streams I/O subsystem introduced in the Eighth Edition Research Unix (V8) by Dennis Ritchie, where it was used for the terminal I/O subsystem and the Internet protocol suite. This version, not yet called STREAMS in capitals, fit the new functionality under the existing device I/O system calls (open, close, read, write, and ioctl), and its application was limited to terminal I/O and protocols providing pipe-like I/O semantics. This I/O system was ported to System V Release 3 by Robert Israel, Gil McGrath, Dave Olander, Her-Daw Che, and Maury Bach as part of a wider framework intended to support a variety of transport protocols, including TCP, ISO Class 4 transport, SNA LU 6.2, and the AT&T; NPACK protocol (used in RFS). It was first released with the Network Support Utilities (NSU) package of UNIX System V Release 3. This port added the putmsg, getmsg, and poll system calls, which are nearly equivalent in purpose to the send, recv, and select calls from Berkeley sockets. The putmsg and getmsg system calls were originally called send and recv, but were renamed to avoid namespace conflict. In System V Release 4, STREAMS was extended and used for the terminal I/O framework and pipes, providing useful new functionality like bidirectional pipes and file descriptor passing. A port for Unicos was also produced. Eric S. Raymond quotes Ritchie as saying about the complexity of System V STREAMS when compared to his V8 Streams that \"Streams means something different when shouted\". Concurrent with the System V Release 3 port, AT&T; developed protocol-independent STREAMS message passing guidelines for the link, network, and transport layers of the OSI model (layers 2-4). Due to the typically close implementation coupling of the network and transport protocols in a given protocol stack, and the typical practice of implementing layers 5-7 outside of the kernel, only the link and transport layer STREAMS service interfaces were later standardized by X/Open. In conjunction with the transport message passing model, the Transport Layer Interface (later adopted as the X/Open Transport Interface) was defined to provide a transport protocol-independent API for application development. Also, a library supporting the session, presentation and application layers was defined and later standardized by The Open Group. STREAMS was required for conformance with the Single UNIX Specification versions 1 (UNIX 95) and 2 (UNIX 98), but as a result of the refusal of the BSD and Linux developers to provide STREAMS, was marked as optional for POSIX compliance by the Austin Group in version 3 (UNIX 03). POSIX.1-2008 with TC1 (IEEE Std 1003.1, 2013 edition) has designated STREAMS as 'marked obsolescent' meaning that said functionality may be removed in a future version of the specification. However, the specific definition of 'obsolescent' used also says that strictly conforming POSIX applications 'shall not use obsolescent features'. == Technical overview == Example use of Streams to implement remote command execution over a network, after In Version 7 Unix, a command was connected to a terminal (keyboard and screen, or keyboard and printer) through a mechanism called the line discipline, which would buffer a single line of input, i.e., wait for the user to press the Return key before sending input to the program for processing; this allowed simple error correction. Streams replaced this with a set of processing modules organized in a linear chain that allowed bidirectional communication between neighboring modules. Programs could \"push\" a new module onto one end of the chain to change the behavior of a terminal or other character device. Ritchie gives the example chain of a terminal module chained with a Datakit network module to achieve remote login over a network. Aside from characters (bytes) going from program to device and vice versa, Streams could carry control messages such as \"hangup\" (drop connection) and ioctl messages. Streams could also be used for inter-process communication, by connecting two processes to pseudoterminals. This functionality was implemented in the mpx window system for the Blit graphics terminal, which could display multiple terminal emulator windows. Each window was a process that communicated with the window system through a pseudoterminal that had the line discipline driver installed, sending typed characters to it and receiving text (and graphics) to display. Control signals designated the user's wish to switch between windows or close them. The actual Streams modules live in kernel space on Unix, and are installed (pushed) and removed (popped) by the ioctl system call. For example, to install the aforementioned line discipline on a file descriptor `fd` referring to a terminal device, one would write (in C): ioctl(fd, PUSH, TTYLD); To perform input/output on a stream, one either uses the `read` and `write` system calls as with regular file descriptors, or a set of STREAMS-specific functions to send control messages.See: , and . Ritchie admitted to regretting having to implement Streams in the kernel, rather than as processes, but felt compelled to do so for reasons of efficiency. A later Plan 9 implementation did implement modules as user-level processes. == Implementations == STREAMS has mostly been used in the System V Unix world; however, other implementations exist: * Plan 9 originally used a multi-processor variant of Research Unix's Streams. During the transition to the third edition of Plan 9, Streams were further simplified to simple I/O queues. * An implementation written at Mentat was used in Novell NetWare for its TCP/IP stack, and licensed by Apple for use in the classic Mac OS starting in version 7.5.2, as part of the Open Transport networking system. (In macOS, the Classic Environment used the STREAMS architecture, but the native networking architecture uses the Berkeley sockets API and is derived from the BSD networking code.) * FreeBSD has basic support for STREAMS-related system calls, as required by SVR4 binary compatibility layer. * The Windows NT kernel offered a full port of STREAMS as the streams.sys binary. NT DDK even had a chapter on STREAMS, going as late as NT4 though in NT4 DDK it was declared obsolete. The original TCP/IP stack for Windows NT 3.1 was implemented atop STREAMS by Spider Systems, and used the streams.sys binary. From NT 3.5 up, TCP/IP was remade completely, by adopting the one from Microsoft LAN Manager for OS/2 1.x. Linux does not include STREAMS functionality without third-party add-ons. Caldera had \"pushed\" for STREAMS to be included in Linux ca. 1998, to support its Netware for Linux, but it was rejected outright by the Linux kernel developers on technical grounds (mainly performance). The compatibility layers in Linux for other operating systems convert STREAMS operations into sockets as early as possible.Alan Cox, Streams and Linux, Linux Kernel Mailing List, 28 June 1998 The implementation used by Caldera was \"LiS\", by a company called GCOM; it later figured in the legal battles by Caldera's successor, the SCO Group, against Linux, with SCO claiming that Linux with STREAMS infringed what it believed to be its copyrights to System V. == Notes == == References == * * * * * * * * * * * * * * == External links == * The original stream(4) manual from Unix 8th Edition * The STREAMS framework in Digital UNIX from the Digital UNIX Network Programmer's Guide * Sun STREAMS Programming Guide Category:Computer networking Category:Inter-process communication Category:UNIX System V Category:Unix ",
    "title": "STREAMS"
}