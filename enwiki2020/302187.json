{
    "id": "302187",
    "text": "Curry is an experimental functional logic programming language, based on the Haskell language. It merges elements of functional and logic programming, including constraint programming integration. It is nearly a superset of Haskell, lacking support mostly for overloading using type classes, which some implementations provide anyway as a language extension, such as the M\u00fcnster Curry Compiler.The M\u00fcnster Curry Compiler ==Foundations of functional logic programming== ===Basic concepts=== A functional program is a set of functions defined by equations or rules. A functional computation consists of replacing subexpressions by equal (with regard to the function definitions) subexpressions until no more replacements (or reductions) are possible and a value or normal form is obtained. For instance, consider the function double defined by double x = x+x The expression \u201c\u201d is replaced by . The latter can be replaced by if we interpret the operator \u201c\u201d to be defined by an infinite set of equations, e.g., , , etc. In a similar way, one can evaluate nested expressions (where the subexpressions to be replaced are quoted): 'double (1+2)' \u2192 '(1+2)'+(1+2) \u2192 3+'(1+2)' \u2192 '3+3' \u2192 6 There is also another order of evaluation if we replace the arguments of operators from right to left: 'double (1+2)' \u2192 (1+2)+'(1+2)' \u2192 '(1+2)'+3 \u2192 '3+3' \u2192 6 In this case, both derivations lead to the same result, a property known as confluence. This follows from a fundamental property of pure functional languages, termed referential transparency: the value of a computed result does not depend on the order or time of evaluation, due to the absence of side effects. This simplifies the reasoning about and maintenance of pure functional programs. As many functional languages like Haskell do, Curry supports the definition of algebraic data types by enumerating their constructors. For instance, the type of Boolean values consists of the constructors and that are declared as follows: data Bool = True | False Functions on Booleans can be defined by pattern matching, i.e., by providing several equations for different argument values: not True = False not False = True The principle of replacing equals by equals is still valid provided that the actual arguments have the required form, e.g.: not '(not False)' \u2192 'not True' \u2192 False More complex data structures can be obtained by recursive data types. For instance, a list of elements, where the type of elements is arbitrary (denoted by the type variable ), is either the empty list \u201c\u201d or the non-empty list \u201c\u201d consisting of a first element and a list : data List a = [] | a : List a The type \u201c\u201d is usually written as and finite lists x1x2...xn are written as x1x2...xn. We can define operations on recursive types by inductive definitions where pattern matching supports the convenient separation of the different cases. For instance, the concatenation operation \u201c\u201d on polymorphic lists can be defined as follows (the optional type declaration in the first line specifies that \u201c\u201d takes two lists as input and produces an output list, where all list elements are of the same unspecified type): (++) :: [a] -> [a] -> [a] [] ++ ys = ys (x:xs) ++ ys = x : xs++ys Beyond its application for various programming tasks, the operation \u201c\u201d is also useful to specify the behavior of other functions on lists. For instance, the behavior of a function last that yields the last element of a list can be specified as follows: for all lists xs and elements e, xs = e if \u2203ysyse = xs. Based on this specification, one can define a function that satisfies this specification by employing logic programming features. Similarly to logic languages, functional logic languages provide search for solutions for existentially quantified variables. In contrast to pure logic languages, they support equation solving over nested functional expressions so that an equation like yse = is solved by instantiating ys to the list and e to the value . In Curry one can define the operation last as follows: last xs | ys++[e] =:= xs = e where ys,e free Here, the symbol \u201c\u201d is used for equational constraints in order to provide a syntactic distinction from defining equations. Similarly, extra variables (i.e., variables not occurring in the left-hand side of the defining equation) are explicitly declared by \u201c\u201d in order to provide some opportunities to detect bugs caused by typos. A conditional equation of the form l c r is applicable for reduction if its condition c has been solved. In contrast to purely functional languages where conditions are only evaluated to a Boolean value, functional logic languages support the solving of conditions by guessing values for the unknowns in the condition. Narrowing as discussed in the next section is used to solve this kind of conditions. ===Narrowing=== Narrowing is a mechanism whereby a variable is bound to a value selected from among alternatives imposed by constraints. Each possible value is tried in some order, with the remainder of the program invoked in each case to determine the validity of the binding. Narrowing is an extension of logic programming, in that it performs a similar search, but can actually generate values as part of the search rather than just being limited to testing them. Narrowing is useful because it allows a function to be treated as a relation: its value can be computed \"in both directions\". The Curry examples of the previous section illustrate this. As noted in the previous section, narrowing can be thought of as reduction on a program term graph, and there are often many different ways (strategies) to reduce a given term graph. Antoy et al. proved in the 1990s that a particular narrowing strategy, needed narrowing, is optimal in the sense of doing a number of reductions to get to a \"normal form\" corresponding to a solution that is minimal among sound and complete strategies. Needed narrowing corresponds to a lazy strategy, in contrast to the SLD-resolution strategy of Prolog. ===Functional patterns=== The rule defining shown above expresses the fact that the actual argument must match the result of narrowing the expression . Curry can express this property also in the following more concise way: last (ys++[e]) = e Haskell does not allow such a declaration since the pattern in the left-hand side contains a defined function (). Such a pattern is also called functional pattern. Functional patterns are enabled by the combined functional and logic features of Curry and support concise definitions of tasks requiring deep pattern matching in hierarchical data structures. ===Non-determinism=== Since Curry is able to solve equations containing function calls with unknown values, its execution mechanism is based on non-deterministic computations, similarly to logic programming. This mechanism supports also the definition of non-deterministic operations, i.e., operations that delivers more than one result for a given input. The archetype of non-deterministic operations is the predefined infix operation , called choice operator, that returns one of its arguments. This operator is defined by the following rules: x ? y = x x ? y = y Thus, the evaluation of the expression returns as well as . Computing with non-deterministic operations and computing with free variables by narrowing has the same expressive power. The rules defining show an important feature of Curry: all rules are tried in order to evaluate some operation. Hence, one can define by insert x ys = x : ys insert x (y:ys) = y : insert x ys an operation to insert an element into a list at an indeterminate position so that the operation defined by perm [] = [] perm (x:xs) = insert x (perm xs) returns any permutation of a given input list. ===Strategies=== Due to the absence of side effects, a functional logic program can be executed with different strategies. To evaluate expressions, Curry uses a variant of the needed narrowing strategy which combines lazy evaluation with non-deterministic search strategies. In contrast to Prolog, which uses backtracking to search for solutions, Curry does not fix a particular search strategy. Hence, there are implementations of Curry, like KiCS2, where the user can easily select a search strategy, like depth-first search (backtracking), breadth-first search, iterative deepening, or parallel search. ==References== ==External links== *Curry - The home page of Curry *Smap - A web-based execution environment for Curry and Haskell with various example programs *MCC - The M\u00fcnster Curry Compiler, which uses C as the target *PAKCS A major Curry implementation with a WWW interface, which uses Prolog as the target *KiCS2 A Curry implementation, which uses Haskell as the target *Curry Mailing List *Michael Hanus's home page * Purely Functional Lazy Non- deterministic Programming (Fischer, Kiselyov, Shan, 2009), Transforming Functional Logic Programs into Monadic Functional Programs (Bra\u00dfel, Fischer, Hanus, Reck, 2010) on modeling lazy non-deterministic (logic) programming (like in Curry) in a purely functional language (Haskell); such approach might give the programmer more flexibility in the control over the strategies that\u2014in the case of Curry\u2014are built-in. Category:Concurrent programming languages Category:Experimental programming languages Category:Functional logic programming languages Category:Haskell programming language family Category:Programming languages created in the 1990s Category:Nondeterministic programming languages Category:Literate programming Category:Academic programming languages ",
    "title": "Curry (programming language)"
}