{
    "id": "827635",
    "text": "In computer science, learning vector quantization (LVQ), is a prototype-based supervised classification algorithm. LVQ is the supervised counterpart of vector quantization systems. == Overview == LVQ can be understood as a special case of an artificial neural network, more precisely, it applies a winner- take-all Hebbian learning-based approach. It is a precursor to self-organizing maps (SOM) and related to neural gas, and to the k-nearest neighbor algorithm (k-NN). LVQ was invented by Teuvo Kohonen.T. Kohonen. Self-Organizing Maps. Springer, Berlin, 1997. An LVQ system is represented by prototypes W=(w(i),...,w(n)) which are defined in the feature space of observed data. In winner-take-all training algorithms one determines, for each data point, the prototype which is closest to the input according to a given distance measure. The position of this so-called winner prototype is then adapted, i.e. the winner is moved closer if it correctly classifies the data point or moved away if it classifies the data point incorrectly. An advantage of LVQ is that it creates prototypes that are easy to interpret for experts in the respective application domain. LVQ systems can be applied to multi-class classification problems in a natural way. It is used in a variety of practical applications. See the 'Bibliography on the Self-Organizing Map (SOM) and Learning Vector Quantization (LVQ)'. A key issue in LVQ is the choice of an appropriate measure of distance or similarity for training and classification. Recently, techniques have been developed which adapt a parameterized distance measure in the course of training the system, see e.g. (Schneider, Biehl, and Hammer, 2009) and references therein. LVQ can be a source of great help in classifying text documents. ==Algorithm== Below follows an informal description. The algorithm consists of three basic steps. The algorithm's input is: * how many neurons the system will have M (in the simplest case it is equal to the number of classes) * what weight each neuron has \\vec{w_i} for i = 0,1,...,M - 1 * the corresponding label c_i to each neuron \\vec{w_i} * how fast the neurons are learning \\eta * and an input list L containing all the vectors of which the labels are known already (training set). The algorithm's flow is: # For next input \\vec{x} (with label y) in L find the closest neuron \\vec{w_m}, i.e. d(\\vec{x},\\vec{w_m}) = \\min\\limits_i {d(\\vec{x},\\vec{w_i})} , where \\, d is the metric used ( Euclidean, etc. ). # Update \\vec{w_m}. A better explanation is get \\vec{w_m} closer to the input \\vec{x}, if \\vec{x} and \\vec{w_m} belong to the same label and get them further apart if they don't. \\vec{w_m} \\gets \\vec{w_m} + \\eta \\cdot \\left( \\vec{x} - \\vec{w_m} \\right) if c_m = y (closer together) or \\vec{w_m} \\gets \\vec{w_m} - \\eta \\cdot \\left( \\vec{x} - \\vec{w_m} \\right) if c_m eq y (further apart). # While there are vectors left in L go to step 1, else terminate. Note: \\vec{w_i} and \\vec{x} are vectors in feature space. A more formal description can be found here: http://jsalatas.ictpro.gr/implementation-of-competitive-learning-networks-for- weka/ == References == == Further reading == * Self-Organizing Maps and Learning Vector Quantization for Feature Sequences, Somervuo and Kohonen. 2004 (pdf) == External links == * LVQ for WEKA: Implementation of LVQ variants (LVQ1, OLVQ1, LVQ2.1, LVQ3, OLVQ3) for the WEKA Machine Learning Workbench. * lvq_pak official release (1996) by Kohonen and his team * LVQ for WEKA: Another implementation of LVQ in Java for the WEKA Machine Learning Workbench. * GMLVQ toolbox: An easy-to-use implementation of Generalized Matrix LVQ (matrix relevance learning) in (c) matlab Category:Artificial neural networks Category:Classification algorithms ",
    "title": "Learning vector quantization"
}