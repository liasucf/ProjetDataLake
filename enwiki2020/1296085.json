{
    "id": "1296085",
    "text": "A virtual finite state machine (VFSM) is a finite state machine (FSM) defined in a Virtual Environment. The VFSM concept provides a software specification method to describe the behaviour of a control system using assigned names of input control properties and of output actions. The VFSM method introduces an execution model and facilitates the idea of an executable specification. This technology is mainly used in complex machine control, instrumentation and telecommunication applications. == Why == The major problem by implementing of a state machine is the generation of logical conditions (State transition conditions and Action conditions). In the hardware environment, where state machines have found their original use, this problem does not exist: all signals are Boolean. In contrary the state machines specified and implemented in the software require logical conditions that are per se multivalued ones. Examples: \\- Temperature can be at least Low , OK, High \\- Commands may have several values: Init, Start, Stop, Break, Continue \\- In a (hierarchical) system of state machines the Slaves state machines have many states that are used in conditions of a Master state machine. In addition many input signals can be not known due for instance to a broken cable which means that even a digital input signals (considered as classical Boolean values) are in fact 3 values signals: Low, High, Unknown. The Temperature example needs probably also the value Unknown. A Positive Logical Algebra solves this problem by creating a Virtual Environment which allows specification of state machines for software using multivalued variables. == Control Properties == A variable in the VFSM environment may have one or more values which are relevant for the control - in such a case it is an input variable. Those values are the control properties of this variable. Control properties are not necessarily specific data values but are rather certain states of the variable. For instance, a digital variable could provide three control properties: TRUE, FALSE and UNKNOWN according to its possible boolean values. A numerical (analog) input variable has control properties such as: LOW, HIGH, OK, BAD, UNKNOWN according to its range of desired values. A timer can have its OVER state (time-out occurred) as its most significant control value; other values could be STOPPED, RUNNING etc... == Actions == A variable in the VFSM environment may be activated by actions - in such a case it is an output variable. For instance, a digital output has two actions: True and False. A numerical (analog) output variable has an action: Set. A timer which is both: an input and output variable can be triggered by actions like: Start, Stop or Reset. == Virtual Environment == The virtual environment characterises the environment in which a VFSM operates. It is defined by three sets of names: *input names represent the control properties of all available variables *output names represent the available actions on the variables *state names, as defined for each of the states of the FSM. The input names build virtual conditions to perform state transitions or input actions. The virtual conditions are built using the positive logic algebra. The output names trigger actions (entry actions, exit actions, input actions or transition actions). Figure 1: VFSM in the Virtual Environment A virtual finite state machine is a finite state machine (FSM) defined in a virtual environment. The VFSM concept provides a software specification method to describe the behaviour of a control system using assigned names of input control properties and of output actions. The VFSM method introduces an execution model and facilitates the idea of an executable specification. This technology is mainly used in complex machine control, instrumentation and telecommunication applications. == Positive Logic Algebra == The rules to build a virtual condition are as follows: === Input Names and Virtual Input === A state of an input is described by Input Names which create a set. For instance: \\- for the input A: Anames = {A1, A2, A3} \\- for the input B: Bnames = {B1, B2} \\- for the input C: Cnames = {C1, C2, C3, C4, C5} etc. Virtual Input VI is a set of mutually exclusive elements of input names. A VI contains always the element always. Examples: VI = {always} VI = {always, A1} VI = {always, A1, B2, C4} === Logical operations on Input Names === & (AND) operation is a set of input names. For instance A1 & B3 & C2= > {A1, B3, C2} | (OR) operation is a table of sets of input names. For instance A1 | B3 | C2 => \\begin{bmatrix} \\\\{ & A1 & \\\\} \\\\\\ \\\\{ & B3 & \\\\} \\\\\\ \\\\{ & C2 & \\\\} \\\\\\ \\end{bmatrix} ~ (Complement) is a complement of a set of input names. For instance ~A2 = {A1, A3} === Logical expression === A logical expression is an OR-table of AND-sets (corresponds to disjunctive form of a boolean expression). For instance: A1 & B3 | A1 & B2 & C4 | C2 => \\begin{bmatrix} \\\\{ & A1 & B3 & \\\\} \\\\\\ \\\\{ & A1 & B2 & C4 & \\\\} \\\\\\ \\\\{ & C2 & \\\\} \\\\\\ \\end{bmatrix} Logical expressions are used to express any logical function. === Evaluation of a logical expression === The logical value (true, false) of a logical expression is calculated by testing whether any of the AND-sets in the OR- table is a subset of VI. === Output Names and Virtual Output === A state of an output is described by Output Names which create a set. For instance: for an output Xnames = {X1, X2} for an output Ynames = {Y1, Y2, Y3} Virtual output VO is a set of mutually exclusive elements of output names. === Virtual Environment=== The Virtual Name and Virtual Output completed by State Names create a Virtual Environment VE where the behavior is specified. == VFSM Execution Model == Figure 2: VFSM Executor Flow Chart A subset of all defined input names, which can exist only in a certain situation, is called virtual input (VI). For instance temperature can be either \"too low\", \"good\" or \"too high\". Although there are three input names defined, only one of them can exist in a real situation. This one builds the VI. A subset of all defined output names, which can exist only in a certain situation is called virtual output (VO). VO is built by the current action(s) of the VFSM. The behaviour specification is built by a state table which describes all details of all states of the VFSM. The VFSM executor is triggered by VI and the current state of the VFSM. In consideration of the behaviour specification of the current state, the VO is set. Figure 2 shows one possible implementation of a VFSM executor. Based on this implementation a typical behaviour characteristics must be considered. == State Table == :main page: state transition table. A state table defines all details of the behaviour of a state of a VFSM. It consists of three columns: in the first column state names are used, in the second the virtual conditions built out of input names using the positive logic algebra are placed and in the third column the output names appear: {| class=\"wikitable\" |- ! State Name ! Condition(s) ! Actions(s) |- | rowspan=4 valign=\"top\" | Current state || Entry action || Output name(s) |- | Exit action || Output name(s) |- | Virtual condition || Output name(s) |- | ... || ... |- | Next state name || Virtual condition || Output name(s) |- | Next state name || Virtual condition || Output name(s) |- | ... || ... || ... |- |} Read the table as following: the first two lines define the entry and exit actions of the current state. The following lines which do not provide the next state represent the input actions. Finally the lines providing the next state represent the state transition conditions and transition actions. All fields are optional. A pure combinatorial VFSM is possible in case only where input actions are used, but no state transitions are defined. The transition action can be replaced by the proper use of other actions. == Tools == *StateWORKS: an implementation of the VFSM concept *PlayMaker: implements the VFSM concept as a method of \"visual scripting\" the Unity game engine == References == *Wagner, F., \"Modeling Software with Finite State Machines: A Practical Approach\", Rosa Fischer-L\u00f6w Verlag 1994, *Wagner, F., \"The Virtual Finite State Machines: Executable Control Flow Specification\", Auerbach Publications, 2006, *VFSM Executable Specification, CompEuro 1992 Proceedings *State machine misunderstandings, IEE journal \"Computing and Control Engineering\", 1997 *A Modern Real-Time Software Design Tool: Applying Lessons from Leo, IEE journal \"Computing and Control Engineering\", 2003 *Modelling and Building Reliable, Re-usable Software., Engineering of Computer -Based Software 2003 (ECBS'03) Proceedings *Closing the Gap Between Software Modelling and Code, Engineering of Computer -Based Software 2004 (ECBS'04) Proceedings *, Wagner, T., \"VFSMML - XML standard for VFSM\", 2004 *, \"The virtual finite\u2010state machine design and implementation paradigm\", Bell Labs Technical Journal / Volume 2, Issue1, 2002 Category:Models of computation ",
    "title": "Virtual finite-state machine"
}