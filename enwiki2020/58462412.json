{
    "id": "58462412",
    "text": "In computer science, join-based tree algorithms are a class of algorithms for self-balancing binary search trees. This framework aims at designing highly- parallelized algorithms for various balanced binary search trees. The algorithmic framework is based on a single operation join. Under this framework, the join operation captures all balancing criteria of different balancing schemes, and all other functions join have generic implementation across different balancing schemes. The join-based algorithms can be applied to at least four balancing schemes: AVL trees, red-black trees, weight- balanced trees and treaps. The join(L,k,R) operation takes as input two binary balanced trees L and R of the same balancing scheme, and a key k, and outputs a new balanced binary tree t whose in-order traversal is the in-order traversal of L, then k then the in-order traversal of R. In particular, if the trees are search trees, which means that the in-order of the trees maintain a total ordering on keys, it must satisfy the condition that all keys in L are smaller than k and all keys in R are greater than k. ==History== The join operation was first defined by Tarjan on red-black trees, which runs in worst-case logarithmic time. Later Sleator and Tarjan described a join algorithm for splay trees which runs in amortized logarithmic time. Later Adams . extended join to weight-balanced trees and used it for fast set-set functions including union, intersection and set difference. In 1998, Blelloch and Reid-Miller extended join on treaps, and proved the bound of the set functions to be O(m\\log (1+\\frac{n}{m})) for two trees of size m and n(\\ge m), which is optimal in the comparison model. They also brought up parallelism in Adams' algorithm by using a divide-and-conquer scheme. In 2016, Blelloch et al. formally proposed the join-based algorithms, and formalized the join algorithm for four different balancing schemes: AVL trees, red-black trees, weight-balanced trees and treaps. In the same work they proved that Adams' algorithms on union, intersection and difference are work-optimal on all the four balancing schemes. ==Join algorithms== The function join(t_1,k,t_2) considers rebalancing the tree, and thus depends on the input balancing scheme. If the two trees are balanced, join simply creates a new node with left subtree , root and right subtree . Suppose that is heavier (this \"heavier\" depends on the balancing scheme) than (the other case is symmetric). Join follows the right spine of until a node which is balanced with . At this point a new node with left child , root and right child is created to replace c. The new node may invalidate the balancing invariant. This can be fixed with rotations. The following is the join algorithms on different balancing schemes. The join algorithm for AVL trees: function joinRightAVL(TL, k, TR) (l, k', c) = expose(TL) if (h(c) <= h(TR) + 1) T'=Node(c, k, TR) if (h(T') <= h(l) + 1) then return Node(l, k', T') else return rotateLeft(Node(l, k', rotateRight(T'))) else T' = joinRightAVL(c, k, TR) T = Node(l, k', T') if (h(T') <= h(l) + 1) return T'' else return rotateLeft(T) function joinLeftAVL(TL, k, TR) /* symmetric to joinRightAVL */ function join(TL, k, TR) if (h(TL) > h(TR) + 1) return joinRightAVL(TL, k, TR) if (h(TR) > h(TL) + 1) return joinLeftAVL(TL, k, TR) return Node(TL, k, TR) Here h(v) of a node v the height of v. expose(v)=(l,k,r) means to extract a tree node v's left child l, the key of the node k, and the right child r. Node(l,k,r) means to create a node of left child l, key k, and right child r. The join algorithm for red- black trees: function joinRightRB(TL, k, TR) if r(TL) = \u230ar(TL)/2\u230b \u00d7 2: return Node(TL, \u27e8k, red\u27e9, TR) else (L', \u27e8k', c'\u27e9, R') = expose(TL) T' = Node(L', \u27e8k', c'\u27e9, joinRightRB(R', k, TR) if (c' = black) and (T'.right.color = T'.right.right.color = red): T'.right.right.color = black return rotateLeft(T') else return T' function joinLeftRB(TL, k, TR) /* symmetric to joinRightRB */ function join(TL, k, TR) if \u230ar(TL)/2\u230b > \u230ar(TR)/2\u230b \u00d7 2: T' = joinRightRB(TL, k, TR) if (T'.color = red) and (T'.right.color = red): T'.color = black return T' else if \u230ar(TL)/2\u230b > \u230ar(TL)/2\u230b \u00d7 2 /* symmetric */ else if (TL.color = black) and (TR = black) Node(TL, \u27e8k, red\u27e9, TR) else Node(TL, \u27e8k, black\u27e9, TR) Here r(v) of a node v means twice the black height of a black node, and the twice the black height of a red node. expose(v)=(l,\u27e8k,c\u27e9,r) means to extract a tree node v's left child l, the key of the node k, the color of the node c and the right child r. Node(l,\u27e8k,c\u27e9,r) means to create a node of left child l, key k, color c and right child r. The join algorithm for weight-balanced trees: function joinRightWB(TL, k, TR) (l, k', c)=expose(TL) if balance(|TL|, |TL|) return Node(TL,k,TR) else T' = joinRightWB(c, k, TR) (l1, k1, r1) = expose(T') if (balance(l, T')) return Node(l, k', T') else if (balance(|l|, |l1|) and balance(|l|+|l1|, |r1|)) return rotateLeft(Node(l, k', T')) else return rotateLeft(Node(l, k', rotateRight(T')) function joinLeftWB(TL, k, TR) /* symmetric to joinRightWB */ function join(TL, k, TR) if (heavy(TL, TR)) return joinRightWB(TL, k, TR) if (heavy(TR, TL)) return joinLeftWB(TL, k, TR) Node(TL, k, TR) Here balance(x,y) means two weights x and y are balanced. expose(v)=(l,k,r) means to extract a tree node v's left child l, the key of the node k and the right child r. Node(l,k,r) means to create a node of left child l, key k and right child r. ==Join-based algorithms== In the following, expose(v)=(l,k,r) means to extract a tree node v's left child l, the key of the node k and the right child r. Node(l,k,r) means to create a node of left child l, key k and right child r. right(v) and left(v) extracts the right child and the left child of a tree nodev, respectively. k(v) extract the key of a node v. Many of the join-based algorithms are parallel. \"s_1 || s_2\" means that two statements s_1 and s_2 can run in parallel. ===Split=== To split a tree into two trees, those smaller than key x, and those larger than key x, we first draw a path from the root by inserting x into the tree. After this insertion, all values less than x will be found on the left of the path, and all values greater than x will be found on the right. By applying Join, all the subtrees on the left side are merged bottom-up using keys on the path as intermediate nodes from bottom to top to form the left tree, and the right part is asymmetric. For some applications, Split also returns a boolean value denoting if x appears in the tree. The cost of Split is O(\\log n), order of the height of the tree. The split algorithm is as follows: function split(T,k) if (T=nil) return (nil,false,nil) (L,m,R)=expose(T) if (k=m) return (L,true,R) if (km) (L',b,R')=split(R,k) return (join(L,m,L'),b,R')) ===Join2=== This function is defined similarly as join but without the middle key. It first splits out the last key k of the left tree, and then join the rest part of the left tree with the right tree with k. The algorithm is as follows: function splitLast(T) (L,k,R)=expose(T) if (R=nil) return (L,k) (T',k')=splitLast(R) return (join(L,k,T'),k') function join2(L,R) if (L=nil) return R (L',k)=splitLast(L) return join(L',k,R) The cost is O(\\log n) for a tree of size n. ===Insert and delete=== The insertion and deletion algorithms, when making use of join can be independent of balancing schemes. For an insertion, the algorithm compares the key to be inserted with the key in the root, inserts it to the left/right subtree if the key is smaller/greater than the key in the root, and joins the two subtrees back with the root. A deletion compares the key to be deleted with the key in the root. If they are equal, return join2 on the two subtrees. Otherwise, delete the key from the corresponding subtree, and join the two subtrees back with the root. The algorithms are as follows: function insert(T,k) if (T=nil) return Node(nil,k,nil) (L,k',R)=expose(T) if (kk') return join(L,k',insert(R,k)) return T function delete(T,k) if (T=nil) return nil (L,k',R)=expose(T) if (kk') return join(L,k',delete(R,k)) return join2(L,R) Both insertion and deletion requires O(\\log n) time if |T|=n. ===Set\u2013set functions=== Several set operations have been defined on weight-balanced trees: union, intersection and set difference. The union of two weight- balanced trees and representing sets and , is a tree that represents . The following recursive function computes this union: function union(t1, t2): if t1 = nil: return t2 if t2 = nil: return t1 (t<, b, t>) = split t2 on t1.root nl = union(left(t1), t<) || nr = union(right(t1), t>) return join(nl, t1.root, nr) Similarly, the algorithms of intersection and set-difference are as follows: function intersection(t1, t2): if (t1 = nil or t2 = nil) return nil (t<, b, t>) = split t2 on t1.root nl = intersection(left(t1), t<) || nr = intersection(right(t1), t>) if (b) return join(nl, t1.root, nr) else return join2(nl, nr) function difference(t1, t2): if (t1 = nil) return nil if (t2 = nil) return t1 (t<, b, t>) = split t2 on t1.root nl = difference(left(t1), t<) || nr = difference(right(t1), t>) return join2(nl, nr) The complexity of each of union, intersection and difference is O\\left(m \\log \\left({n\\over m}+1\\right)\\right) for two weight-balanced trees of sizes m and n(\\ge m). This complexity is optimal in terms of the number of comparisons. More importantly, since the recursive calls to union, intersection or difference are independent of each other, they can be executed in parallel with a parallel depth O(\\log m\\log n). When m=1, the join-based implementation applies the same computation as in a single-element insertion or deletion if the root of the larger tree is used to split the smaller tree. ===Build=== The algorithm for building a tree can make use of the union algorithm, and use the divide-and-conquer scheme: function build(A[], n): if (n=0) return nil if (n=1) return Node(nil,A[0],nil) L = build(A,n/2) || R = (A+n/2, n-n/2) return union(L,R) This algorithm costs O(n\\log n) work and has O(\\log^3 n) depth. A more-efficient algorithm makes use of a parallel sorting algorithm. function buildSorted(A[], n): if (n=0) return nil if (n=1) return Node(nil,A[0],nil) L = build(A,n/2) || R = (A+n/2+1, n-n/2-1) return join(L,A[n/2],R) function build(A[], n): A'=sort(A,n) return buildSorted(A,n) This algorithm costs O(n\\log n) work and has O(\\log n) depth assuming the sorting algorithm has O(n\\log n) work and O(\\log n) depth. ===Filter=== This function selects all entries in a tree satisfying an indicator f, and return a tree containing all selected entries. It recursively filters the two subtrees, and join them with the root if the root satisfies f, otherwise join2 the two subtrees. function filter(T,f): if (T=nil) return nil L = filter(left(T),f) || R = (right(T),f) if (f(k(T)) return join(L,k(T),R) else return join2(L,R) This algorithm costs work O(n) and depth O(\\log n) on a tree of size n, assuming f has constant cost. ==Used in libraries== The join-based algorithms are applied to support interface for sets, maps, and augmented maps in libarays such as Hackage, SML/NJ, and PAM. ==Notes== ==References== == External links == * PAM, the parallel augmented map library. * Hackage, Containers in Hackage Category:Algorithms and data structures Category:Algorithms Category:Data structures ",
    "title": "Join-based tree algorithms"
}