{
    "id": "44578",
    "text": "300px|thumb|Example of Big O notation: \u2208 O() as there exists c > 0 (e.g., c = 1) and x0 (e.g., x0 = 5) such that \u2264 c whenever x \u2265 x0. Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. Big O is a member of a family of notations invented by Paul Bachmann, Edmund Landau, and others, collectively called Bachmann\u2013Landau notation or asymptotic notation. In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows. In analytic number theory, big O notation is often used to express a bound on the difference between an arithmetical function and a better understood approximation; a famous example of such a difference is the remainder term in the prime number theorem. Big O notation characterizes functions according to their growth rates: different functions with the same growth rate may be represented using the same O notation. The letter O is used because the growth rate of a function is also referred to as the order of the function. A description of a function in terms of big O notation usually only provides an upper bound on the growth rate of the function. Associated with big O notation are several related notations, using the symbols , to describe other kinds of bounds on asymptotic growth rates. Big O notation is also used in many other fields to provide similar estimates. == Formal definition == Let be a real or complex valued function and a real valued function. Let both functions be defined on some unbounded subset of the positive real numbers, and g(x) be strictly positive for all large enough values of . One writes :f(x) = O\\bigl( g(x)\\bigr)\\quad\\text{ as }x\\to\\infty if the absolute value of f(x) is at most a positive constant multiple of g(x) for all sufficiently large values of . That is, f(x) =O\\bigl(g(x)\\bigr) if there exists a positive real number and a real number such that :|f(x)| \\le M g(x) \\quad \\text{ for all } x \\ge x_0. In many contexts, the assumption that we are interested in the growth rate as the variable goes to infinity is left unstated, and one writes more simply that :f(x) = O\\bigl( g(x) \\bigr). The notation can also be used to describe the behavior of near some real number (often, we say :f(x) = O\\bigl( g(x) \\bigr)\\quad\\text{ as }x \\to a if there exist positive numbers \\delta and such that for all with 0 < |x-a| < \\delta, :|f(x)| \\le M g(x). As is chosen to be non-zero for values of sufficiently close to , both of these definitions can be unified using the limit superior: :f(x) = O\\bigl( g(x) \\bigr) \\quad \\text{ as } x \\to a if :\\limsup_{x\\to a} \\frac{\\left|f(x)\\right|}{g(x)} < \\infty. == Example == In typical usage the notation is asymptotical, that is, it refers to very large . In this setting, the contribution of the terms that grow \"most quickly\" will eventually make the other ones irrelevant. As a result, the following simplification rules can be applied: *If is a sum of several terms, if there is one with largest growth rate, it can be kept, and all others omitted. *If is a product of several factors, any constants (terms in the product that do not depend on ) can be omitted. For example, let , and suppose we wish to simplify this function, using notation, to describe its growth rate as approaches infinity. This function is the sum of three terms: , , and . Of these three terms, the one with the highest growth rate is the one with the largest exponent as a function of , namely . Now one may apply the second rule: is a product of and in which the first factor does not depend on . Omitting this factor results in the simplified form . Thus, we say that is a \"big O\" of . Mathematically, we can write . One may confirm this calculation using the formal definition: let and . Applying the formal definition from above, the statement that is equivalent to its expansion, :|f(x)| \\le M x^4 for some suitable choice of and and for all . To prove this, let and . Then, for all : :\\begin{align}|6x^4 - 2x^3 + 5| &\\le 6x^4 + |2x^3| + 5\\\\\\ &\\le 6x^4 + 2x^4 + 5x^4\\\\\\ &= 13x^4\\end{align} so : |6x^4 - 2x^3 + 5| \\le 13 x^4 . == Usage == Big O notation has two main areas of application: * In mathematics, it is commonly used to describe how closely a finite series approximates a given function, especially in the case of a truncated Taylor series or asymptotic expansion * In computer science, it is useful in the analysis of algorithms In both applications, the function appearing within the is typically chosen to be as simple as possible, omitting constant factors and lower order terms. There are two formally close, but noticeably different, usages of this notation: * infinite asymptotics * infinitesimal asymptotics. This distinction is only in application and not in principle, however\u2014the formal definition for the \"big O\" is the same for both cases, only with different limits for the function argument. === Infinite asymptotics === Graphs of functions commonly used in the analysis of algorithms, showing the number of operations versus input size for each function Big O notation is useful when analyzing algorithms for efficiency. For example, the time (or the number of steps) it takes to complete a problem of size might be found to be . As grows large, the term will come to dominate, so that all other terms can be neglected\u2014for instance when , the term is 1000 times as large as the term. Ignoring the latter would have negligible effect on the expression's value for most purposes. Further, the coefficients become irrelevant if we compare to any other order of expression, such as an expression containing a term or . Even if , if , the latter will always exceed the former once grows larger than (). Additionally, the number of steps depends on the details of the machine model on which the algorithm runs, but different types of machines typically vary by only a constant factor in the number of steps needed to execute an algorithm. So the big O notation captures what remains: we write either :T(n)= O(n^2) or :T(n) \\in O(n^2) and say that the algorithm has order of time complexity. The sign \"\" is not meant to express \"is equal to\" in its normal mathematical sense, but rather a more colloquial \"is\", so the second expression is sometimes considered more accurate (see the \"Equals sign\" discussion below) while the first is considered by some as an abuse of notation. === Infinitesimal asymptotics === Big O can also be used to describe the error term in an approximation to a mathematical function. The most significant terms are written explicitly, and then the least-significant terms are summarized in a single big O term. Consider, for example, the exponential series and two expressions of it that are valid when is small: :\\begin{align} e^x &=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\frac{x^4}{4!}+\\dotsb &\\text{for all } x\\\\\\ &=1+x+\\frac{x^2}{2}+O(x^3) &\\text{as } x\\to 0\\\\\\ &=1+x+O(x^2) &\\text{as } x\\to 0\\\\\\ \\end{align} The second expression (the one with O(x3)) means the absolute-value of the error ex \u2212 (1 + x + x2/2) is at most some constant times x3 when x is close enough to 0\\. == Properties == If the function can be written as a finite sum of other functions, then the fastest growing one determines the order of . For example, :f(n) = 9 \\log n + 5 (\\log n)^4 + 3n^2 + 2n^3 = O(n^3) \\qquad\\text{as } n\\to\\infty . In particular, if a function may be bounded by a polynomial in , then as tends to infinity, one may disregard lower-order terms of the polynomial. The sets and are very different. If is greater than one, then the latter grows much faster. A function that grows faster than for any is called superpolynomial. One that grows more slowly than any exponential function of the form is called subexponential. An algorithm can require time that is both superpolynomial and subexponential; examples of this include the fastest known algorithms for integer factorization and the function . We may ignore any powers of inside of the logarithms. The set is exactly the same as . The logarithms differ only by a constant factor (since ) and thus the big O notation ignores that. Similarly, logs with different constant bases are equivalent. On the other hand, exponentials with different bases are not of the same order. For example, and are not of the same order. Changing units may or may not affect the order of the resulting algorithm. Changing units is equivalent to multiplying the appropriate variable by a constant wherever it appears. For example, if an algorithm runs in the order of , replacing by means the algorithm runs in the order of , and the big O notation ignores the constant . This can be written as . If, however, an algorithm runs in the order of , replacing with gives . This is not equivalent to in general. Changing variables may also affect the order of the resulting algorithm. For example, if an algorithm's run time is when measured in terms of the number of digits of an input number , then its run time is when measured as a function of the input number itself, because . === Product === : f_1 = O(g_1) \\text{ and } f_2 = O(g_2) \\Rightarrow f_1 f_2 = O(g_1 g_2) :f\\cdot O(g) = O(f g) === Sum === : f_1 = O(g_1) \\text{ and } f_2= O(g_2) \\Rightarrow f_1 + f_2 = O(\\max(g_1, g_2)) This implies f_1 = O(g) \\text{ and } f_2 = O(g) \\Rightarrow f_1+f_2 \\in O(g) , which means that O(g) is a convex cone. === Multiplication by a constant === :Let be constant. Then: :O(|k| g) = O(g) if is nonzero. :f = O(g) \\Rightarrow kf = O(g). == Multiple variables == Big O (and little o, \u03a9, etc.) can also be used with multiple variables. To define big O formally for multiple variables, suppose f and g are two functions defined on some subset of \\mathbb{R}^n. We say :f(\\vec{x})\\text{ is }O(g(\\vec{x}))\\quad\\text{ as }\\vec{x}\\to\\infty if and only if :\\exists M \\exists C > 0~\\text{ such that for all }~\\vec{x}~\\text{ with }~x_i \\ge M~\\text{ for some }~i, |f(\\vec{x})| \\le C |g(\\vec{x})|~. Equivalently, the condition that x_i \\geq M for some i can be replaced with the condition that \\|\\vec{x}\\|_{\\infty} \\ge M, where \\|\\vec{x}\\|_{\\infty} denotes the Chebyshev norm. For example, the statement :f(n,m) = n^2 + m^3 + O(n+m) \\quad\\text{ as } n,m\\to\\infty asserts that there exist constants C and M such that :\\forall \\|(n, m)\\|_{\\infty} \\geq M: \\quad |g(n,m)| \\le C |n+m|~ where g(n,m) is defined by :f(n,m) = n^2 + m^3 + g(n,m)~. This definition allows all of the coordinates of ~\\vec{x}~ to increase to infinity. In particular, the statement :f(n,m) = O(n^m) \\quad \\text{ as } n,m\\to\\infty~ (i.e., \\exists C \\exists M \\forall n \\forall m\\dots) is quite different from :\\forall m\\colon~f(n,m) = O(n^m) \\quad\\text{ as } n\\to\\infty (i.e., \\forall m \\exists C \\exists M \\forall n \\dots). Under this definition, the subset on which a function is defined is significant when generalizing statements from the univariate setting to the multivariate setting. For example, if ~f(n,m)=1~ and ~g(n,m)=n~, then ~f(n,m) = O(g(n,m))~ if we restrict f and g to ~[1,\\infty)^2~, but not if they are defined on [0,\\infty)^2~. This is not the only generalization of big O to multivariate functions, and in practice, there is some inconsistency in the choice of definition. == Matters of notation == === Equals sign === The statement \"f(x) is O(g(x))\" as defined above is usually written as f(x) = O(g(x)). Some consider this to be an abuse of notation, since the use of the equals sign could be misleading as it suggests a symmetry that this statement does not have. As de Bruijn says, O(x) = O(x2) is true but O(x2) = O(x) is not. Knuth describes such statements as \"one-way equalities\", since if the sides could be reversed, \"we could deduce ridiculous things like n = n2 from the identities n = O(n2) and n2 = O(n2).\" For these reasons, it would be more precise to use set notation and write f(x) \u2208 O(g(x)), thinking of O(g(x)) as the class of all functions h(x) such that |h(x)| \u2264 C|g(x)| for some constant C. However, the use of the equals sign is customary. Knuth pointed out that \"mathematicians customarily use the = sign as they use the word 'is' in English: Aristotle is a man, but a man isn't necessarily Aristotle.\" (Unabridged version) === Other arithmetic operators === Big O notation can also be used in conjunction with other arithmetic operators in more complicated equations. For example, h(x) + O(f(x)) denotes the collection of functions having the growth of h(x) plus a part whose growth is limited to that of f(x). Thus, :g(x) = h(x) + O(f(x)) expresses the same as :g(x) - h(x) = O(f(x)). ==== Example ==== Suppose an algorithm is being developed to operate on a set of n elements. Its developers are interested in finding a function T(n) that will express how long the algorithm will take to run (in some arbitrary measurement of time) in terms of the number of elements in the input set. The algorithm works by first calling a subroutine to sort the elements in the set and then perform its own operations. The sort has a known time complexity of O(n2), and after the subroutine runs the algorithm must take an additional 55n3 + 2n + 10 steps before it terminates. Thus the overall time complexity of the algorithm can be expressed as T(n) = 55n3 + O(n2). Here the terms 2n+10 are subsumed within the faster-growing O(n2). Again, this usage disregards some of the formal meaning of the \"=\" symbol, but it does allow one to use the big O notation as a kind of convenient placeholder. === Multiple uses === In more complicated usage, O(...) can appear in different places in an equation, even several times on each side. For example, the following are true for n\\to\\infty :(n+1)^2 = n^2 + O(n) :(n + O(n^{1/2}))(n + O(\\log n))^2 = n^3 + O(n^{5/2}) :n^{O(1)} = O(e^n). The meaning of such statements is as follows: for any functions which satisfy each O(...) on the left side, there are some functions satisfying each O(...) on the right side, such that substituting all these functions into the equation makes the two sides equal. For example, the third equation above means: \"For any function f(n) = O(1), there is some function g(n) = O(en) such that nf(n) = g(n).\" In terms of the \"set notation\" above, the meaning is that the class of functions represented by the left side is a subset of the class of functions represented by the right side. In this use the \"=\" is a formal symbol that unlike the usual use of \"=\" is not a symmetric relation. Thus for example nO(1) = O(en) does not imply the false statement O(en) = nO(1) === Typesetting === Big O consists of just an uppercase \"O\". Unlike Greek-named Bachmann\u2013Landau notations, it needs no special symbol. Yet, commonly used calligraphic variants, like \\mathcal{O}, are available, in LaTeX and derived typesetting systems. == Orders of common functions == Here is a list of classes of functions that are commonly encountered when analyzing the running time of an algorithm. In each case, c is a positive constant and n increases without bound. The slower-growing functions are generally listed first. {| class=\"wikitable\" |- !Notation !! Name !! Example |- |O(1) || constant || Determining if a binary number is even or odd; Calculating (-1)^n; Using a constant-size lookup table |- |O(\\log \\log n) || double logarithmic || Number of comparisons spent finding an item using interpolation search in a sorted array of uniformly distributed values |- |O(\\log n) || logarithmic || Finding an item in a sorted array with a binary search or a balanced search tree as well as all operations in a Binomial heap |- |O((\\log n)^c) \\scriptstyle c>1 || polylogarithmic || Matrix chain ordering can be solved in polylogarithmic time on a parallel random-access machine. |- |O(n^c) \\scriptstyle 0 || fractional power || Searching in a k-d tree |- |O(n) || linear || Finding an item in an unsorted list or in an unsorted array; adding two n-bit integers by ripple carry |- |O(n\\log^* n) || n log-star n || Performing triangulation of a simple polygon using Seidel's algorithm, or the union\u2013find algorithm. Note that \\log^*(n) = \\begin{cases} 0, & \\text{if }n \\leq 1 \\\\\\ 1 + \\log^*(\\log n), & \\text{if }n>1 \\end{cases} |- |O(n\\log n) = O(\\log n!) || linearithmic, loglinear, quasilinear, or \"n log n\" || Performing a fast Fourier transform; Fastest possible comparison sort; heapsort and merge sort |- |O(n^2) || quadratic || Multiplying two n-digit numbers by a simple algorithm; simple sorting algorithms, such as bubble sort, selection sort and insertion sort; (worst case) bound on some usually faster sorting algorithms such as quicksort, Shellsort, and tree sort |- |O(n^c) || polynomial or algebraic || Tree-adjoining grammar parsing; maximum matching for bipartite graphs; finding the determinant with LU decomposition |- |L_n[\\alpha,c] = e^{(c + o(1)) (\\ln n)^\\alpha (\\ln \\ln n)^{1-\\alpha}} \\scriptstyle 0 < \\alpha < 1 || L-notation or sub-exponential || Factoring a number using the quadratic sieve or number field sieve |- |O(c^n) \\scriptstyle c>1 || exponential || Finding the (exact) solution to the travelling salesman problem using dynamic programming; determining if two logical statements are equivalent using brute-force search |- |O(n!) || factorial || Solving the travelling salesman problem via brute-force search; generating all unrestricted permutations of a poset; finding the determinant with Laplace expansion; enumerating all partitions of a set |} The statement f(n) = O(n!) is sometimes weakened to f(n) = O\\left(n^n\\right) to derive simpler formulas for asymptotic complexity. For any k>0 and c > 0, O(n^c(\\log n)^k) is a subset of O(n^{c+\\varepsilon}) for any \\varepsilon > 0, so may be considered as a polynomial with some bigger order. == Related asymptotic notations == Big O is the most commonly used asymptotic notation for comparing functions. Together with some other related notations it forms the family of Bachmann\u2013Landau notations. ===Little-o notation=== Intuitively, the assertion \" is \" (read \" is little-o of \") means that grows much faster than . Let as before f be a real or complex valued function and g a real valued function, both defined on some unbounded subset of the positive real numbers, such that g(x) is strictly positive for all large enough values of x. One writes :f(x) = o(g(x)) \\quad \\text{ as } x \\to \\infty if for every positive constant there exists a constant such that :|f(x)| \\leq \\varepsilon g(x) \\quad \\text{ for all } x \\geq N. For example, one has : 2x = o(x^2) and 1/x = o(1). The difference between the earlier definition for the big-O notation and the present definition of little-o, is that while the former has to be true for at least one constant M, the latter must hold for every positive constant , however small.Thomas H. Cormen et al., 2001, Introduction to Algorithms, Second Edition In this way, little-o notation makes a stronger statement than the corresponding big-O notation: every function that is little-o of g is also big-O of g, but not every function that is big-O of g is also little-o of g. For example, 2x^2 = O(x^2) but 2x^2 eq o(x^2). As g(x) is nonzero, or at least becomes nonzero beyond a certain point, the relation f(x) = o(g(x)) is equivalent to :\\lim_{x \\to \\infty}\\frac{f(x)}{g(x)} = 0 (and this is in fact how Landau originally defined the little-o notation). Little-o respects a number of arithmetic operations. For example, : if is a nonzero constant and f = o(g) then c \\cdot f = o(g), and : if f = o(F) and g = o(G) then f \\cdot g = o(F \\cdot G). It also satisfies a transitivity relation: : if f = o(g) and g = o(h) then f = o(h). === Big Omega notation === Another asymptotic notation is \\Omega, read \"big Omega\". Unfortunately, there are two widespread and incompatible definitions of the statement :f(x)=\\Omega(g(x)) as x\\rightarrow a,, where a is some real number, \u221e, or \u2212\u221e, where f and g are real functions defined in a neighbourhood of a, and where g is positive in this neighbourhood. The first one (chronologically) is used in analytic number theory, and the other one in computational complexity theory. When the two subjects meet, this situation is bound to generate confusion. ==== The Hardy\u2013Littlewood definition ==== In 1914 Godfrey Harold Hardy and John Edensor Littlewood introduced the new symbol \\Omega, which is defined as follows: :f(x) = \\Omega(g(x)) as x\\rightarrow\\infty if \\limsup_{x \\to \\infty} \\left|\\frac{f(x)}{g(x)}\\right| > 0. Thus f(x)=\\Omega(g(x)) is the negation of f(x)=o(g(x)). In 1916 the same authors introduced the two new symbols \\Omega_R and \\Omega_L, defined as:G. H. Hardy and J. E. Littlewood, \u00ab Contribution to the theory of the Riemann zeta-function and the theory of the distribution of primes \u00bb, Acta Mathematica, vol. 41, 1916. :f(x)=\\Omega_R(g(x)) as x\\rightarrow\\infty if \\limsup_{x \\to \\infty} \\frac{f(x)}{g(x)}> 0; :f(x)=\\Omega_L(g(x)) as x\\rightarrow\\infty if \\liminf_{x \\to \\infty} \\frac{f(x)}{g(x)}< 0\\. These symbols were used by Edmund Landau, with the same meanings, in 1924.E. Landau, \"\u00dcber die Anzahl der Gitterpunkte in gewissen Bereichen. IV.\" Nachr. Gesell. Wiss. G\u00f6tt. Math-phys. Kl. 1924, 137\u2013150. After Landau, the notations were never used again exactly thus; \\Omega_R became \\Omega_+ and \\Omega_L became \\Omega_-. These three symbols \\Omega, \\Omega_+, \\Omega_-, as well as f(x)=\\Omega_\\pm(g(x)) (meaning that f(x)=\\Omega_+(g(x)) and f(x)=\\Omega_-(g(x)) are both satisfied), are now currently used in analytic number theory.Aleksandar Ivi\u0107. The Riemann zeta- function, chapter 9. John Wiley & Sons 1985.G\u00e9rald Tenenbaum, Introduction to analytic and probabilistic number theory, Chapter I.5. American Mathematical Society, Providence RI, 2015. ===== Simple examples ===== We have :\\sin x=\\Omega(1) as x\\rightarrow\\infty, and more precisely :\\sin x=\\Omega_\\pm(1) as x\\rightarrow\\infty. We have :\\sin x+1=\\Omega(1) as x\\rightarrow\\infty, and more precisely :\\sin x+1=\\Omega_+(1) as x\\rightarrow\\infty; however :\\sin x+1 ot=\\Omega_-(1) as x\\rightarrow\\infty. ==== The Knuth definition ==== In 1976 Donald Knuth published a paper to justify his use of the \\Omega-symbol to describe a stronger property. Knuth wrote: \"For all the applications I have seen so far in computer science, a stronger requirement ... is much more appropriate\". He defined :f(x)=\\Omega(g(x))\\Leftrightarrow g(x)=O(f(x)) with the comment: \"Although I have changed Hardy and Littlewood's definition of \\Omega, I feel justified in doing so because their definition is by no means in wide use, and because there are other ways to say what they want to say in the comparatively rare cases when their definition applies.\" === Family of Bachmann\u2013Landau notations === {| class=\"wikitable\" |- ! Notation ! Name ! Description ! Formal Definition ! Limit Definition |- | f(n) = O(g(n)) | Big O; Big Oh; Big Omicron | |f| is bounded above by (up to constant factor) asymptotically | \\exists k > 0 \\exists n_0 \\forall n>n_0\\colon |f(n)| \\leq k\\cdot g(n) | \\limsup_{n \\to \\infty} \\frac{\\left|f(n)\\right|}{g(n)} < \\infty |- | f(n) = \\Theta(g(n)) | Big Theta | is bounded both above and below by asymptotically | \\exists k_1 > 0 \\exists k_2>0 \\exists n_0 \\forall n > n_0\\colon k_1 \\cdot g(n) \\leq f(n) \\leq k_2 \\cdot g(n) | f(n) = O(g(n)) and f(n) = \\Omega(g(n)) (Knuth version) |- | f(n) = \\Omega(g(n)) | Big Omega in complexity theory (Knuth) | is bounded below by asymptotically | \\exists k > 0 \\exists n_0 \\forall n>n_0\\colon f(n) \\geq k\\cdot g(n) | \\liminf_{n \\to \\infty} \\frac{f(n)}{g(n)} > 0 |- style=\"border-top: 2px solid gray;\" | f(n) = o(g(n)) | Small O; Small Oh | is dominated by asymptotically | \\forall k>0 \\exists n_0 \\forall n > n_0\\colon |f(n)| < k\\cdot g(n) | \\lim_{n \\to \\infty} \\frac{\\left|f(n)\\right|}{g(n)} = 0 |- | f(n)\\sim g(n) | On the order of | is equal to asymptotically | \\forall \\varepsilon > 0 \\exists n_0\\forall n > n_0\\colon \\left|{f(n) \\over g(n)} - 1 \\right| < \\varepsilon | \\lim_{n \\to \\infty} {f(n) \\over g(n)} = 1 |- | f(n) = \\omega(g(n)) | Small Omega | dominates asymptotically | \\forall k > 0 \\exists n_0 \\forall n > n_0 \\colon |f(n)| > k\\cdot |g(n)| | \\lim_{n \\to \\infty} \\left|\\frac{f(n)}{g(n)}\\right| = \\infty |- style=\"border-top: 2px solid gray;\" | f(n) = \\Omega(g(n)) | Big Omega in number theory (Hardy\u2013Littlewood) | |f| is not dominated by asymptotically | \\exists k>0 \\forall n_0 \\exists n > n_0\\colon |f(n)| \\geq k\\cdot g(n) | \\limsup_{n \\to \\infty} \\left|\\frac{f(n)}{g(n)}\\right| > 0 |} The limit definitions assume g(n) > 0 for sufficiently large . The table is (partly) sorted from smallest to largest, in the sense that o, O, \u0398, \u223c, (Knuth's version of) \u03a9, \u03c9 on functions correspond to <, \u2264, \u2248, =, \u2265, > on the real line (the Hardy-Littlewood version of \u03a9, however, doesn't correspond to any such description). Computer science uses the big O, big Theta \u0398, little o, little omega \u03c9 and Knuth's big Omega \u03a9 notations. Analytic number theory often uses the big O, small o, Hardy\u2013Littlewood's big Omega \u03a9 (with or without the +, - or \u00b1 subscripts) and \\sim notations. The small omega \u03c9 notation is not used as often in analysis.for example it is omitted in: === Use in computer science === Informally, especially in computer science, the big O notation often can be used somewhat differently to describe an asymptotic tight bound where using big Theta \u0398 notation might be more factually appropriate in a given context. For example, when considering a function T(n) = 73n3 \\+ 22n2 \\+ 58, all of the following are generally acceptable, but tighter bounds (such as numbers 2 and 3 below) are usually strongly preferred over looser bounds (such as number 1 below). #T(n) = O(n100) #T(n) = O(n3) #T(n) = \u0398(n3) The equivalent English statements are respectively: #T(n) grows asymptotically no faster than n100 #T(n) grows asymptotically no faster than n3 #T(n) grows asymptotically as fast as n3. So while all three statements are true, progressively more information is contained in each. In some fields, however, the big O notation (number 2 in the lists above) would be used more commonly than the big Theta notation (items numbered 3 in the lists above). For example, if T(n) represents the running time of a newly developed algorithm for input size n, the inventors and users of the algorithm might be more inclined to put an upper asymptotic bound on how long it will take to run without making an explicit statement about the lower asymptotic bound. === Other notation === In their book Introduction to Algorithms, Cormen, Leiserson, Rivest and Stein consider the set of functions f which satisfy : f(n) = O(g(n))\\quad(n\\rightarrow\\infty)~. In a correct notation this set can, for instance, be called O(g), where :O(g) = \\\\{ f : there exist positive constants c and n_0 such that 0 \\le f(n) \\le c g(n) for all n \\ge n_0 \\\\}. The authors state that the use of equality operator (=) to denote set membership rather than the set membership operator (\u2208) is an abuse of notation, but that doing so has advantages. Inside an equation or inequality, the use of asymptotic notation stands for an anonymous function in the set O(g), which eliminates lower-order terms, and helps to reduce inessential clutter in equations, for example: : 2n^2 + 3n + 1=2n^2 + O(n). === Extensions to the Bachmann\u2013Landau notations === Another notation sometimes used in computer science is \u00d5 (read soft-O): f(n) = \u00d5(g(n)) is shorthand for f(n) = O(g(n) logk g(n)) for some k. Essentially, it is big O notation, ignoring logarithmic factors because the growth-rate effects of some other super-logarithmic function indicate a growth-rate explosion for large-sized input parameters that is more important to predicting bad run-time performance than the finer-point effects contributed by the logarithmic-growth factor(s). This notation is often used to obviate the \"nitpicking\" within growth-rates that are stated as too tightly bounded for the matters at hand (since logk n is always o(n\u03b5) for any constant k and any \u03b5 > 0). Also the L notation, defined as :L_n[\\alpha,c]=e^{(c + o(1))(\\ln n)^\\alpha(\\ln\\ln n)^{1-\\alpha}} is convenient for functions that are between polynomial and exponential in terms of \\ln n. == Generalizations and related usages == The generalization to functions taking values in any normed vector space is straightforward (replacing absolute values by norms), where f and g need not take their values in the same space. A generalization to functions g taking values in any topological group is also possible. The \"limiting process\" x \u2192 xo can also be generalized by introducing an arbitrary filter base, i.e. to directed nets f and g. The o notation can be used to define derivatives and differentiability in quite general spaces, and also (asymptotical) equivalence of functions, : f\\sim g \\iff (f-g) \\in o(g) which is an equivalence relation and a more restrictive notion than the relationship \"f is \u0398(g)\" from above. (It reduces to lim f / g = 1 if f and g are positive real valued functions.) For example, 2x is \u0398(x), but 2x \u2212 x is not o(x). == History (Bachmann\u2013Landau, Hardy, and Vinogradov notations) == The symbol O was first introduced by number theorist Paul Bachmann in 1894, in the second volume of his book Analytische Zahlentheorie (\"analytic number theory\"). The number theorist Edmund Landau adopted it, and was thus inspired to introduce in 1909 the notation o; hence both are now called Landau symbols. These notations were used in applied mathematics during the 1950s for asymptotic analysis. The symbol \\Omega (in the sense \"is not an o of\") was introduced in 1914 by Hardy and Littlewood. Hardy and Littlewood also introduced in 1918 the symbols \\Omega_R (\"right\") and \\Omega_L (\"left\"), precursors of the modern symbols \\Omega_+ (\"is not smaller than a small o of\") and \\Omega_- (\"is not larger than a small o of\"). Thus the Omega symbols (with their original meanings) are sometimes also referred to as \"Landau symbols\". This notation \\Omega became commonly used in number theory at least since the 1950s.E. C. Titchmarsh, The Theory of the Riemann Zeta-Function (Oxford; Clarendon Press, 1951) In the 1970s the big O was popularized in computer science by Donald Knuth, who introduced the related Theta notation, and proposed a different definition for the Omega notation. Landau never used the big Theta and small omega symbols. Hardy's symbols were (in terms of the modern O notation) : f \\preccurlyeq g\\iff f \\in O(g) and f\\prec g\\iff f\\in o(g); (Hardy however never defined or used the notation \\prec\\\\!\\\\!\\prec, nor \\ll, as it has been sometimes reported). Hardy introduced the symbols \\preccurlyeq and \\prec (as well as some other symbols) in his 1910 tract \"Orders of Infinity\", and made use of them only in three papers (1910\u20131913). In his nearly 400 remaining papers and books he consistently used the Landau symbols O and o. Hardy's notation is not used anymore. On the other hand, in the 1930s,See for instance \"A new estimate for G(n) in Waring's problem\" (Russian). Doklady Akademii Nauk SSSR 5, No 5-6 (1934), 249\u2013253. Translated in English in: Selected works / Ivan Matveevi\u010d Vinogradov; prepared by the Steklov Mathematical Institute of the Academy of Sciences of the USSR on the occasion of his 90th birthday. Springer-Verlag, 1985. the Russian number theorist Ivan Matveyevich Vinogradov introduced his notation \\ll, which has been increasingly used in number theory instead of the O notation. We have : f\\ll g \\iff f \\in O(g), and frequently both notations are used in the same paper. The big-O originally stands for \"order of\" (\"Ordnung\", Bachmann 1894), and is thus a Latin letter. Neither Bachmann nor Landau ever call it \"Omicron\". The symbol was much later on (1976) viewed by Knuth as a capital omicron, probably in reference to his definition of the symbol Omega. The digit zero should not be used. == See also == * Asymptotic expansion: Approximation of functions generalizing Taylor's formula * Asymptotically optimal algorithm: A phrase frequently used to describe an algorithm that has an upper bound asymptotically within a constant of a lower bound for the problem * Big O in probability notation: Op,op * Limit superior and limit inferior: An explanation of some of the limit notation used in this article * Master theorem (analysis of algorithms): For analyzing divide-and-conquer recursive algorithms using Big O notation * Nachbin's theorem: A precise method of bounding complex analytic functions so that the domain of convergence of integral transforms can be stated * Orders of approximation * Computational complexity of mathematical operations == References and notes == == Further reading == * * * * * * * * * * == External links == * Growth of sequences \u2014 OEIS (Online Encyclopedia of Integer Sequences) Wiki * Introduction to Asymptotic Notations * Landau Symbols * Big-O Notation \u2013 What is it good for * Big O Notation explained in plain english *An example of Big O in accuracy of central divided difference scheme for first derivative *A Gentle Introduction to Algorithm Complexity Analysis Category:Mathematical notation Category:Asymptotic analysis Category:Analysis of algorithms ",
    "title": "Big O notation"
}