{
    "id": "2737742",
    "text": "A carry-skip adder (also known as a carry-bypass adder) is an adder implementation that improves on the delay of a ripple-carry adder with little effort compared to other adders. The improvement of the worst-case delay is achieved by using several carry-skip adders to form a block-carry-skip adder. Unlike other fast adders, carry-skip adder performance is increased with only some of the combinations of input bits. This means, speed improvement is only probabilistic. ==Single carry-skip adder== The worst case for a simple one level ripple-carry adder occurs, when the propagate-condition is true for each digit pair (a_i, b_i). Then the carry-in ripples through the n-bit adder and appears as the carry-out after \\tau_{CRA}(n) \\approx n \\cdot \\tau_{VA}. Full adder with additional generate and propagate signals. For each operand input bit pair (a_i,b_i) the propagate-conditions p_i = a_i \\oplus b_i are determined using an XOR-gate. When all propagate-conditions are true, then the carry-in bit c_0 determines the carry-out bit. The n-bit-carry-skip adder consists of a n-bit-carry-ripple-chain, a n-input AND-gate and one multiplexer. Each propagate bit p_i, that is provided by the carry-ripple- chain is connected to the n-input AND-gate. The resulting bit is used as the select bit of a multiplexer that switches either the last carry-bit c_n or the carry-in c_0 to the carry-out signal c_{out}. * s = p_{n-1} \\wedge p_{n-2} \\wedge \\dots \\wedge p_1 \\wedge p_0 = p_{[0:n-1]} This greatly reduces the latency of the adder through its critical path, since the carry bit for each block can now \"skip\" over blocks with a group propagate signal set to logic 1 (as opposed to a long ripple-carry chain, which would require the carry to ripple through each bit in the adder). The number of inputs of the AND-gate is equal to the width of the adder. For a large width, this becomes impractical and leads to additional delays, because the AND-gate has to be built as a tree. A good width is achieved, when the sum-logic has the same depth like the n-input AND-gate and the multiplexer. 4 bit carry-skip adder. ===Performance=== The critical path of a carry-skip-adder begins at the first full-adder, passes through all adders and ends at the sum-bit s_{n-1}. Carry- skip-adders are chained (see block-carry-skip-adders) to reduce the overall critical path, since a single n-bit carry-skip-adder has no real speed benefit compared to a n-bit ripple-carry adder. :\\tau_{CSA}(n) = \\tau_{CRA}(n) The skip-logic consists of a m-input AND-gate and one multiplexer. :T_{SK} = T_{AND}(m) + T_{MUX} As the propagate signals are computed in parallel and are early available, the critical path for the skip logic in a carry-skip adder consists only of the delay imposed by the multiplexer (conditional skip). :T_{CSK} = T_{MUX} = 2 D. ==Block-carry-skip adders== 16-bit fixed-block- carry-skip adder with a block size of 4 bit. Block-carry-skip adders are composed of a number of carry-skip adders. There are two types of block-carry- skip adders The two operands A = (a_{n-1}, a_{n-2}, \\dots , a_1, a_0) and B = (b_{n-1}, b_{n-2}, \\dots , b_1, b_0) are split in k blocks of (m_{k}, m_{k-1}, \\dots , m_{2}, m_{1}) bits. * Why are block-carry-skip-adders used? * Should the block-size be constant or variable? * Fixed block width vs. variable block width ===Fixed size block-carry-skip adders=== Fixed size block-carry-skip adders split the n bits of the input bits into blocks of m bits each, resulting in k = \\frac{n}{m} blocks. The critical path consists of the ripple path and the skip element of the first block, the skip paths that are enclosed between the first and the last block, and finally the ripple-path of the last block. :T_{FCSA}(n) = T_{CRA_{[0:c_{out}]}}(m) + T_{CSK} + (k-2) \\cdot T_{CSK} + T_{CRA}(m) = 3 D + m \\cdot 2 D + (k-1) \\cdot 2 D + (m+2) 2 D = (2m + k) \\cdot 2 D + 5 D The optimal block size for a given adder width n is derived by equating to 0 :\\frac{d T_{FCSA}(n)}{d m} = 0 :2 D \\cdot \\left(2 - n \\cdot \\frac{1}{m^2} \\right) = 0 :\\Rightarrow m_{1,2} = \\pm \\sqrt{\\frac{n}{2}} Only positive block sizes are realizable :\\Rightarrow m = \\sqrt{\\frac{n}{2}} ===Variable size block-carry-skip adders=== The performance can be improved, i.e. all carries propagated more quickly by varying the block sizes. Accordingly the initial blocks of the adder are made smaller so as to quickly detect carry generates that must be propagated the furthers, the middle blocks are made larger because they are not the problem case, and then the most significant blocks are again made smaller so that the late arriving carry inputs can be processed quickly. ==Multilevel carry-skip adders== By using additional skip-blocks in an additional layer, the block-propagate signals p_{[i:i+3]} are further summarized and used to perform larger skips: :p_{[i:i+15]} = p_{[i:i+3]} \\wedge p_{[i+4:i+7]} \\wedge p_{[i+8:i+11]} \\wedge p_{[i+12:i+15]} Thus making the adder even faster. ==Carry-skip optimization== The problem of determining the block sizes and number of levels required to make the physically fastest carry-skip adder is known as the 'carry-skip adder optimization problem'. This problem is made complex by the fact that a carry- skip adders are implemented with physical devices whose size and other parameters also affects addition time. The carry-skip optimization problem for variable block sizes and multiple levels for an arbitrary device process node was solved by Thomas W. Lynch. This reference also shows that carry-skip addition is the same as parallel prefix addition and is thus related to, and for some configurations identical to the Han\u2013Carlson, the Brent\u2013Kung, the Kogge-Stone adder and a number of other adder types. ==Implementation overview== Breaking this down into more specific terms, in order to build a 4-bit carry-bypass adder, 6 full adders would be needed. The input buses would be a 4-bit A and a 4-bit B, with a carry-in (CIN) signal. The output would be a 4-bit bus X and a carry-out signal (COUT). The first two full adders would add the first two bits together. The carry-out signal from the second full adder (C_1)would drive the select signal for three 2 to 1 multiplexers. The second set of 2 full adders would add the last two bits assuming C_1 is a logical 0. And the final set of full adders would assume that C_1 is a logical 1. The multiplexers then control which output signal is used for COUT, X_2 and X_3. ==Notes== ==References== ==External links== * Explanation for critical path of the variable-skip adder Category:Adders (electronics) ",
    "title": "Carry-skip adder"
}