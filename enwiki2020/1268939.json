{
    "id": "1268939",
    "text": "General-purpose computing on graphics processing units (GPGPU, rarely GPGP) is the use of a graphics processing unit (GPU), which typically handles computation only for computer graphics, to perform computation in applications traditionally handled by the central processing unit (CPU).Fung, et al., \"Mediated Reality Using Computer Graphics Hardware for Computer Vision\" , Proceedings of the International Symposium on Wearable Computing 2002 (ISWC2002), Seattle, Washington, USA, 7\u201310 October 2002, pp. 83\u201389.An EyeTap video-based featureless projective motion estimation assisted by gyroscopic tracking for wearable computer mediated reality, ACM Personal and Ubiquitous Computing published by Springer Verlag, Vol.7, Iss. 3, 2003.\"Computer Vision Signal Processing on Graphics Processing Units\", Proceedings of the IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP 2004) : Montreal, Quebec, Canada, 17\u201321 May 2004, pp. V-93 \u2013 V-96Chitty, D. M. (2007, July). A data parallel approach to genetic programming using programmable graphics hardware . In Proceedings of the 9th annual conference on Genetic and evolutionary computation (pp. 1566-1573). ACM. The use of multiple video cards in one computer, or large numbers of graphics chips, further parallelizes the already parallel nature of graphics processing.\"Using Multiple Graphics Cards as a General Purpose Parallel Computer: Applications to Computer Vision\", Proceedings of the 17th International Conference on Pattern Recognition (ICPR2004) , Cambridge, United Kingdom, 23\u201326 August 2004, volume 1, pages 805\u2013808. In addition, even a single GPU-CPU framework provides advantages that multiple CPUs on their own do not offer due to the specialization in each chip. Essentially, a GPGPU pipeline is a kind of parallel processing between one or more GPUs and CPUs that analyzes data as if it were in image or other graphic form. While GPUs operate at lower frequencies, they typically have many times the number of cores. Thus, GPUs can process far more pictures and graphical data per second than a traditional CPU. Migrating data into graphical form and then using the GPU to scan and analyze it can create a large speedup. GPGPU pipelines were developed at the beginning of the 21st century for graphics processing (e.g., for better shaders). These pipelines were found to fit scientific computing needs well, and have since been developed in this direction. ==History== In principle, any arbitrary boolean function, including those of addition, multiplication and other mathematical functions can be built-up from a functionally complete set of logic operators. In 1987, Conway's Game of Life became one of the first examples of general purpose computing using an early stream processor called a blitter to invoke a special sequence of logical operations on bit vectors. General-purpose computing on GPUs became more practical and popular after about 2001, with the advent of both programmable shaders and floating point support on graphics processors. Notably, problems involving matrices and/or vectors especially two-, three-, or four-dimensional vectors were easy to translate to a GPU, which acts with native speed and support on those types. The scientific computing community's experiments with the new hardware began with a matrix multiplication routine (2001); one of the first common scientific programs to run faster on GPUs than CPUs was an implementation of LU factorization (2005). These early efforts to use GPUs as general-purpose processors required reformulating computational problems in terms of graphics primitives, as supported by the two major APIs for graphics processors, OpenGL and DirectX. This cumbersome translation was obviated by the advent of general-purpose programming languages and APIs such as Sh/RapidMind, Brook and Accelerator. These were followed by Nvidia's CUDA, which allowed programmers to ignore the underlying graphical concepts in favor of more common high- performance computing concepts. Newer, hardware vendor-independent offerings include Microsoft's DirectCompute and Apple/Khronos Group's OpenCL. This means that modern GPGPU pipelines can leverage the speed of a GPU without requiring full and explicit conversion of the data to a graphical form. ==Implementations== Any language that allows the code running on the CPU to poll a GPU shader for return values, can create a GPGPU framework. , OpenCL is the dominant open general-purpose GPU computing language, and is an open standard defined by the Khronos Group. OpenCL provides a cross-platform GPGPU platform that additionally supports data parallel compute on CPUs. OpenCL is actively supported on Intel, AMD, Nvidia, and ARM platforms. The Khronos Group has also standardised and implemented SYCL, a higher-level programming model for OpenCL as a single-source domain specific embedded language based on pure C++11. The dominant proprietary framework is Nvidia CUDA. \"As the two major programming frameworks for GPU computing, OpenCL and CUDA have been competing for mindshare in the developer community for the past few years.\" Nvidia launched CUDA in 2006, a software development kit (SDK) and application programming interface (API) that allows using the programming language C to code algorithms for execution on GeForce 8 series and later GPUs. Programming standards for parallel computing include OpenCL (vendor-independent), OpenACC, and OpenHMPP. Mark Harris, the founder of GPGPU.org, coined the term GPGPU. The ', created by Xcelerit, is designed to accelerate large existing C++ or C# code-bases on GPUs with minimal effort. It provides a simplified programming model, automates parallelisation, manages devices and memory, and compiles to CUDA binaries. Additionally, multi-core CPUs and other accelerators can be targeted from the same source code. OpenVIDIA was developed at University of Toronto between 2003\u20132005, James Fung, Steve Mann, Chris Aimone, \"OpenVIDIA: Parallel GPU Computer Vision\", Proceedings of the ACM Multimedia 2005, Singapore, 6\u201311 November 2005, pages 849\u2013852 in collaboration with Nvidia. ' created by Altimesh compiles Common Intermediate Language to CUDA binaries. It supports generics and virtual functions. Debugging and profiling is integrated with Visual Studio and Nsight. It is available as a Visual Studio extension on Visual Studio Marketplace. Microsoft introduced the DirectCompute GPU computing API, released with the DirectX 11 API. ' created by QuantAlea introduces native GPU computing capabilities for the Microsoft .NET language F# and C#. Alea GPU also provides a simplified GPU programming model based on GPU parallel-for and parallel aggregate using delegates and automatic memory management. MATLAB supports GPGPU acceleration using the Parallel Computing Toolbox and MATLAB Distributed Computing Server, and third-party packages like Jacket. GPGPU processing is also used to simulate Newtonian physics by physics engines, and commercial implementations include Havok Physics, FX and PhysX, both of which are typically used for computer and video games. Close to Metal, now called Stream, is AMD's GPGPU technology for ATI Radeon-based GPUs. C++ Accelerated Massive Parallelism (C++ AMP) is a library that accelerates execution of C++ code by exploiting the data-parallel hardware on GPUs. ===Mobile computers=== Due to a trend of increasing power of mobile GPUs, general-purpose programming became available also on the mobile devices running major mobile operating systems. Google Android 4.2 enabled running RenderScript code on the mobile device GPU. Apple introduced the proprietary Metal API for iOS applications, able to execute arbitrary code through Apple's GPU compute shaders. ==Hardware support== Computer video cards are produced by various vendors, such as Nvidia, AMD, and ATI. Cards from such vendors differ on implementing data-format support, such as integer and floating-point formats (32-bit and 64-bit). Microsoft introduced a Shader Model standard, to help rank the various features of graphic cards into a simple Shader Model version number (1.0, 2.0, 3.0, etc.). ===Integer numbers=== Pre-DirectX 9 video cards only supported paletted or integer color types. Various formats are available, each containing a red element, a green element, and a blue element. Sometimes another alpha value is added, to be used for transparency. Common formats are: * 8 bits per pixel \u2013 Sometimes palette mode, where each value is an index in a table with the real color value specified in one of the other formats. Sometimes three bits for red, three bits for green, and two bits for blue. * 16 bits per pixel \u2013 Usually the bits are allocated as five bits for red, six bits for green, and five bits for blue. * 24 bits per pixel \u2013 There are eight bits for each of red, green, and blue. * 32 bits per pixel \u2013 There are eight bits for each of red, green, blue, and alpha. ===Floating- point numbers=== For early fixed-function or limited programmability graphics (i.e., up to and including DirectX 8.1-compliant GPUs) this was sufficient because this is also the representation used in displays. It is important to note that this representation does have certain limitations. Given sufficient graphics processing power even graphics programmers would like to use better formats, such as floating point data formats, to obtain effects such as high dynamic range imaging. Many GPGPU applications require floating point accuracy, which came with video cards conforming to the DirectX 9 specification. DirectX 9 Shader Model 2.x suggested the support of two precision types: full and partial precision. Full precision support could either be FP32 or FP24 (floating point 32- or 24-bit per component) or greater, while partial precision was FP16. ATI's Radeon R300 series of GPUs supported FP24 precision only in the programmable fragment pipeline (although FP32 was supported in the vertex processors) while Nvidia's NV30 series supported both FP16 and FP32; other vendors such as S3 Graphics and XGI supported a mixture of formats up to FP24. The implementations of floating point on Nvidia GPUs are mostly IEEE compliant; however, this is not true across all vendors.Mapping computational concepts to GPUs: Mark Harris. Mapping computational concepts to GPUs. In ACM SIGGRAPH 2005 Courses (Los Angeles, California, 31 July 4 August 2005). J. Fujii, Ed. SIGGRAPH '05. ACM Press, New York, NY, 50. This has implications for correctness which are considered important to some scientific applications. While 64-bit floating point values (double precision float) are commonly available on CPUs, these are not universally supported on GPUs. Some GPU architectures sacrifice IEEE compliance, while others lack double-precision. Efforts have occurred to emulate double-precision floating point values on GPUs; however, the speed tradeoff negates any benefit to offloading the computing onto the GPU in the first place.Double precision on GPUs (Proceedings of ASIM 2005) : Dominik Goddeke, Robert Strzodka, and Stefan Turek. Accelerating Double Precision (FEM) Simulations with (GPUs). Proceedings of ASIM 2005 18th Symposium on Simulation Technique, 2005. ===Vectorization=== Most operations on the GPU operate in a vectorized fashion: one operation can be performed on up to four values at once. For example, if one color is to be modulated by another color , the GPU can produce the resulting color in one operation. This functionality is useful in graphics because almost every basic data type is a vector (either 2-, 3-, or 4-dimensional). Examples include vertices, colors, normal vectors, and texture coordinates. Many other applications can put this to good use, and because of their higher performance, vector instructions, termed single instruction, multiple data (SIMD), have long been available on CPUs. ==GPU vs. CPU== Originally, data was simply passed one-way from a central processing unit (CPU) to a graphics processing unit (GPU), then to a display device. As time progressed, however, it became valuable for GPUs to store at first simple, then complex structures of data to be passed back to the CPU that analyzed an image, or a set of scientific-data represented as a 2D or 3D format that a video card can understand. Because the GPU has access to every draw operation, it can analyze data in these forms quickly, whereas a CPU must poll every pixel or data element much more slowly, as the speed of access between a CPU and its larger pool of random-access memory (or in an even worse case, a hard drive) is slower than GPUs and video cards, which typically contain smaller amounts of more expensive memory that is much faster to access. Transferring the portion of the data set to be actively analyzed to that GPU memory in the form of textures or other easily readable GPU forms results in speed increase. The distinguishing feature of a GPGPU design is the ability to transfer information bidirectionally back from the GPU to the CPU; generally the data throughput in both directions is ideally high, resulting in a multiplier effect on the speed of a specific high-use algorithm. GPGPU pipelines may improve efficiency on especially large data sets and/or data containing 2D or 3D imagery. It is used in complex graphics pipelines as well as scientific computing; more so in fields with large data sets like genome mapping, or where two- or three-dimensional analysis is useful especially at present biomolecule analysis, protein study, and other complex organic chemistry. Such pipelines can also vastly improve efficiency in image processing and computer vision, among other fields; as well as parallel processing generally. Some very heavily optimized pipelines have yielded speed increases of several hundred times the original CPU-based pipeline on one high-use task. A simple example would be a GPU program that collects data about average lighting values as it renders some view from either a camera or a computer graphics program back to the main program on the CPU, so that the CPU can then make adjustments to the overall screen view. A more advanced example might use edge detection to return both numerical information and a processed image representing outlines to a computer vision program controlling, say, a mobile robot. Because the GPU has fast and local hardware access to every pixel or other picture element in an image, it can analyze and average it (for the first example) or apply a Sobel edge filter or other convolution filter (for the second) with much greater speed than a CPU, which typically must access slower random-access memory copies of the graphic in question. GPGPU is fundamentally a software concept, not a hardware concept; it is a type of algorithm, not a piece of equipment. Specialized equipment designs may, however, even further enhance the efficiency of GPGPU pipelines, which traditionally perform relatively few algorithms on very large amounts of data. Massively parallelized, gigantic-data-level tasks thus may be parallelized even further via specialized setups such as rack computing (many similar, highly tailored machines built into a rack), which adds a third layer many computing units each using many CPUs to correspond to many GPUs. Some Bitcoin \"miners\" used such setups for high-quantity processing. ===Caches=== Historically, CPUs have used hardware-managed caches, but the earlier GPUs only provided software-managed local memories. However, as GPUs are being increasingly used for general-purpose applications, state-of-the-art GPUs are being designed with hardware-managed multi-level caches\"A Survey of Techniques for Managing and Leveraging Caches in GPUs \", S. Mittal, JCSC, 23(8), 2014. which have helped the GPUs to move towards mainstream computing. For example, GeForce 200 series GT200 architecture GPUs did not feature an L2 cache, the Fermi GPU has 768 KiB last-level cache, the Kepler GPU has 1.5 MiB last-level cache, the Maxwell GPU has 2 MiB last-level cache, and the Pascal GPU has 4 MiB last-level cache. ===Register file=== GPUs have very large register files, which allow them to reduce context-switching latency. Register file size is also increasing over different GPU generations, e.g., the total register file size on Maxwell (GM200), Pascal and Volta GPUs are 6 MiB, 14 MiB and 20 MiB, respectively.\"A Survey of Techniques for Architecting and Managing GPU Register File \", IEEE TPDS, 2016\"Inside Pascal: Nvidia\u2019s Newest Computing Platform \"\"Inside Volta: The World\u2019s Most Advanced Data Center GPU \" By comparison, the size of a register file on CPUs is small, typically tens or hundreds of kilobytes. ===Energy efficiency=== The high performance of GPUs comes at the cost of high power consumption, which under full load is in fact as much power as the rest of the PC system combined.\"https://www.tomshardware.com/reviews/geforce-radeon-power,2122.html How Much Power Does Your Graphics Card Need?\" The maximum power consumption of the Pascal series GPU (Tesla P100) was specified to be 250W.\"https://images.nvidia.com/content/tesla/pdf/nvidia-tesla-p100-PCIe- datasheet.pdf Nvidia Tesla P100 GPU Accelerator \" Several research projects have compared the energy efficiency of GPUs with that of CPUs and FPGAs.\"A Survey of Methods for Analyzing and Improving GPU Energy Efficiency \", Mittal et al., ACM Computing Surveys, 2014. ==Stream processing== GPUs are designed specifically for graphics and thus are very restrictive in operations and programming. Due to their design, GPUs are only effective for problems that can be solved using stream processing and the hardware can only be used in certain ways. The following discussion referring to vertices, fragments and textures concerns mainly the legacy model of GPGPU programming, where graphics APIs (OpenGL or DirectX) were used to perform general-purpose computation. With the introduction of the CUDA (Nvidia, 2007) and OpenCL (vendor- independent, 2008) general-purpose computing APIs, in new GPGPU codes it is no longer necessary to map the computation to graphics primitives. The stream processing nature of GPUs remains valid regardless of the APIs used. (See e.g.,) GPUs can only process independent vertices and fragments, but can process many of them in parallel. This is especially effective when the programmer wants to process many vertices or fragments in the same way. In this sense, GPUs are stream processors processors that can operate in parallel by running one kernel on many records in a stream at once. A stream is simply a set of records that require similar computation. Streams provide data parallelism. Kernels are the functions that are applied to each element in the stream. In the GPUs, vertices and fragments are the elements in streams and vertex and fragment shaders are the kernels to be run on them. For each element we can only read from the input, perform operations on it, and write to the output. It is permissible to have multiple inputs and multiple outputs, but never a piece of memory that is both readable and writable. Arithmetic intensity is defined as the number of operations performed per word of memory transferred. It is important for GPGPU applications to have high arithmetic intensity else the memory access latency will limit computational speedup. Ideal GPGPU applications have large data sets, high parallelism, and minimal dependency between data elements. ===GPU programming concepts=== ====Computational resources==== There are a variety of computational resources available on the GPU: * Programmable processors \u2013 vertex, primitive, fragment and mainly compute pipelines allow programmer to perform kernel on streams of data * Rasterizer \u2013 creates fragments and interpolates per-vertex constants such as texture coordinates and color * Texture unit \u2013 read-only memory interface * Framebuffer \u2013 write-only memory interface In fact, a program can substitute a write only texture for output instead of the framebuffer. This is done either through Render to Texture (RTT), Render-To-Backbuffer-Copy-To- Texture (RTBCTT), or the more recent stream-out. ====Textures as stream==== The most common form for a stream to take in GPGPU is a 2D grid because this fits naturally with the rendering model built into GPUs. Many computations naturally map into grids: matrix algebra, image processing, physically based simulation, and so on. Since textures are used as memory, texture lookups are then used as memory reads. Certain operations can be done automatically by the GPU because of this. ====Kernels==== Compute kernels can be thought of as the body of loops. For example, a programmer operating on a grid on the CPU might have code that looks like this: // Input and output grids have 10000 x 10000 or 100 million elements. void transform_10k_by_10k_grid(float in[10000][10000], float out[10000][10000]) { for (int x = 0; x < 10000; x++) { for (int y = 0; y < 10000; y++) { // The next line is executed 100 million times out[x][y] = do_some_hard_work(in[x][y]); } } } On the GPU, the programmer only specifies the body of the loop as the kernel and what data to loop over by invoking geometry processing. ====Flow control==== In sequential code it is possible to control the flow of the program using if-then-else statements and various forms of loops. Such flow control structures have only recently been added to GPUs. Conditional writes could be performed using a properly crafted series of arithmetic/bit operations, but looping and conditional branching were not possible. Recent GPUs allow branching, but usually with a performance penalty. Branching should generally be avoided in inner loops, whether in CPU or GPU code, and various methods, such as static branch resolution, pre-computation, predication, loop splitting,Future Chips. \"Tutorial on removing branches\", 2011 and Z-cullGPGPU survey paper : John D. Owens, David Luebke, Naga Govindaraju, Mark Harris, Jens Kr\u00fcger, Aaron E. Lefohn, and Tim Purcell. \"A Survey of General-Purpose Computation on Graphics Hardware\". Computer Graphics Forum, volume 26, number 1, 2007, pp. 80\u2013113. can be used to achieve branching when hardware support does not exist. ===GPU methods=== ====Map==== The map operation simply applies the given function (the kernel) to every element in the stream. A simple example is multiplying each value in the stream by a constant (increasing the brightness of an image). The map operation is simple to implement on the GPU. The programmer generates a fragment for each pixel on screen and applies a fragment program to each one. The result stream of the same size is stored in the output buffer. ====Reduce==== Some computations require calculating a smaller stream (possibly a stream of only one element) from a larger stream. This is called a reduction of the stream. Generally, a reduction can be performed in multiple steps. The results from the prior step are used as the input for the current step and the range over which the operation is applied is reduced until only one stream element remains. ====Stream filtering==== Stream filtering is essentially a non-uniform reduction. Filtering involves removing items from the stream based on some criteria. ====Scan==== The scan operation, also termed parallel prefix sum, takes in a vector (stream) of data elements and an (arbitrary) associative binary function '+' with an identity element 'i'. If the input is [a0, a1, a2, a3, ...], an exclusive scan produces the output [i, a0, a0 + a1, a0 + a1 + a2, ...], while an inclusive scan produces the output [a0, a0 + a1, a0 + a1 + a2, a0 + a1 + a2 + a3, ...] and does not require an identity to exist. While at first glance the operation may seem inherently serial, efficient parallel scan algorithms are possible and have been implemented on graphics processing units. The scan operation has uses in e.g., quicksort and sparse matrix-vector multiplication. ====Scatter==== The scatter operation is most naturally defined on the vertex processor. The vertex processor is able to adjust the position of the vertex, which allows the programmer to control where information is deposited on the grid. Other extensions are also possible, such as controlling how large an area the vertex affects. The fragment processor cannot perform a direct scatter operation because the location of each fragment on the grid is fixed at the time of the fragment's creation and cannot be altered by the programmer. However, a logical scatter operation may sometimes be recast or implemented with another gather step. A scatter implementation would first emit both an output value and an output address. An immediately following gather operation uses address comparisons to see whether the output value maps to the current output slot. In dedicated compute kernels, scatter can be performed by indexed writes. ====Gather==== Gather is the reverse of scatter. After scatter reorders elements according to a map, gather can restore the order of the elements according to the map scatter used. In dedicated compute kernels, gather may be performed by indexed reads. In other shaders, it is performed with texture- lookups. ====Sort==== The sort operation transforms an unordered set of elements into an ordered set of elements. The most common implementation on GPUs is using radix sort for integer and floating point data and coarse- grained merge sort and fine-grained sorting networks for general comparable data.Merrill, Duane. Allocation-oriented Algorithm Design with Application to GPU Computing. Ph.D. dissertation, Department of Computer Science, University of Virginia. Dec. 2011.Sean Baxter. Modern gpu , 2013. ====Search==== The search operation allows the programmer to find a given element within the stream, or possibly find neighbors of a specified element. The GPU is not used to speed up the search for an individual element, but instead is used to run multiple searches in parallel. Mostly the search method used is binary search on sorted elements. ====Data structures==== A variety of data structures can be represented on the GPU: * Dense arrays * Sparse matrices (sparse array) static or dynamic * Adaptive structures (union type) ==Applications== The following are some of the areas where GPUs have been used for general purpose computing: * Automatic parallelizationLeung, Alan, Ond\u0159ej Lhot\u00e1k, and Ghulam Lashari. \"Automatic parallelization for graphics processing units.\" Proceedings of the 7th International Conference on Principles and Practice of Programming in Java. ACM, 2009.Henriksen, Troels, Martin Elsman, and Cosmin E. Oancea. \"Size slicing: a hybrid approach to size inference in futhark.\" Proceedings of the 3rd ACM SIGPLAN workshop on Functional high-performance computing. ACM, 2014.Baskaran, Muthu Manikandan, et al. \"A compiler framework for optimization of affine loop nests for GPGPUs.\" Proceedings of the 22nd annual international conference on Supercomputing. ACM, 2008. * Computer clusters or a variant of a parallel computing (using GPU cluster technology) for highly calculation-intensive tasks: ** High-performance computing (HPC) clusters, often termed supercomputers *** including cluster technologies like Message Passing Interface, and single-system image (SSI), distributed computing, and Beowulf ** Grid computing (a form of distributed computing) (networking many heterogeneous computers to create a virtual computer architecture) ** Load-balancing clusters, sometimes termed a server farm * Physical based simulation and physics enginesJoselli, Mark, et al. \"A new physics engine with automatic process distribution between CPU-GPU.\" Proceedings of the 2008 ACM SIGGRAPH symposium on Video games. ACM, 2008. (usually based on Newtonian physics models) ** Conway's Game of Life, cloth simulation, fluid incompressible flow by solution of Euler equations (fluid dynamics) or Navier\u2013Stokes equations * Statistical physics ** Ising modelBlock, Benjamin, Peter Virnau, and Tobias Preis. \"Multi-GPU accelerated multi-spin Monte Carlo simulations of the 2D Ising model.\" Computer Physics Communications 181.9 (2010): 1549-1556. * Lattice gauge theory * Segmentation 2D and 3DSun, Shanhui, Christian Bauer, and Reinhard Beichel. \"Automated 3-D segmentation of lungs with lung cancer in CT data using a novel robust active shape model approach.\" IEEE transactions on medical imaging 31.2 (2011): 449-460. * Level set methods * CT reconstructionJimenez, Edward S., and Laurel J. Orr. \"Rethinking the union of computed tomography reconstruction and GPGPU computing.\" Penetrating Radiation Systems and Applications XIV. Vol. 8854. International Society for Optics and Photonics, 2013. * Fast Fourier transformS\u00f8rensen, Thomas Sangild, et al. \"Accelerating the nonequispaced fast Fourier transform on commodity graphics hardware.\" IEEE Transactions on Medical Imaging 27.4 (2008): 538-547. * GPU learning machine learning and data mining computations, e.g., with software BIDMach * k-nearest neighbor algorithmFast k-nearest neighbor search using GPU. In Proceedings of the CVPR Workshop on Computer Vision on GPU, Anchorage, Alaska, USA, June 2008. V. Garcia and E. Debreuve and M. Barlaud. * Fuzzy logicM. Cococcioni, R. Grasso, M. Rixen, Rapid prototyping of high performance fuzzy computing applications using high level GPU programming for maritime operations support, in Proceedings of the 2011 IEEE Symposium on Computational Intelligence for Security and Defense Applications (CISDA), Paris, 11\u201315 April 2011 * Tone mapping * Audio signal processingWhalen, Sean. \"Audio and the graphics processing unit.\" Author report, University of California Davis 47 (2005): 51. ** Audio and sound effects processing, to use a GPU for digital signal processing (DSP) ** Analog signal processing ** Speech processing * Digital image processing * Video processing ** Hardware accelerated video decoding and post-processing *** Motion compensation (mo comp) *** Inverse discrete cosine transform (iDCT) *** Variable-length decoding (VLD), Huffman coding *** Inverse quantization (IQ (not to be confused by Intelligence Quotient)) *** In-loop deblocking *** Bitstream processing (CAVLC/CABAC) using special purpose hardware for this task because this is a serial task not suitable for regular GPGPU computation *** Deinterlacing **** Spatial-temporal deinterlacing *** Noise reduction *** Edge enhancement *** Color correction ** Hardware accelerated video encoding and pre-processing * Global illumination ray tracing, photon mapping, radiosity among others, subsurface scattering * Geometric computing constructive solid geometry, distance fields, collision detection, transparency computation, shadow generation * Scientific computing ** Monte Carlo simulation of light propagation ** Weather forecasting ** Climate research ** Molecular modeling on GPU ** Quantum mechanical physics ** Astrophysics * Bioinformatics * Computational finance * Medical imaging * Clinical decision support system (CDSS) * Computer visionWang, Guohui, et al. \"Accelerating computer vision algorithms using OpenCL framework on the mobile GPU-a case study.\" 2013 IEEE International Conference on Acoustics, Speech and Signal Processing. IEEE, 2013. * Digital signal processing / signal processing * Control engineering * Operations researchGPU computing in OR Vincent Boyer, Didier El Baz. \"Recent Advances on GPU Computing in Operations Research\". Parallel and Distributed Processing Symposium Workshops & PhD Forum (IPDPSW), 2013 IEEE 27th International, on pages: 1778\u20131787 ** Implementations of: the GPU Tabu Search algorithm solving the Resource Constrained Project Scheduling problem is freely available on GitHub;CTU-IIG Czech Technical University in Prague, Industrial Informatics Group (2015). the GPU algorithm solving the Nurse Rerostering problem is freely available on GitHub.NRRPGpu Czech Technical University in Prague, Industrial Informatics Group (2015). * Neural networks * Database operations * Computational Fluid Dynamics especially using Lattice Boltzmann methods * CryptographyManavski, Svetlin A. \"CUDA compatible GPU as an efficient hardware accelerator for AES cryptography.\" 2007 IEEE International Conference on Signal Processing and Communications. IEEE, 2007. and cryptanalysis * Performance modeling: computationally intensive tasks on GPU ** Implementations of: MD6, Advanced Encryption Standard (AES),AES and modes of operations on SM4.0 compliant GPUs. Owen Harrison, John Waldron, Practical Symmetric Key Cryptography on Modern Graphics Hardware. In proceedings of USENIX Security 2008. Data Encryption Standard (DES), RSA, elliptic curve cryptography (ECC) ** Password cracking ** Cryptocurrency transactions processing (\"mining\") (Bitcoin mining) * Electronic design automation * Antivirus softwareGrAVity: A Massively Parallel Antivirus Engine . Giorgos Vasiliadis and Sotiris Ioannidis, GrAVity: A Massively Parallel Antivirus Engine. In proceedings of RAID 2010. * Intrusion detectionGnort: High Performance Network Intrusion Detection Using Graphics Processors . Giorgos Vasiliadis et al., Gnort: High Performance Network Intrusion Detection Using Graphics Processors. In proceedings of RAID 2008.Regular Expression Matching on Graphics Hardware for Intrusion Detection . Giorgos Vasiliadis et al., Regular Expression Matching on Graphics Hardware for Intrusion Detection. In proceedings of RAID 2009. * Increase computing power for distributed computing projects like SETI@home, Einstein@home ===Bioinformatics=== GPGPU usage in Bioinformatics: {| class=\"wikitable\" ! Application ! Description ! Supported features ! Expected speed-up\u2020 ! GPU\u2021 ! Multi-GPU support ! Release status |- | BarraCUDA||DNA, including epigenetics, sequence mapping software||Alignment of short sequencing reads||6\u201310x||T 2075, 2090, K10, K20, K20X||||Available now, version 0.7.107f |- | CUDASW++||Open source software for Smith-Waterman protein database searches on GPUs||Parallel search of Smith-Waterman database||10\u201350x||T 2075, 2090, K10, K20, K20X||||Available now, version 2.0.8 |- | CUSHAW||Parallelized short read aligner||Parallel, accurate long read aligner gapped alignments to large genomes||10x||T 2075, 2090, K10, K20, K20X||||Available now, version 1.0.40 |- | GPU-BLAST||Local search with fast k-tuple heuristic||Protein alignment according to blastp, multi CPU threads||3\u20134x||T 2075, 2090, K10, K20, K20X||||Available now, version 2.2.26 |- | GPU-HMMER||Parallelized local and global search with profile hidden Markov models||Parallel local and global search of hidden Markov models||60\u2013100x||T 2075, 2090, K10, K20, K20X|| ||Available now, version 2.3.2 |- | mCUDA-MEME||Ultrafast scalable motif discovery algorithm based on MEME ||Scalable motif discovery algorithm based on MEME||4\u201310x||T 2075, 2090, K10, K20, K20X||||Available now, version 3.0.12 |- | SeqNFind||A GPU accelerated sequence analysis toolset||Reference assembly, blast, Smith\u2013Waterman, hmm, de novo assembly||400x||T 2075, 2090, K10, K20, K20X||||Available now |- | UGENE||Opensource Smith\u2013Waterman for SSE/CUDA, suffix array based repeats finder and dotplot||Fast short read alignment||6\u20138x||T 2075, 2090, K10, K20, K20X||||Available now, version 1.11 |- | WideLM||Fits numerous linear models to a fixed design and response||Parallel linear regression on multiple similarly-shaped models||150x||T 2075, 2090, K10, K20, K20X|| ||Available now, version 0.1-1 |} ====Molecular dynamics==== {| class=\"wikitable\" ! Application ! Description ! Supported features ! Expected speed-up\u2020 ! GPU\u2021 ! Multi-GPU support ! Release status |- | Abalone||Models molecular dynamics of biopolymers for simulations of proteins, DNA and ligands||Explicit and implicit solvent, hybrid Monte Carlo||4\u2013120x||T 2075, 2090, K10, K20, K20X||||Available now, version 1.8.88 |- | ACEMD||GPU simulation of molecular mechanics force fields, implicit and explicit solvent ||Written for use on GPUs||160 ns/day GPU version only||T 2075, 2090, K10, K20, K20X||||Available now |- | AMBER||Suite of programs to simulate molecular dynamics on biomolecule||PMEMD: explicit and implicit solvent|| 89.44 ns/day JAC NVE ||T 2075, 2090, K10, K20, K20X||||Available now, version 12 + bugfix9 |- | DL-POLY||Simulate macromolecules, polymers, ionic systems, etc. on a distributed memory parallel computer||Two-body forces, link-cell pairs, Ewald SPME forces, Shake VV||4x||T 2075, 2090, K10, K20, K20X||||Available now, version 4.0 source only |- | CHARMM||MD package to simulate molecular dynamics on biomolecule.||Implicit (5x), explicit (2x) solvent via OpenMM||TBD||T 2075, 2090, K10, K20, K20X ||||In development Q4/12 |- | GROMACS||Simulate biochemical molecules with complex bond interactions||Implicit (5x), explicit (2x) solvent||165 ns/Day DHFR ||T 2075, 2090, K10, K20, K20X|| ||Available now, version 4.6 in Q4/12 |- | HOOMD- Blue||Particle dynamics package written grounds up for GPUs||Written for GPUs ||2x ||T 2075, 2090, K10, K20, K20X||||Available now |- | LAMMPS||Classical molecular dynamics package ||Lennard-Jones, Morse, Buckingham, CHARMM, tabulated, course grain SDK, anisotropic Gay-Bern, RE-squared, \"hybrid\" combinations||3\u201318x||T 2075, 2090, K10, K20, K20X||||Available now |- | NAMD||Designed for high-performance simulation of large molecular systems||100M atom capable||6.44 ns/days STMV 585x 2050s||T 2075, 2090, K10, K20, K20X||||Available now, version 2.9 |- | OpenMM||Library and application for molecular dynamics for HPC with GPUs||Implicit and explicit solvent, custom forces||Implicit: 127\u2013213 ns/day; Explicit: 18\u201355 ns/day DHFR||T 2075, 2090, K10, K20, K20X||||Available now, version 4.1.1 |} \u2020 Expected speedups are highly dependent on system configuration. GPU performance compared against multi-core x86 CPU socket. GPU performance benchmarked on GPU supported features and may be a kernel to kernel performance comparison. For details on configuration used, view application website. Speedups as per Nvidia in-house testing or ISV's documentation. \u2021 Q=Quadro GPU, T=Tesla GPU. Nvidia recommended GPUs for this application. Check with developer or ISV to obtain certification information. ==See also== * Graphics processing unit * OpenCL * OpenMP * OpenACC * OpenHMPP * Fastra II * Stream processing * Mark Harris (programmer) * Physics engine ** Advanced Simulation Library ** Physics processing unit (PPU) ** Havok (software) Physics, FX ** PhysX * Close to Metal * C++ AMP * DirectCompute * RenderScript * Audio processing unit * Larrabee (microarchitecture) * Compute kernel * AI accelerator * Deep learning processor (DLP) ==References== ==External links== * openhmpp.org New Open Standard for Many-Core * OCLTools Open Source OpenCL Compiler and Linker * GPGPU.org \u2013 General-Purpose Computation Using Graphics Hardware * GPGPU Wiki * SIGGRAPH 2005 GPGPU Course Notes * IEEE VIS 2005 GPGPU Course Notes * Nvidia Developer Zone * AMD GPU Tools * CPU vs. GPGPU * What is GPU Computing? * Tech Report article: \"ATI stakes claims on physics, GPGPU ground\" by Scott Wasson * * GPGPU Computing @ Duke Statistical Science * GPGPU Programming in F# using the Microsoft Research Accelerator system Category:Emerging technologies Category:Graphics hardware Category:Video cards Category:Instruction processing Category:Parallel computing Category:Video game development ",
    "title": "General-purpose computing on graphics processing units"
}