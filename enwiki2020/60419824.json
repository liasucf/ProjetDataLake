{
    "id": "60419824",
    "text": "A participatory budgeting (PB) algorithm is an algorithm for implementing participatory budgeting. The inputs to a PB algorithm are: a list of possible projects that require funding, the total available budget for funding the projects, and the preferences of voters over the project. The output of a PB algorithm is a partition of budget among the projects - determining how much money to allocate to each project. A PB algorithm can treat the projects as either divisible or indivisible: * A divisible PB algorithm may allocate any amount of money to any project, as long as the sum of allocations equals the budget. It is suited for projects in which each additional dollar can be used effectively, such as charity donations. * An indivisible PB algorithm takes, as additional inputs, the costs of the projects. It returns a subset of the projects, such that the total cost of the selected projects does not exceed the budget. Each selected project is allocated its entire cost, while each unselected project is allocated nothing. It is better suited for projects which must be entirely funded in order to operate, such as constructing new buildings. == Input formats == An important consideration in designing a PB algorithm is what input format to use for preference elicitation - how each voter should express his/her preferences over the projects. Several input formats used in practice are: * Approval voting: each voter specifies a subset of the projects that they \"approve\" (consider as valuable), while the others are considered unapproved. This is like a binary scoring system in which each voter can score each project as either 1 or 0. * k-approval voting: each voter specifies a subset of their top k projects - the k projects that they consider to be the most valuable. * Threshold approval voting: given a threshold-value t, each voter specifies the subset of all projects which they value as at least t. * Ranked voting: each voter specifies an entire preference-relation over the projects, specifying the project that they consider the most valuable, the 2nd-most valuable, etc. These input formats are problematic for indivisible PB, since they ignore the different costs of the projects. Some newer input formats, which do consider the costs, are: * Knapsack voting: each voter specifies a subset of the projects, such that the total cost of the projects in the subset is at most the budget (regardless of how many projects are in the subset). Thus, each voter has to solve an individual knapsack problem - finding the subset which maximizes their personal utility under the budget constraint. An advantage of knapsack voting is that, if the algorithm scores each project by the number of votes it received, and chooses projects greedily in descending order of score until the budget is filled, then knapsack voting is a partially truthful mechanism. * Value-for-money ranking: each voter ranks the projects, not according to their total value, but according to their value/cost ratio. The various input formats can be compared based in terms of implicit utilitarian voting - how much each input-format is useful in maximizing the sum of utilities. From this perspective, threshold approval voting is superior to knapsack voting, ranking-by-value and ranking- by-value-for-money: it minimizes the distortion from the maximum sum-of- utilities both theoretically and empirically. After the system receives the citizens' inputs, it should compute a budget. There are various criteria by which a budget can be evaluated. == Knapsack budgeting == The budgeting method most common in practice is a greedy solution to a variant of the knapsack problem: the projects are ordered by decreasing order of the number of votes they received, and selected one-by-one until the budget is full. Alternatively, if the number of projects is sufficiently small, the knapsack problem may be solved exactly, by selecting a subset of projects that maximizes the total happiness of the citizens. The disadvantage of this method, often called individually-best knapsack budgeting, is that it may be unfair towards minorities: if 51% of the population support 10 projects and 49% support 10 other projects, and the money suffices only for 10 projects, then knapsack budgeting will choose the 10 projects supported by the 51%, and ignore the 49% altogether. Two alternatives to individually-best knapsack are: * Diverse knapsack - maximizing the number of citizens who have at least one preferred item in the budget (similarly to the Chamberlin-Courant rule for multiwinner voting). * Nash-optimal knapsack - maximizing the product of the citizens' utilities. Unfortunately, for general utility domains, both these rules are NP-hard to compute. However, diverse-knapsack is polynomially- solvable in specific preference domains, or when the number of voters is small. == Majority budgeting == One such criterion is the Condorcet criterion: the selected budget should be at least as good as any other proposed budget, according to a majority of the voters (no proposed change to it has majority support among the votes). There exists a polynomial-time algorithm for finding such a budget. The algorithm uses Schwartz sets. == Proportional budgeting == Another set of criteria is related to proportional representation. These criteria generalize the justified representation criteria from multi-winner voting. The idea of these criteria is that, if there is a sufficiently large group of voters who all agree on a specific project, then this project should receive a sufficiently large part of the budget. The expressions below formalize this intuition for the case of indivisible PB and approval voting, i.e.: * There are m discrete projects; each project j requires a cost cj. * There are n voters; each voter has a set of projects they consider desirable. *The goal is to decide on a subset of projects to fund, with a total cost of at most L. Below, L denotes the budget limit. * Strong Budget-Justified- Representation (BJR) means that, for every voter-group of size at least n/L, if all of them support at least one project, then at least one project wanted by all of them is funded. * Strong Budget-Proportional-Justified- Representation (BPJR) means that, for every integer k and every voter-group of size at least kn/L, if the projects supported by all of them cost at least k, then the projects supported by all of them should be get a funding of at least k. Unfortunately, Strong BJR budgets may not exist (and obviously the same is true for strong BPJR, since BJR is a special case of BPJR for k=1). For example, suppose there are two projects with cost 2, the budget-limit is 3, and there are two voters each of whom desires a single project. Then, each voter is a group of size 1 > 2/3, so BJR requires that the project of each voter is funded, but the sum of costs of both projects is 4>3. Therefore, weaker variants of these criteria have been suggested: *Weak BJR means that, for every voter-group of size at least n/L, if all of them support at least one project of cost one (the minimal cost), then at least one project wanted by all of them is funded. *Weak BPJR means that, for every integer k and every voter-group of size at least kn/L, if the projects supported by all of them cost at least k, then the fundings for projects supported by all of them should be at least the maximum cost of a project-subset with cost at most k supported by all of them. Fortunately, Weak BPJR budgets (and hence weak BJR budgets) always exist and can be found by a super-polynomial algorithm. Finding a weak-BPJR budget is NP-hard, but finding a weak-BJR budget can be done by a polynomial greedy algorithm. Another criterion, Weak Local BPJR, is weaker than weak BPJR but stronger than weak BJR; it can be found by a polynomial-time algorithm based on Phragmen's sequential rule. Each of these criteria has a weaker variant where, instead of the external budget-limit L, the denominator is W, which is the actual amount used for funding. Since usually W == Core budgeting == For the case of divisible PB and utility voting, a compelling budgeting method is one based on the core of the underlying game. A budget is considered \"in the core\" if no subset of k voters can take their share of the budget (k L / n) and fund a subset of the projects such that the utility of each voter in the subset strictly increases. There are efficient algorithms for calculating the core budget for some natural classes of utility functions. == Donor coordination == The donor coordination problem is a variant of divisible PB in which the budget is donated by the voters themselves (rather than fixed in advance). A coordination algorithm can improve the efficiency of the distribution of funds. For example, suppose three projects are considered: theater, chess club, and basketball field. There are two donors: Alice and Bob, each of whom wants to contribute 3000. Alice prefers indoor activities (theater or chess), while Bob prefers competitive activities (chess or basketball). * If they do not coordinate, then naturally Alice contributes 1500 to each indoor activity, while Bob contributes 1500 to each competitive activity. The resulting distribution is 1500, 3000, 1500. Each donor feels a happiness of 4500 from the donations to his/her preferred projects. * In contrast, if they coordinate, they can contribute everything to the chess club, so the distribution becomes 0, 6000, 0. Now, each donor feels a happiness of 6000, so this distribution Pareto- dominates the previous one. Since the donations are voluntary, it is important that the coordination algorithm ensures that each voter weakly gains from participating in the algorithm, i.e., the amount contributed to projects he approves of is weakly higher when he participates than when he does not. This requirement may be incompatible with efficient budget allocation when the voters' utilities are general linear functions. However, it is attainable when the voters' utilities are linear and binary, i.e., in the approval voting model: * There are m charities; each charity can benefit from any amount of money put into it. * There are n donors; each donor has a set of charities he/she cares about. Each donor i is willing to donate a total amount of Ci. * The goal is to decide on a distribution of the total funds collected from all donors (the sum of the Ci) among the m charities. The utility of each agent from a given distribution is the sum of money allocated to his/her beloved charities. Several rules have been analyzed in this setting. They are exemplified below for a setting with 4 charities (a,b,c,d) and 5 donors who contribute 1 each, and whose beloved sets are ac, ad, bc, bd, a. * The uncoordinated rule just divides the contribution of each agent i among the charities liked by i. So the funding distribution is 2,1,1,1 and the utilities of the five agents are 3,3,2,2,2. This mechanism is implementable and individually-rational, but not efficient: the outcome is dominated, for example, by the distribution 3,2,0,0, where the utilities are 3,3,2,2,3. * The Nash-optimal rule finds a budget-allocation maximizing the product of utilities. It is Pareto optimal, implementable and individually-rational. However, it is not Strategyproof nor resource-monotonic. * The Constrained- utilitarian rule finds a budget-allocation maximizing the sum of utilities from the set of all implementable rules. It is implementable, individually- rational, strategyproof and resource-monotonic. However, it is not Pareto- optimal. * There is no PB rule that satisfies all five properties, even with binary preferences. == References == Category:Electoral systems Category:Computational social science Category:Participatory budgeting ",
    "title": "Participatory budgeting algorithm"
}