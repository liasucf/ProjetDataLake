{
    "id": "60388496",
    "text": "In computer science, a channel system is a finite state machine similar to communicating finite-state machine in which there is a single system communicating with itself instead of many systems communicating with each other. A channel system is similar to a pushdown automaton where a queue is used instead of a stack. Those queues are called channels. Intuitively, each channel represents a sequence a message to be sent, and to be read in the order in which they are sent. == Definition == === Channel system === Formally, a channel system (or perfect channel system) S is defined as a tuple \\langle Q,C,\\Sigma,\\Delta \\rangle with: * Q=\\\\{q_1,\\dots,q_m\\\\} a finite set of control states, * q_0\\in Q an initial state, * A a finite alphabet (for the sake of notation simplicity, let \\epsilon \\in A), * C=\\\\{c_1,\\dots,c_n\\\\} a finite set of channels, * \\Sigma=\\\\{a_1,\\dots,a_p\\\\} a finite alphabet of messages, * \\Delta\\subseteq Q\\times C\\times\\\\{?,!\\\\}\\times\\Sigma^*\\times A \\times Q a finite set of transition rules with \\Sigma^* being the set of finite (potentially empty) words over the alphabet \\Sigma. Depending of the author, a channel system may have no initial state and may have an empty alphabet. === Configuration === A configuration or global state of the channel system is a n+1 tuple belonging to Q\\times\\prod_{i=1}^n(\\Sigma^*). Intuitively, a configuration \\gamma=(q,w_1,\\dots,w_m) represents that a run is in state q and that its i-th channel contains the word w_i. The initial configuration is (q_0,\\epsilon,\\dots,\\epsilon), with \\epsilon the empty word. === Step === Intuitively, a transition (q,c_i,!,u,a,q') means that the system may goes to control state q to q' by writing an u to the end of the channel c_i. Similarly (q,c_i,?,u,a,q') means that the system may goes to control state q to q' by removing a u starting the word c_i. Formally, given a configuration (q,w_1,\\dots,w_m), and a transition (q,c_i,!,u,q'), there is a perfect step (q,w_1,\\dots, w_{i-1}, w_i, w_{i+1},\\dots,w_m)\\xrightarrow{a}_{\\mathtt{perf}}(q',w_1,\\dots,w_{i-1},w_iu,w_{i+1},\\dots,w_m), where the step adds a letter u to the end of the i-th word. Similarly, given a transition (q,c_i,?,u,q'), there is a perfect step (q,w_1,\\dots,w_{i-1},uw_i,w_{i+1},w_m)\\xrightarrow{a}_{\\mathtt{perf}}(q',w_1,\\dots,w_{i-1}, w_i, w_{i+1},\\dots,w_m) where the first letter of the i-th word is u and has been removed during the step. === Run === A perfect run is a sequence of perfect step, of the form \\gamma_0\\xrightarrow{a_0}_{\\mathtt{perf}}\\gamma_1\\dots. We let \\gamma\\xrightarrow[\\mathtt{perf}]{*}\\gamma' denote that there is a perfect run starting at \\gamma and ending at \\gamma'. === Languages === Given a perfect or a lossy channel system S, multiple languages may be defined. A word over A^* is accepted by S if it is the concatenation of the labels of a run of S. The language defined by S is the set of words accepted by S. The set of reachable configuration of S, denoted R(S) is defined as the set of configuration \\gamma reachable from the initial state. I.e. as the set of configurations \\gamma' such that (q_0,\\epsilon,\\dots,\\epsilon)\\xrightarrow{*}\\gamma'. Given a channel c, the channel of c is the set of tuples (w_1,\\dots w_m) such that (c,w_1,\\dots,w_m)\\in R(S). == Channel system and Turing machine == Most problem related to perfect channel system are undecidable. This is due to the fact that such a machine may simulates the run of a Turing machine. This simulation is now sketched. Given a Turing machine M, there exists a perfect channel system S such that any run of M of length n can be simulated by a run of S of length O(n^2). Intuitively, this simulation consists simply in having the entire tape of the simulated Turing machine in a channel. The content channel is then entirely read and immediately rewritten in the channel, with one exception, the part of the content representing the head of the Turing machine is changed, to simulate a step of the Turing machine computation. == Variants == Multiple variants of channel systems have been introduced. The two variants introduced below does not allow to simulate a Turing machine and thus allows multiple problem of interest to be decidable. === One channel machine === A one-channel machine is a channel system using a single channel. The same definition also applies for all variants of channel system. === Counter machine === When the alphabet of a channel system contains a single message, then each channel is essentially a counter. It follows that those systems are essentially Minsky machines. We call such systems counter machines. This same definition applies for all variants of channel system. === Completely specified protocol === A completely specified protocol (CSP) is defined exactly as a channel system. However, the notion of step and of run are defined differently. A CSP admits two kinds of steps. Perfect steps, as defined above, and a message loss transition step. We denote a message loss transition step by (q,w_1,\\dots,a\\cdot w_i,\\dots,w_m)\\rightsquigarrow(q,w_1,\\dots,w_i,\\dots,w_m). === Looseness === A lossy channel system or machine capable of lossiness error is an extension of completely specified protocol in which letters may disappear anywhere. A lossy channel system admits two kinds of steps. Perfect steps, as defined above, and lossy step. We denote a lossy step, (q,w_1,\\dots,w_i\\cdot a\\cdot w'_i\\dots,,w_m)\\rightsquigarrow(q,w_1,\\dots,w_i\\cdot w'_i,w'_m). A run in which channel are emptied as soon as messages are sent into them is a valid run according to this definition. For this reason, some fairness conditions may be introduced to those systems. ==== Channel fairness ==== Given a message a channel c, a run is said to be channel fair with respect to c if, assuming there are infinitely many steps in which a letter is sent to c then there are infinitely many steps in which a letter is read from c. A computation is said to be channel fair if it is channel fair with respect to each channel c. ===== Impartiality ===== The impartiality condition is a restriction to the channel fairness condition in which both the channel and the letter are considered. Given a message m and a channel c, a run is said to be impartial with respect to c and m if, assuming there are infinitely many steps in which m is sent to c then there are infinitely many steps in which m is read from c. A computation is said to be impartial with respect to a channel c if it is impartial with respect to c and a messages m. It is said to be impartial if it is impartial with respect to every channels c. ===== Message fairness ===== The message fairness property is similar to impartiality, but the condition only have to hold if there is an infinite number of step at which m may be read. Formally, a run is said to be message faire with respect to c and m if, assuming there are infinitely many steps in which m is sent to c, and infinitely many step i which occurs in a state q such that there exists a transition (q,m,q'), then there are infinitely many steps in which m is read from c. ===== Boundedness ===== The run is said to have bounded lossiness if the number of letter removed between two perfect steps is bounded. === Insertion of errors === A machine capable of insertion of error is an extension of channel system in which letters may appear anywhere. A machine capable of insertion of error admits two kinds of steps. Perfect steps, as defined above, and insertion steps. We denote an insertion step by (q,w_1,\\dots,w_i\\cdot w'_i\\dots,,w_m)\\rightsquigarrow(q,w_1,\\dots,w_i\\cdot a\\cdot w'_i,w'_m). === Duplication errors === A machine capable of duplication error is an extension of machine capable of insertion of error in which the inserted letter is a copy of the previous letter. A machine capable of insertion of error admits two kinds of steps. Perfect steps, as defined above, and duplication steps. We denote an insertion step by (q,w_1,\\dots,w_i\\cdot a\\cdot w'_i\\dots,,w_m)\\rightsquigarrow(q,w_1,\\dots,w_i\\cdot a\\cdot a\\cdot w'_i,w'_m). A non-duplicate machine capable of duplication error is a machine which ensures that in each channel, the letters alternate between a special new letter #, and a regular letter from the alphabet of message. If it is not the caes, it means a duplication occurred and the run rejects. This process allow to encode any channel system into a machine capable of duplication error, while forcing it not to have errors. Since channel systems can simulate machines, it follows that machines capable of duplication error can simulate Turing machine. == Properties == The set of reachable configurations is recognizable for lossy channel machines and machines capable of insertions of errors. It is recursively enumerable for machine capable of duplication error. == Problems and their complexity == This section contain a list of problems over channel system, and their decidability of complexity over variants of such systems. === Termination problem === The termination problem consists in deciding, given a channel system S and an initial configuration \\gamma whether all runs of S starting at \\gamma are finite. This problem is undecidable over perfect channel systems, even when the system is a counter machine or when it is a one-channel machine. This problem is decidable but nonprimitive recursive over lossy channel system. This problem is trivially decidable over machine capable of insertion of errors. === Reachability problem === The reachability problem consists in deciding, given a channel system S and two initial configurations \\gamma and \\gamma' whether there is a run of S from \\gamma to \\gamma'. This problem is undecidable over perfect channel systems and decidable but nonprimitive recursive over lossy channel system. This problem is decidable over machine capable of insertion of errors . === Reachability problem === The deadlock problem consists in deciding whether there is a reachable configuration without successor. This problem is decidable over lossy channel system and trivially decidable over machine capable of insertion of errors. It is also decidable over counter machine. === Model checking problem === The model checking problem consists in deciding whether given a system S and a CTL**-formula or a LTL-formula \\phi or a whether the language defined by S satisfies \\phi. This problem is undecidable over lossy channel system. === Recurrent state problem === The recurrent state problem consists in deciding, given a channel system S and an initial configuration \\gamma and a state s whether there exists a run of S, starting at \\gamma, going infinitely often through state s. This problem is undecidable over lossy channel system, even with a single channel. === Equivalent finite state machine === Given a system S, there is no algorithm which computes a finite state machine representing R(S) for the class of lossy channel system. This problem is decidable over machine capable of insertion of error . === Boundedness problem === The boundedness problem consists in deciding whether the set of reachable configuration is finite. I.e. the length of the content of each channel is bounded. This problem is trivially decidable over machine capable of insertion of errors. It is also decidable over counter machine. === Eventually properties === The eventuality property, or inevitability property problem consists in deciding, given a channel system S and a set \\Gamma of configurations whether all run of S starting at \\gamma goes through a configuration of \\Gamma. This problem is undecidable for lossy channel system with impartiality and with the two other fairness constraints. === Safety property === The safety property problem consists in deciding, given a channel system S and a regular set R whether === Structural termination === The structural termination problem consists in deciding, given a channel system S if the termination problem holds for S for every initial configuration. This problem is undecidable even over counter machine. ==Communicating Hierarchical State Machine== Hierarchical state machines are finite state machines whose states themselves can be other machines. Since a communicating finite state machine is characterized by concurrency, the most notable trait in a communicating hierarchical state machine is the coexistence of hierarchy and concurrency. This had been considered highly suitable as it signifies stronger interaction inside the machine. However, it was proved that the coexistence of hierarchy and concurrency intrinsically costs language inclusion, language equivalence, and all of universality.Alur, Rajeev; Kannan, Sampath; Yannakakis, Mihalis. \"Communicating hierarchical state machines,\" Automata, Languages and Programming. Prague: ICALP, 1999 == References == Category:Concurrency (computer science) Category:Models of computation ",
    "title": "Channel system (computer science)"
}