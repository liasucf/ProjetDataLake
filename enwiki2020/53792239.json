{
    "id": "53792239",
    "text": "CANpie (CAN Programming Interface Environment) is an open source project and pursues the objective of creating and establishing an open and standardized software API for access to the CAN bus. CANpie FD logo The project was established in 2001https://sourceforge.net/projects/canpie/files/?source=navbar by MicroControl and is licensed under Apache License version 2.0. The current version of the CANpie APIhttp://www.microcontrol.net/download/canpie/canpie_user_v3r00.pdf covers both classical CAN frames as well as ISO CAN FDhttps://www.can- cia.org/fileadmin/resources/documents/proceedings/2012_hartwich.pdf frames. The API is designed for embedded control applications as well as for PC interface boards: embedded microcontrollers are programmed in C, a C++ API is provided for OS independent access to interface boards. The API provides ISO/OSI Layer-2 (Data Link Layer) functionality. It is not the intention of CANpie to incorporate higher layer functionality (e.g. CANopen, SAE J1939). ==Driver principle== The CANpie API supports the concept of hardware message buffers (mailboxes) with a total limit of 255 buffers. A message buffer has a unique direction (receive or transmit). As an option it is possible to connect a FIFO with arbitrary size to a message buffer for both transfer directions. The total number of CAN channels is limited to 255, the API provides a method to gather information about the features of each CAN hardware channel. This is especially important for an application designer who wants to write the code only once. The CAN frame time-stamping (specified by CiA 603, CAN Frame time- stamping \u2013 Requirements for network time managementhttps://www.can- cia.org/standardization/specifications/) is supported with a resolution of 1 nano-second. ==Usage== CANpie Structure The following code snippet shows the initialisation of a microcontroller. #include \"cp_core.h\" // CANpie core functions void MyCanInit(void) { CpPort_ts tsCanPortT; // logical CAN port //--------------------------------------------------- // setup the CAN controller / open a physical CAN // port // memset(&tsCanPortT;, 0, sizeof(CpPort_ts)); CpCoreDriverInit(eCP_CHANNEL_1, &tsCanPortT;, 0); //--------------------------------------------------- // setup 500 kBit/s // CpCoreBitrate(&tsCanPortT;, eCP_BITRATE_500K, eCP_BITRATE_NONE); //--------------------------------------------------- // start CAN operation // CpCoreCanMode(&tsCanPortT;, eCP_MODE_OPERATION); //.. now we are operational } ==Similar projects== For the Linux operating system the projects can4linux and SocketCAN provide support for Classical CAN and ISO CAN FD. The commercial AUTOSAR specification supports CAN FD since version 4.3 and is available only for AUTOSAR partners. The CMSIS-Driver (Cortex Microcontroller Software Interface Standard) specification is a software API that describes peripheral driver interfaces for middleware stacks and user applications on ARM Cortex-M processors.https://www.arm.com/products/processors/cortex-m/cortex- microcontroller-software-interface-standard.php ==References== ==External links== * CANpie documentation * CANpie project site * CAN newsletter 2014-02-25 * Software Architecture for Modular Self-Reconfigurable Robots, Xerox Palo Alto Research Center * AUTOSAR website * can4linux project site * SocketCAN project site * Patent applied for SocketCAN (German language) * iCC 2017 - \"CAN driver API - migration from Classical CAN to CAN FD\" Category:CAN bus Category:Computer-mediated communication Category:Data transmission Category:Serial buses ",
    "title": "CANpie"
}