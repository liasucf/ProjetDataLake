{
    "id": "646796",
    "text": "In mathematics, the regula falsi, method of false position, or false position method is a very old method for solving an equation with one unknown, that, in modified form, is still in use. In simple terms, the method is the trial and error technique of using test (\"false\") values for the variable and then adjusting the test value according to the outcome. This is sometimes also referred to as \"guess and check\". Versions of the method predate the advent of algebra and the use of equations. As an example, consider problem 26 in the Rhind papyrus, which asks for a solution of (written in modern notation) the equation . This is solved by false position. First, guess that to obtain, on the left, . This guess is a good choice since it produces an integer value. However, 4 is not the solution of the original equation, as it gives a value which is three times too small. To compensate, multiply (currently set to 4) by 3 and substitute again to get , verifying that the solution is . Modern versions of the technique employ systematic ways of choosing new test values and are concerned with the questions of whether or not an approximation to a solution can be obtained, and if it can, how fast can the approximation be found. ==Two historical types== Two basic types of false position method can be distinguished historically, simple false position and double false position. Simple false position is aimed at solving problems involving direct proportion. Such problems can be written algebraically in the form: determine such that :ax = b , if and are known. The method begins by using a test input value , and finding the corresponding output value by multiplication: . The correct answer is then found by proportional adjustment, . Double false position is aimed at solving more difficult problems that can be written algebraically in the form: determine such that :f(x) = ax + c = 0 , if it is known that :f(x_1) = b_1, \\qquad f(x_2) = b_2 . Double false position is mathematically equivalent to linear interpolation. By using a pair of test inputs and the corresponding pair of outputs, the result of this algorithm given by, : x = \\frac{b_1 x_2 - b_2 x_1}{b_1 - b_2}, would be memorized and carried out by rote. Indeed, the rule as given by Robert Recorde in his Ground of Artes (c. 1542) is: :::Gesse at this woorke as happe doth leade. :::By chaunce to truthe you may procede. :::And firste woorke by the question, :::Although no truthe therein be don. :::Suche falsehode is so good a grounde, :::That truth by it will soone be founde. :::: From many bate to many mo, :::From to fewe take to fewe also. :::With to much ioyne to fewe againe, :::To to fewe adde to manye plaine. :::In crossewaies multiplye contrary kinde, :::All truthe by falsehode for to fynde. For an affine linear function, :f(x) = ax + c , double false position provides the exact solution, while for a nonlinear function it provides an approximation that can be successively improved by iteration. ==History== The simple false position technique is found in cuneiform tablets from ancient Babylonian mathematics, and in papyri from ancient Egyptian mathematics.Jean-Luc Chabert, ed., A History of Algorithms: From the Pebble to the Microchip (Berlin: Springer, 1999), pp. 86-91. Double false position arose in late antiquity as a purely arithmetical algorithm. In the ancient Chinese mathematical text called The Nine Chapters on the Mathematical Art (\u4e5d\u7ae0\u7b97\u8853), dated from 200 BC to AD 100, most of Chapter 7 was devoted to the algorithm. There, the procedure was justified by concrete arithmetical arguments, then applied creatively to a wide variety of story problems, including one involving what we would call secant lines on a conic section. A more typical example is this \"joint purchase\" problem: > Now an item is purchased jointly; everyone contributes 8 [coins], the excess > is 3; everyone contributes 7, the deficit is 4. Tell: The number of people, > the item price, what is each? Answer: 7 people, item price 53.Shen Kangshen, > John N. Crossley and Anthony W.-C. Lun, 1999. The Nine Chapters on the > Mathematical Art: Companion and Commentary. Oxford: Oxford University Press, > p. 358. Between the 9th and 10th centuries, the Egyptian mathematician Abu Kamil wrote a now-lost treatise on the use of double false position, known as the Book of the Two Errors (Kit\u0101b al-kha\u1e6d\u0101\u02beayn). The oldest surviving writing on double false position from the Middle East is that of Qusta ibn Luqa (10th century), an Arab mathematician from Baalbek, Lebanon. He justified the technique by a formal, Euclidean-style geometric proof. Within the tradition of medieval Muslim mathematics, double false position was known as his\u0101b al-kha\u1e6d\u0101\u02beayn (\"reckoning by two errors\"). It was used for centuries to solve practical problems such as commercial and juridical questions (estate partitions according to rules of Quranic inheritance), as well as purely recreational problems. The algorithm was often memorized with the aid of mnemonics, such as a verse attributed to Ibn al-Yasamin and balance-scale diagrams explained by al-Hassar and Ibn al-Banna, all three being mathematicians of Moroccan origin. Available online at: http://facstaff.uindy.edu/~oaks/Biblio/COMHISMA8paper.doc and Leonardo of Pisa (Fibonacci) devoted Chapter 13 of his book Liber Abaci (AD 1202) to explaining and demonstrating the uses of double false position, terming the method regulis elchatayn after the al-kha\u1e6d\u0101\u02beayn method that he had learned from Arab sources. In 1494, Pacioli used the term el cataym in his book Summa de arithmetica, probably taking the term from Fibonacci. Other European writers would follow Pacioli and sometimes provided a translation into Latin or the vernacular. For instance, Tartaglia translates the Latinized version of Pacioli's term into the vernacular \"false positions\" in 1556. Pacioli's term nearly disappeared in the 16th century European works and the technique went by various names such as \"Rule of False\", \"Rule of Position\" and \"Rule of False Position\". Regula Falsi appears as the Latinized version of Rule of False as early as 1690. Several 16th century European authors felt the need to apologize for the name of the method in a science that seeks to find the truth. For instance, in 1568 Humphrey Baker says: ==Numerical analysis== The method of false position provides an exact solution for linear functions, but more direct algebraic techniques have supplanted its use for these functions. However, in numerical analysis, double false position became a root-finding algorithm used in iterative numerical approximation techniques. Many equations, including most of the more complicated ones, can be solved only by iterative numerical approximation. This consists of trial and error, in which various values of the unknown quantity are tried. That trial-and- error may be guided by calculating, at each step of the procedure, a new estimate for the solution. There are many ways to arrive at a calculated- estimate and regula falsi provides one of these. Given an equation, move all of its terms to one side so that it has the form, , where is some function of the unknown variable . A value that satisfies this equation, that is, , is called a root or zero of the function and is a solution of the original equation. If is a continuous function and there exist two points and such that and are of opposite signs, then, by the intermediate value theorem, the function has a root in the interval . There are many root-finding algorithms that can be used to obtain approximations to such a root. One of the most common is Newton's method, but it can fail to find a root under certain circumstances and it may be computationally costly since it requires a computation of the function's derivative. Other methods are needed and one general class of methods are the two-point bracketing methods. These methods proceed by producing a sequence of shrinking intervals , at the th step, such that contains a root of . ===Two-point bracketing methods=== These methods start with two -values, initially found by trial-and-error, at which has opposite signs. Under the continuity assumption, a root of is guaranteed to lie between these two values, that is to say, these values \"bracket\" the root. A point strictly between these two values is then selected and used to create a smaller interval that still brackets a root. If is the point selected, then the smaller interval goes from to the endpoint where has the sign opposite that of . In the improbable case that , a root has been found and the algorithm stops. Otherwise, the procedure is repeated as often as necessary to obtain an approximation to the root to any desired accuracy. The point selected in any current interval can be thought of as an estimate of the solution. The different variations of this method involve different ways of calculating this solution estimate. Preserving the bracketing and ensuring that the solution estimates lie in the interior of the bracketing intervals guarantees that the solution estimates will converge toward the solution, a guarantee not available with other root finding methods such as Newton's method or the secant method. The simplest variation, called the bisection method, calculates the solution estimate as the midpoint of the bracketing interval. That is, if at step , the current bracketing interval is , then the new solution estimate is obtained by, :c_k=\\frac{a_k+b_k}{2}. This ensures that is between and , thereby guaranteeing convergence toward the solution. Since the bracketing interval's length is halved at each step, the bisection method's error is, on average, halved with each iteration. The method gains roughly a decimal place of accuracy, for each 3 iterations. ===The regula falsi (false position) method=== The first two iterations of the false position method. The red curve shows the function and the blue lines are the secants. The convergence rate of the bisection method could possibly be improved by using a different solution estimate. The regula falsi method calculates the new solution estimate as the -intercept of the line segment joining the endpoints of the function on the current bracketing interval. Essentially, the root is being approximated by replacing the actual function by a line segment on the bracketing interval and then using the classical double false position formula on that line segment. More precisely, suppose that in the -th iteration the bracketing interval is . Construct the line through the points and , as illustrated. This line is a secant or chord of the graph of the function . In point-slope form, its equation is given by : y - f(b_k) = \\frac{f(b_k)-f(a_k)}{b_k-a_k} (x-b_k). Now choose to be the -intercept of this line, that is, the value of for which , and substitute these values to obtain : f(b_k) + \\frac{f(b_k)-f(a_k)}{b_k-a_k} (c_k-b_k) = 0. Solving this equation for ck gives: : c_k = b_k - f(b_k) \\frac{b_k- a_k}{f(b_k)-f(a_k)} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}. This last symmetrical form has a computational advantage: As a solution is approached, and will be very close together, and nearly always of the same sign. Such a subtraction can lose significant digits. Because and are always of opposite sign the \u201csubtraction\u201d in the numerator of the improved formula is effectively an addition (as is the subtraction in the denominator too). At iteration number , the number is calculated as above and then, if and have the same sign, set and , otherwise set and . This process is repeated until the root is approximated sufficiently well. The above formula is also used in the secant method, but the secant method always retains the last two computed points, and so, while it is slightly faster, it does not preserve bracketing and may not converge. The fact that regula falsi always converges, and has versions that do well at avoiding slowdowns, makes it a good choice when speed is needed. However, its rate of convergence can drop below that of the bisection method. ==Analysis== Since the initial end-points and are chosen such that and are of opposite signs, at each step, one of the end-points will get closer to a root of . If the second derivative of is of constant sign (so there is no inflection point) in the interval, then one endpoint (the one where also has the same sign) will remain fixed for all subsequent iterations while the converging endpoint becomes updated. As a result, unlike the bisection method, the width of the bracket does not tend to zero (unless the zero is at an inflection point around which ). As a consequence, the linear approximation to , which is used to pick the false position, does not improve as rapidly as possible. One example of this phenomenon is the function : f(x) = 2x^3-4x^2+3x on the initial bracket [\u22121,1]. The left end, \u22121, is never replaced (it does not change at first and after the first three iterations, is negative on the interval) and thus the width of the bracket never falls below 1. Hence, the right endpoint approaches 0 at a linear rate (the number of accurate digits grows linearly, with a rate of convergence of 2/3). For discontinuous functions, this method can only be expected to find a point where the function changes sign (for example at for or the sign function). In addition to sign changes, it is also possible for the method to converge to a point where the limit of the function is zero, even if the function is undefined (or has another value) at that point (for example at for the function given by when and by , starting with the interval [-0.5, 3.0]). It is mathematically possible with discontinuous functions for the method to fail to converge to a zero limit or sign change, but this is not a problem in practice since it would require an infinite sequence of coincidences for both endpoints to get stuck converging to discontinuities where the sign does not change, for example at in :f(x) = \\frac{1}{(x-1)^2} + \\frac{1}{(x+1)^2}. The method of bisection avoids this hypothetical convergence problem. ==Improvements in regula falsi== Though regula falsi always converges, usually considerably faster than bisection, there are situations that can slow its convergence \u2013 sometimes to a prohibitive degree. That problem isn't unique to regula falsi: Other than bisection, all of the numerical equation-solving methods can have a slow-convergence or no-convergence problem under some conditions. Sometimes, Newton's method and the secant method diverge instead of converging \u2013 and often do so under the same conditions that slow regula falsi's convergence. But, though regula falsi is one of the best methods, and even in its original un-improved version would often be the best choice; for example, when Newton's isn't used because the derivative is prohibitively time-consuming to evaluate, or when Newton's and Successive-Substitutions have failed to converge. Regula falsi's failure mode is easy to detect: The same end-point is retained twice in a row. The problem is easily remedied by picking instead a modified false position, chosen to avoid slowdowns due to those relatively unusual unfavorable situations. A number of such improvements to regula falsi have been proposed; two of them, the Illinois algorithm and the Anderson\u2013Bj\u00f6rk algorithm, are described below. ===The Illinois algorithm=== The Illinois algorithm halves the -value of the retained end point in the next estimate computation when the new -value (that is, )) has the same sign as the previous one ()), meaning that the end point of the previous step will be retained. Hence: : c_k = \\frac{\\frac{1}{2}f(b_k) a_k - f(a_k) b_k}{\\frac{1}{2}f(b_k) - f(a_k)} or : c_k = \\frac{f(b_k) a_k - \\frac{1}{2}f(a_k) b_k}{f(b_k) - \\frac{1}{2}f(a_k)}, down-weighting one of the endpoint values to force the next to occur on that side of the function. The factor \u00bd used above looks arbitrary, but it guarantees superlinear convergence (asymptotically, the algorithm will perform two regular steps after any modified step, and has order of convergence 1.442). There are other ways to pick the rescaling which give even better superlinear convergence rates. The above adjustment to regula falsi is called the Illinois algorithm by some scholars. Ford (1995) summarizes and analyzes this and other similar superlinear variants of the method of false position. ===Anderson\u2013Bj\u00f6rck algorithm=== Suppose that in the -th iteration the bracketing interval is and that the functional value of the new calculated estimate has the same sign as . In this case, the new bracketing interval and the left-hand endpoint has been retained. (So far, that's the same as ordinary Regula Falsi and the Illinois algorithm.) But, whereas the Illinois algorithm would multiply by , Anderson\u2013Bj\u00f6rck algorithm multiplies it by , where has one of the two following values: :m = 1 - \\frac{f(c_k)}{f(b_k)} if that value of is positive, otherwise, let m = \\frac{1}{2}. For simple roots, Anderson\u2013Bj\u00f6rck was the clear winner in Galdino's numerical tests. For multiple roots, no method was much faster than bisection. In fact, the only methods that were as fast as bisection were three new methods introduced by Galdino. But even they were only a little faster than bisection. ==Practical considerations== When solving one equation, or just a few, using a computer, the bisection method is an adequate choice. Although bisection isn't as fast as the other methods\u2014when they're at their best and don't have a problem\u2014bisection nevertheless is guaranteed to converge at a useful rate, roughly halving the error with each iteration - gaining roughly a decimal place of accuracy with every 3 iterations. For manual calculation, by calculator, one tends to want to use faster methods, and they usually, but not always, converge faster than bisection. But a computer, even using bisection, will solve an equation, to the desired accuracy, so rapidly that there's no need to try to save time by using a less reliable method\u2014and every method is less reliable than bisection. An exception would be if the computer program had to solve equations very many times during its run. Then the time saved by the faster methods could be significant. Then, a program could start with Newton's method, and, if Newton's isn't converging, switch to regula falsi, maybe in one of its improved versions, such as the Illinois or Anderson\u2013Bj\u00f6rck versions. Or, if even that isn't converging as well as bisection would, switch to bisection, which always converges at a useful, if not spectacular, rate. When the change in has become very small, and is also changing very little, then Newton's method most likely will not run into trouble, and will converge. So, under those favorable conditions, one could switch to Newton's method if one wanted the error to be very small and wanted very fast convergence. ==Example code== This example program, written in the C programming language, is an example of the Illinois algorithm. To find the positive number where , the equation is transformed into a root-finding form . #include #include double f(double x) { return cos(x) - x*x*x; } /* s,t: endpoints of an interval where we search e: half of upper bound for relative error m: maximal number of iterations */ double FalsiMethod(double s, double t, double e, int m) { double r,fr; int n, side=0; /* starting values at endpoints of interval */ double fs = f(s); double ft = f(t); for (n = 0; n < m; n++) { r = (fs*t - ft*s) / (fs - ft); if (fabs(t-s) < e*fabs(t+s)) break; fr = f(r); if (fr * ft > 0) { /* fr and ft have same sign, copy r to t */ t = r; ft = fr; if (side==-1) fs /= 2; side = -1; } else if (fs * fr > 0) { /* fr and fs have same sign, copy r to s */ s = r; fs = fr; if (side==+1) ft /= 2; side = +1; } else { /* fr * f_ very small (looks like zero) */ break; } } return r; } int main(void) { printf(\"%0.15f \", FalsiMethod(0, 1, 5E-15, 100)); return 0; } After running this code, the final answer is approximately 0.865474033101614. ==See also== * Ridders' method, another root-finding method based on the false position method * Brent's method ==References== ==Further reading== * Richard L. Burden, J. Douglas Faires (2000). Numerical Analysis, 7th ed. Brooks/Cole. . * L.E. Sigler (2002). Fibonacci's Liber Abaci, Leonardo Pisano's Book of Calculation. Springer-Verlag, New York. . Category:Root- finding algorithms Category:Latin words and phrases Category:Articles with example C code ",
    "title": "Regula falsi"
}