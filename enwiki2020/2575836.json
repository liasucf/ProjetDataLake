{
    "id": "2575836",
    "text": "In computer science, an abstract state machine (ASM) is a state machine operating on states that are arbitrary data structures (structure in the sense of mathematical logic, that is a nonempty set together with a number of functions (operations) and relations over the set). The ASM Method is a practical and scientifically well-founded systems engineering method that bridges the gap between the two ends of system development: * the human understanding and formulation of real-world problems (requirements capture by accurate high-level modeling at the level of abstraction determined by the given application domain) * the deployment of their algorithmic solutions by code-executing machines on changing platforms (definition of design decisions, system and implementation details). The method builds upon three basic concepts: * ASM: a precise form of pseudo-code, generalizing Finite State Machines to operate over arbitrary data structures * ground model: a rigorous form of blueprints, serving as authoritative reference model for the design * refinement: a most general scheme for stepwise instantiations of model abstractions to concrete system elements, providing controllable links between the more and more detailed descriptions at the successive stages of system development. In the original conception of ASMs, a single agent executes a program in a sequence of steps, possibly interacting with its environment. This notion was extended to capture distributed computations, in which multiple agents execute their programs concurrently. Since ASMs model algorithms at arbitrary levels of abstraction, they can provide high-level, low-level and mid-level views of a hardware or software design. ASM specifications often consist of a series of ASM models, starting with an abstract ground model and proceeding to greater levels of detail in successive refinements or coarsenings. Due to the algorithmic and mathematical nature of these three concepts, ASM models and their properties of interest can be analyzed using any rigorous form of verification (by reasoning) or validation (by experimentation, testing model executions). ==History== The concept of ASMs is due to Yuri Gurevich, who first proposed it in the mid-1980s as a way of improving on Turing's thesis that every algorithm is simulated by an appropriate Turing machine. He formulated the ASM Thesis: every algorithm, no matter how abstract, is step-for-step emulated by an appropriate ASM. In 2000, Gurevich axiomatized the notion of sequential algorithms, and proved the ASM thesis for them. Roughly stated, the axioms are as follows: states are structures, the state transition involves only a bounded part of the state, and everything is invariant under isomorphisms of structures. (Structures can be viewed as algebras, which explains the original name evolving algebras for ASMs.) The axiomatization and characterization of sequential algorithms have been extended to parallel and interactive algorithms. In the 1990s, by a community effort, the ASM method was developed, using ASMs for the formal specification and analysis (verification and validation) of computer hardware and software. Comprehensive ASM specifications of programming languages (including Prolog, C, and Java) and design languages (UML and SDL) have been developed. A detailed historical account can be found in the AsmBook (Chapter 9) or in this article. A number of software tools for ASM execution and analysis are available. ==Publications== ===Books=== * AsmBook: Egon B\u00f6rger, Robert St\u00e4rk. Abstract State Machines: A Method for High-Level System Design and Analysis * JBook: R.St\u00e4rk, J.Schmid, E.B\u00f6rger. Java and the Java Virtual Machine: Definition, Verification, Validation * Proceedings/Journal Issues (since 2000) ** 2008: Springer LNCS 5238 Abstract State Machines, B and Z ** 2007: J.UCS Special Issue with and http://osys.grm.hia.no/asm07/proceedings Selected Papers from ASM'07 ** 2006: Springer LNCS 5115 Rigorous Methods for Software Construction and Analysis, ASM and B Dagstuhl Seminar ** 2005: Fundamenta Informatica Special Issue with Selected Papers from ASM'05 (electronic proceedings) ** 2004: Springer LNCS 3052 Abstract State Machines 2004 ** 2003: Springer LNCS 2589 Abstract State Machines 2003: Advances in Theory and Practice ** 2003: TCS special Issue with Selected Papers from ASM'03 ** 2002: Dagstuhl Seminar Report Theory and Applications of Abstract State Machines ** 2001: J.UCS 7.11 Special Issue with Selected Papers from ASM'01 ** 2000: Springer LNCS 1912 Abstract State Machines: Theory and Applications * Comparative case studies with ASM contributions ** Steam-Boiler Control: Specification Case Study, Springer LNCS 1165 ** Production Cell: Software Development Case Study, ASM model ** Railcrossing: Formal Methods for Real-Time Computing, ASM model ** Light Control: Requirements Engineering Case Study, Dagstuhl Seminar ** Invoicing: Requirements Capture Case Study ===Behavioral models for industrial standards=== * OMG for BPMN (version 2006): Springer LNCS 5316 * OASIS for BPEL: IJBPMI 1.4 (2006) * ECMA for C#: \"A high-level modular definition of the semantics of C\u266f\" * ITU-T for SDL-2000: formal semantics of SDL-2000 and Formal Definition of SDL-2000 - Compiling and Running SDL Specifications as ASM Models * IEEE for VHDL93: E.Boerger, U.Glaesser, W.Mueller. Formal Definition of an Abstract VHDL'93 Simulator by EA-Machines. In: Carlos Delgado Kloos and Peter T.~Breuer (Eds.), Formal Semantics for VHDL, pp. 107\u2013139, Kluwer Academic Publishers, 1995 * ISO for Prolog: \"A mathematical definition of full Prolog\" ==Tools== (in historical order since 2000) *ASMETA, the Abstract State Machine Metamodel and its tool set *AsmL * CoreASM, available at CoreASM, an extensible ASM execution engine *AsmGofer *The XASM open source project ==References== * Y. Gurevich, Evolving Algebras 1993: Lipari Guide, E. B\u00f6rger (ed.), Specification and Validation Methods, Oxford University Press, 1995, 9-36. () * E. B\u00f6rger and R. St\u00e4rk, Abstract State Machines: A Method for High-Level System Design and Analysis, Springer-Verlag, 2003. () * R. St\u00e4rk, J. Schmid and E. B\u00f6rger, Java and the Java Virtual Machine: Definition, Verification, Validation, Springer-Verlag, 2001. () * Y. Gurevich, Sequential Abstract State Machines capture Sequential Algorithms, ACM Transactions on Computational Logic 1(1) (July 2000), 77-111. ==External links== *Abstract State Machines *AsmCenter *The TASM toolset: specification, simulation, and formal verification of real-time systems Category:Models of computation Category:Formal methods ",
    "title": "Abstract state machine"
}