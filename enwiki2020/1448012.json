{
    "id": "1448012",
    "text": "The Burroughs B6x00-7x00 instruction set includes the set of valid operations for the Burroughs B6500, B7500 and later Burroughs large systems, including the current (as of 2006) Unisys Clearpath/MCP systems; it does not include the instruction for other Burroughs large systems including the B5000, B5500, B5700 and the B8500. These unique machines have a distinctive design and instruction set. Each word of data is associated with a type, and the effect of an operation on that word can depend on the type. Further, the machines are stack based to the point that they had no user-addressable registers. As you would expect from the description of the run-time data structures used in these systems, they also have an interesting instruction set. Programs are made up of 8-bit syllables, which may be Name Call, be Value Call or form an operator, which may be from one to twelve syllables in length. There are less than 200 operators, all of which fit into 8-bit syllables. Many of these operators are polymorphic depending on the kind of data being acted on as given by the tag. If we ignore the powerful string scanning, transfer, and edit operators, the basic set is only about 120 operators. If we remove the operators reserved for the operating system such as MVST and HALT, the set of operators commonly used by user-level programs is less than 100. The Name Call and Value Call syllables contain address couples; the Operator syllables either use no addresses or use control words and descriptors on the stack. Since there are no programmer-addressable registers, most of the register manipulating operations required in other architectures are not needed, nor are variants for performing operations between pairs of registers, since all operations are applied to the top of the stack. This also makes code files very compact, since operators are zero-address and do not need to include the address of registers or memory locations in the code stream. For example, the instruction set has only one ADD operator. Typical architectures require multiple operators for each data type, for example add.i, add.f, add.d, add.l for integer, float, double, and long data types. The architecture only distinguishes single and double precision numbers - integers are just reals with a zero exponent. When one or both of the operands has a tag of 2, a double precision add is performed, otherwise tag 0 indicates single precision. Thus the tag itself is the equivalent of the operator .i, .f, .d, and .l extension. This also means that the code and data can never be mismatched. Two operators are important in the handling of on-stack data - VALC and NAMC. These are two-bit operators, 00 being VALC, value call, and 01 being NAMC, name call. The following six bits of the syllable, concatenated with the following syllable, provide the address couple. Thus VALC covers syllable values 0000 to 3FFF and NAMC 4000 to 7FFF. VALC is another polymorphic operator. If it hits a data word, that word is loaded to the top of stack. If it hits an IRW, that is followed, possibly in a chain of IRWs until a data word is found. If a PCW is found, then a function is entered to compute the value and the VALC does not complete until the function returns. NAMC simply loads the address couple onto the top of the stack as an IRW (with the tag automatically set to 1). Static branches (BRUN, BRFL, and BRTR) used two additional syllables of offset. Thus arithmetic operations occupied one syllable, addressing operations (NAMC and VALC) occupied two, branches three, and long literals (LT48) five. As a result, code was much denser (had better entropy) than a conventional RISC architecture in which each operation occupies four bytes. Better code density meant fewer instruction cache misses and hence better performance running large-scale code. In the following operator explanations remember that A and B are the top two stack registers. Double precision extensions are provided by the X and Y registers; thus the top two double precision operands are given by AX and BY. (Mostly AX and BY is implied by just A and B.) {| class=\"wikitable\" |+B6x00/7x00 Address Couple |- ! scope=\"col\" style=\"text-align: left;\" | Current LL ! scope=\"col\" style=\"text-align: left;\" | Lexical Level bits ! scope=\"col\" style=\"text-align: left;\" | Index bits |- | 0-1 || 13 || 12-0 |- | 2-3 || 13-12 || 11-0 |- | 4-7 || 13-11 || 10-0 |- | 8-15 || 13-10 || 9-0 |- | 16-31 || 13-9 || 8-0 |} ==Arithmetic operators== ; : Add top two stack operands (B := B + A or BY := BY + AX if double precision) ; : Subtract (B - A) ; : Multiply with single or double precision result ; : Extended multiply with forced double precision result ; : Divide with real result ; : Divide with integer result ; : Return remainder after division ; : Integerize truncated ; : Integerize rounded ; : Integerize rounded with double precision result ; : Change sign ; : Join two singles to form a double ; : Split a double to form two singles ; : Input convert destructive - convert BCD number to binary (for COBOL) ; : Input convert update - convert BCD number to binary (for COBOL) ; : Set to single precision rounded ; : Set to single precision truncated ; : Set to double precision ; : Pack destructive ; : Pack update ; : Unpack signed destructive ; : Unpack signed update ; : Unpack absolute destructive ; : Unpack, absolute update ; : Set external sign ; : Read and clear overflow flip flop ; : Read true/false flip flop ==Comparison operators== ; : Is B < A? ; : Is B >= A? ; : Is B > A? ; : Is B <= A? ; : Is B = A? ; : Is B <> A? ; : Does B have the same bit pattern as A, including the tag ==Logical operators== ; : Logical bitwise and of all bits in operands ; : Logical bitwise or of all bits in operands ; : Logical bitwise complement of all bits in operand ; : Logical bitwise equivalence of all bits in operands ==Branch and call operators== ; : Branch unconditional (offset given by following code syllables) ; : Dynamic branch unconditional (offset given in top of stack) ; : Branch if last result false (offset given by following code syllables) ; : Dynamic branch if last result false (offset given in top of stack) ; : Branch if last result true (offset given by following code syllables) ; : Dynamic branch if last result true (offset given in top of stack) ; : Exit current environment (terminate process) ; : Step and branch (used in loops; operand must be SIW) ; : Execute a procedure call as given by a tag 7 PCW, resulting in an RCW at D[n] + 1 ; : Return from current routine to place given by RCW at D[n] + 1 and remove the stack frame ==Bit and field operators== ; : Bit set (bit number given by syllable following instruction) ; : Dynamic bit set (bit number given by contents of B) ; : Bit reset (bit number given by syllable following instruction) ; : Dynamic bit reset (bit number given by contents of B) ; : Field isolate (field given in syllables following instruction) ; : Dynamic field isolate (field given in top of stack words) ; : Field transfer (field given in syllables following instruction) ; : Dynamic field transfer (field given in top of stack words) ; : Field insert (field given in syllables following instruction) ; : Dynamic field insert (field given in top of stack words) ; : Count binary ones in the top of stack word (A or AX) ; : Scale left ; : Dynamic scale left ; : Scale right ; : Dynamic scale right ; : Scale right save ; : Dynamic scale right save ; : Scale right final ; : Dynamic scale right final ; : Scale right round ; : Dynamic scale right round ==Literal operators== ; : Load following code word onto top of stack ; : Set top of stack to following 16 bits in code stream ; : Set top of stack to following code syllable ; : Shortcut for LT48 0 ; : Shortcut for LT48 1 ==Descriptor operators== ; : Index create a pointer (copy descriptor) from a base (MOM) descriptor ; : Index and load name (resulting in an indexed descriptor) ; : Index and load value (resulting in a data value) ; : Evaluate descriptor (follow address chain until data word or another descriptor found) ==Stack operators== ; : Push down stack register ; : Pop top of stack ; : Exchange top two words of stack ; : Rotate stack up (top three words) ; : Rotate stack down (top three words) ; : Duplicate top of stack ; :Mark stack (build a new stack frame resulting in an MSCW on the top, -- followed by NAMC to load the PCW, then parameter pushes as needed, then ENTR) ; : Insert an MSCW in the B register. ; : Fetch a value onto the stack as described above ; : Place an address couple (IRW stack address) onto the stack as described above ; : Convert an IRW as placed by NAMC into an SIRW which references data in another stack. ; : Move to stack (process switch only done in one place in the MCP) ==Store operators== ; : Store destructive (if the target word has an odd tag throw a memory protect interrupt, -- store the value in the B register at the memory addressed by the A register. -- Delete the value off the stack. ; : Store non-destructive (Same as STOD but value is not deleted - handy for F := G := H := J expressions). ; : Overwrite destructive, STOD ignoring read-only bit (for use in MCP only) ; : Overwrite non-destructive, STON ignoring read- only bit (for use in MCP only) ==Load operators== ; : Load the value given by the address (tag 5 or tag 1 word) on the top of stack. -- Follow an address chain if necessary. ; : Load transparent - load the word referenced by the address on the top of stack ==Transfer operators== These were used for string transfers usually until a certain character was detected in the source string. All these operators are protected from buffer overflows by being limited by the bounds in the descriptors. ; : Transfer while false, destructive (forget pointer) ; : Transfer while false, update (leave pointer at end of transfer for further transfers) ; : Transfer while true, destructive ; : Transfer while true, update ; : Transfer words, destructive ; : Transfer words, update ; : Transfer words, overwrite destructive ; : Transfer words, overwrite update ; : Translate - transfer a source buffer into a destination converting characters as given in a translate table. ; : Transfer while less, destructive ; : Transfer while less, update ; : Transfer while greater or equal, destructive ; : Transfer while greater or equal, update ; : Transfer while greater, destructive ; : Transfer while greater, update ; : Transfer while less or equal, destructive ; : Transfer while less or equal, update ; : Transfer while equal, destructive ; : Transfer while equal, update ; : Transfer while not equal, destructive ; : Transfer while not equal, update ; : Transfer unconditional, destructive ; : Transfer unconditional, update ==Scan operators== These were used for scanning strings useful in writing compilers. All these operators are protected from buffer overflows by being limited by the bounds in the descriptors. ; : Scan while false, destructive ; : String isolate ; : Scan while true, destructive ; : Scan while true, update ; : Scan while less, destructive ; : Scan while less, update ; : Scan while greater or equal, destructive ; : Scan while greater or equal, update ; : Scan while greater, destructive ; : Scan while greater, update ; : Scan while less or equal, destructive ; : Scan while less or equal, update ; : Scan while equal, destructive ; : Scan while equal, update ; : Scan while not equal, destructive ; : Scan while not equal, update ; : Compare characters less, destructive ; : Compare characters less, update ; : Compare characters greater or equal, destructive ; : Compare characters greater or equal, update ; : Compare character greater, destructive ; : Compare character greater, update ; : Compare characters less or equal, destructive ; : Compare characters less or equal, update ; : Compare character equal, destructive ; : Compare character equal, update ; : Compare characters not equal, destructive ; : Compare characters not equal, update ==System== ; : Set interval timer ; : Enable external interrupts ; : Disable external interrupts ; : Scan in - initiate IO read, this changed on different architectures ; : Scan out - initiate IO write, this changed on different architectures ; : Set tag (not allowed in user-level processes) ; : Read tag ; : Hardware pseudo operator ; : Set processor register (highly implementation dependent, only used in lower levels of MCP) ; : Read processor register (highly implementation dependent, only used in lower levels of MCP) ; : Make PCW ; : Halt the processor (operator requested or some unrecoverable condition has occurred) ==Other== ; : Escape to extended (variable instructions which were less frequent) ; : Occurs index builds an occurs index word used in loops ; : Linked list lookup - Follow a chain of linked words until a certain condition is met ; : Masked search for equal - Similar to LLLU, but testing a mask in the examined words for an equal value ; : Table enter edit destructive ; : Table enter edit, update ; : Execute single micro destructive ; : Execute single micro update ; : Execute single micro, single pointer update ; : No operation ; : Invalid operator (hex code FF) ;User operators : unassigned operators could cause interrupts into the operating system so that algorithms could be written to provide the required functionality ==Edit operators== These were special operators for sophisticated string manipulation, particularly for business applications. ; : Move with insert - insert characters in a string ; : Move with float ; : Skip forward source character ; : Skip reverse source characters ; : Reset float ; : End float ; : Move numeric unconditional ; : Move characters ; : Insert overpunch ; : Insert sign ; : Skip forward destination character ; : Skip reverse destination characters ; : Insert unconditional ; : Insert conditional ; : End edit ==Notes== ==References== Category:Instruction processing Category:Instruction set architectures Category:Instruction set listings ",
    "title": "Burroughs B6x00-7x00 instruction set"
}