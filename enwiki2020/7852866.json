{
    "id": "7852866",
    "text": "OPC Unified Architecture (OPC UA) is a machine to machine communication protocol for industrial automation developed by the OPC Foundation. Distinguishing characteristics are: * Based on a client server communication * Focus on communicating with industrial equipment and systems for data collection and control * Open - freely available and implementable under GPL 2.0 license https://opcfoundation.org/license/gpl.html * Cross-platform - not tied to one operating system or programming language * Service-oriented architecture (SOA) * Inherent complexity - in September 2020, the specification consisted of 3151 pages in 15 documents * Offers security functionality for authentication, authorization, integrity and confidentialityRoepert, Linus; Dahlmanns, Markus; Fink, Ina Berenice; Pennekamp, Jan; Henze, Martin https://www.comsys.rwth- aachen.de/fileadmin/papers/2020/2020-roepert-opcua-security.pdf Assessing the Security of OPC UA Deployments, 2020 * Integral information model, which is the foundation of the infrastructure necessary for information integration where vendors and organizations can model their complex data into an OPC UA namespace to take advantage of the rich service-oriented architecture of OPC UA. There are over 35 collaborations with the OPC Foundation currently. Key industries include pharmaceutical, oil and gas, building automation, industrial robotics, security, manufacturing and process control. == History == Although developed by the same organization, OPC UA differs significantly from its predecessor, Open Platform Communications (OPC). The Foundation's goal for OPC UA was to provide a path forward from the original OPC communications model (namely the Microsoft Windows-only process exchange COM/DCOM) that would better meet the emerging needs of industrial automation.Mahnke, Wolfgang; Leitner, Stefan-Helmut https://library.e.abb.com/public/75d70c47268d78bfc125762d00481f78/56-61%203M903_ENG72dpi.pdf OPC Unified Architecture - The future standard for communication and information modeling in automation], 3/2009 ABB Review 3/2009, page 56-61 After more than three years of specification work and another year for a prototype implementation, the first version of the Unified Architecture was released in 2006. The current version of the specification is on 1.04 (22 Nov 2017https://opcfoundation.org/developer-tools/specifications-unified- architecture). The new version of OPC UA now has added publish/subscribe in addition to the client/server communications infrastructure. == Innovations == Although the original binding to COM/DCOM helped OPC to distribute well, it had several drawbacks: * Frequent configuration issues with DCOM; * No configurable time-outs; * Microsoft Windows only; * Lower security; * No control over DCOM (COM/DCOM is kind of a black box, developers have no access to sources and therefore have to deal with bugs or insufficient implementations). These drawbacks along with a number of other considerations pushed the decision to develop a new and independent stack for OPC UA, which replaces COM/DCOM. The main characteristics of this communication stack were: * Multi-platform implementation, including portable ANSI C, Java and .NET implementations; * Scalability: from smart sensors and smart actuators to mainframes; * Multi-threaded, as well as single-threaded/single-task operation --necessary for porting the stack to embedded devices; * Security, based on new standards; * Configurable time-outs for each service; * Chunking of big datagrams. This communication stack reflects the beginning of various innovations. The OPC UA architecture is a service-oriented architecture (SOA) and is based on different logical levels. OPC Base Services are abstract method descriptions, which are protocol independent and provide the basis for OPC UA functionality. The transport layer puts these methods into a protocol, which means it serializes/deserializes the data and transmits it over the network. Two protocols are specified for this purpose. One is a binary TCP protocol, optimized for high performance and the second is Web service- oriented. The OPC information model is a so-called Full Mesh Network based on nodes. These nodes can include any kind of meta information, and are similar to the objects of object-oriented programming (OOP). A node can have attributes for read access (DA, HDA), methods that can be called (Commands), and triggered events that can be transmitted (AE, DataAccess, DataChange). Nodes hold process data as well all other types of metadata. The OPC namespace contains the type model. Client software can verify what Profiles a server supports. This is necessary to obtain information, if a server only supports DA functionality or additionally AE, HDA, etc. Additionally, information can be obtained about whether a server supports a given profile. New and important features of OPC UA are: * Redundancy support * Heartbeat for connections in both directions (to indicate whether the other end is \"alive\"). This means that both server and client recognize interrupts. * Buffering of data and acknowledgements of transmitted data. Lost connections don't lead to lost data anymore. Lost datagrams can be refetched. At the OPC UA DevCon in October 2006 in Munich the first prototypes were presented live. Various UA Servers have been shown on a Beckhoff programmable logic controller and an embedded test board from Euros. The Beckhoff PLC is based on Windows XP Embedded and the embedded controller is based on the real-time operating system Euros. The company Embedded Labs Ltd demonstrated an OPC UA Server based on their own C++ UA Stack executing on a single chip ARM microcontroller with 64kB RAM. In October 2012 the German Fraunhofer-Application Center IOSB-INA and the Institute for industrial Information Technologies (inIT) showed that an OPC UA server is scalable down to 15 kB RAM and 10 kB ROM and therefore usable at chip level.The world's smallest OPC UA server comes from Germany ==Protocols== OPC UA supports two protocols.Leitner, Stefan-Helmut; Mahnke, Wolfgang OPC UA \u2013 Service-oriented Architecture for Industrial Applications, 11/2006 Softwaretechnik-Trends This is visible to application programmers only via changes to the URL. The binary protocol is opc.tcp://Server and http://Server is for Web Service. Otherwise OPC UA works completely transparent to the API. The binary protocol offers the best performance/least overhead, takes minimum resources (no XML Parser, SOAP and HTTP required, which is important for embedded devices), offers best interoperability (binary is explicitly specified and allows fewer degrees of freedom during implementation) and uses a single arbitrarily choosable TCP port for communication easing tunneling or easy enablement through a firewall. The Web Service (SOAP) protocol is best supported from available tools, e.g., from Java or .NET environments, and is firewall-friendly, using standard HTTP(S) ports. Binary is supported by all implementations, while only .NET implementation supports SOAP. ==Specifications== The OPC UA specification is a multi-part specification and consists of the following parts: # Concepts # Security Model # Address Space Model # Services # Information Model # Mappings # Profiles # Data Access # Alarms and Conditions # Programs # Historical Access # Discovery and Global Services # Aggregates # PubSub In contrast to the COM-based specifications, the UA specifications are not pure application specifications. They describe typically UA internal mechanisms, which get handled through the communication stack and are normally only of interest for those that port a stack to a specific target or those that want to implement their own UA stack. The OPC UA application developers code against the OPC UA API and therefore mainly use API documentation. Nevertheless, part 3, 4, and 5 may be of interest for application developers.Massaro, Simone What is OPC UA and how does it affect your world?, 5/15/2008 planetengineering.com ==Discussion== The OPC UA protocol specification consists of 14 documents for a total of 1250 pages. Due to this complexity, existing implementations are usually incomplete. In addition, the existence of several serialization formats, as well as the possibility of selectively implementing certain services such as PubSub, eventually lead to a great heterogeneity of the OPC UA connection points. Under these conditions, it is finally difficult to develop client applications that are independent of the specific implementation of each server. In this sense, OPC UA does not achieve its promise of ensuring good interoperability of systems. This can be seen typically in factory and infrastructure projects integrating various PLC technologies, each delivered with a different and limited implementation of the OPC UA protocol. The specification is still evolving, the last specification document volume 14 is dated February 6, 2018, while the first publication of the standard OPC UA dates from 2006. As a result, despite considerable marketing efforts to support its adoption, OPC UA may be considered at this stage as a standardization attempt rather than an established standard. ==UA communication stack== The architecture of a UA application, independent of whether it is the server or client part, is structured into levels. Some parts equalize to the former COM Proxy/Stubs and get provided by the OPC Foundation. The portability level is new; it simplifies porting the UA ANSI C stack to other target platforms. A port layer for Windows and Linux is also provided by the OPC Foundation. ==UA security== UA Security consists of authentication and authorization, encryption and data integrity via signatures. For Web Services the WS-SecureConversation gets used and is therefore compatible to .NET and other SOAP implementations. For the binary variant, the algorithms of WS-SecureConversation have been followed and also converted to a binary equivalent. This is named as UA Secure Conversation. There is also a mixed version where the code is binary, but the transport layer is SOAP. This is a compromise between efficient binary coding and firewall-friendly transmission. Binary coding always requires UA Secure Conversation. The authentication uses X.509 certificates exclusively. It relies on the application developer to choose which certificate store the UA application gets bound to. For instance, it is possible to use the public key infrastructure (PKI) of an Active Directory. == Built-in data types == The OPC UA standard defines 25 built-in data types: {| class=\"wikitable\" |+ OPC UA built-in data types !Built-in type !C/C++ equivalent !Details !NodeId type |- |Boolean |bool |0/1 (true or false) | rowspan=\"11\" |0 (numeric) |- |SByte |int8_t | -128 to 127 |- |Byte |uint8_t |0 to 255 |- |Int16 |int16_t | -32768 to 32767 |- |UInt16 |uint16_t |0 to 65535 |- |Int32 |int32_t | -2147483648 to 2147483647 |- |UInt32 |uint32_t |0 to 4294967295 |- |Int64 |int64_t |-9223372036854775808 to 9223372036854775807 |- |UInt64 |uint64_t |0 to 18446744073709551615 |- |Float |float |IEEE single precision (32 bit) floating point value |- |Double |double |IEEE double precision (64 bit) floating point value |- |StatusCode |uint32_t | | |- |String |uint8_t* / std::string | |3 (string) |- |DateTime |int64_t |number of 100 nanosecond intervals since 1/1/1601 (UTC) | |- |GUID |implementation dependent |16-byte number used as a unique identifier |4 (GUID) |- |ByteString |(same as String) | |5 (byte string) |- |XmlElement |(same as String) | | |- |NodeId | |namespace index and NodeId type | |- |ExpandedNodeId | |(similar to NodeId) | |- |QualifiedName | |namespace index and string | |- |LocalizedText | |string and a locale indicator | |- |NumericRange | |string (e.g. \"0:4,1:5\" for [0..4][1..5] array) | |- |Variant | |(built-in data types only) | |- |ExtensionObject | |scalars of any type | |- |DataValue | |a composite of a value, timestamps and status code | |- |DiagnosticInfo | |detailed error/diagnostic information | |} ==OPC UA APIs== UA APIs are available in several programming languages. Commercial SDK are available for C, C++, Java, and .NET. Open-source stacks are available at least for C, C++, Java, Javascript(node) and Python . ===C++/C Implementation=== * The open62541 project provides an Open Source implementation for OPC UA server and clients and is licensed under the Mozilla Public License v2.0. Besides Linux and Windows, it also supports OS X, QNX and different embedded systems as compilation target. * The S2OPC project provides an Open Source secured implementation and is licensed under the Apache 2.0 license. It supports Linux, Windows, FreeRTOS, Zephyr, VxWorks and aims to be safe, secure and fast. The core of the software is formally designed with the help of the B-Method. * The ASNeG project provides a C++ open source (Apache License 2.0) OPC UA Application Server and an OPC UA Web Server (beta state, currently only base functions). * The FreeOpcUa project provides an open source (LGPL) server and client implementation in C++. * The UAF project offers an open source (LGPL) C++/Python implementation. ===.NET implementation=== The .NET implementation uses ANSI C for the lower levels and implements the rest natively in .NET. That means only the handling of the socket and the Message-Chunking gets integrated from the ANSI C stack. De- serialization takes place directly in .NET and therefore gets converted directly into .NET structures and objects. This provides better performance than de-serializing into a C structure first and then copying the data to a .NET structure afterwards. ===Java implementation=== Various stacks for Java were being developed. Similar to .NET, there are principally three variants: #Encapsulate the complete ANSI C stack via JNI, which complicates portability. Although the stack can be ported to different operating systems, it needs to get compiled for those individually. Also, the data needs to get copied to the JNI boundary, but benefits from the performance of C during de-serialization. #Code directly on the network layer (similar to the current .Net implementation) and de-serialize in Java. This saves one data copy execution, but still depends on the C stack. #Write a native Java OPC UA stack. This was observed to be the most portable, but estimated to take the most engineering effort to implement. The Eclipse Milo project provides a pure-Java, open- source, implementation of the UA 1.03 client and server specification. Alternatively, there is the simple variant to only support the WebService protocol. For that, a SOAP Toolkit that supports WS-Security is needed. === JavaScript implementation === node-opcua is a complete implementation of the OPC UA for client and server entirely writing in JavaScript for Node.js. === Python implementation === * The FreeOpcUa project provides two implementations in pure Python programming language - opcua-asyncio (requires Python >=3.7) and python-opcua (compatible with Python 2, 3 and pypy; it requires Cython for the lxml library, but is in maintainance mode and opcua-asyncio is recommended). Both provide high-level abstractions of an OPC UA client and server which can be used as is or readily extended for custom applications. * The S2OPC C-implementation provides a python wrapper PyS2OPC. === Rust implementation === Rust for OPC UA provides an API and samples for implementing OPC UA client and servers up to embedded profile level. This includes support for encryption, subscriptions and the default node set. === TypeScript / JavaScript implementation === TypeScript / JavaScript OPC UA client for the browser is an OPC UA client that works in the browser. It is completely written in TypeScript and compiled to JavaScript. The source code is publicly available and has an MIT license. It includes OPC UA binary data encoding and uses WebSockets as the transport protocol. == IEC 62541 == IEC 62541 is a standard for OPC Unified Architecture. {| class=\"wikitable\" style=\"text-align:left vertical-align:top\" |+ IEC 62541 Overview |- ! ID ! release date ! title |- style=\"vertical-align:top\" | IEC/TR 62541-1 | 2016 | OPC Unified Architecture - Part 1: Overview and Concepts |- style=\"vertical- align:top\" | IEC/TR 62541-2 | 2016 | OPC Unified Architecture - Part 2: Security Model |- style=\"vertical-align:top\" | IEC 62541-3 | 2020 | OPC Unified Architecture - Part 3: Address Space Model |- style=\"vertical- align:top\" | IEC 62541-4 | 2020 | OPC Unified Architecture - Part 4: Services |- style=\"vertical-align:top\" | IEC 62541-5 | 2020 | OPC Unified Architecture - Part 5: Information Model |- style=\"vertical-align:top\" | IEC 62541-6 | 2020 | OPC Unified Architecture - Part 6: Mappings |- |IEC 62541-7 |2020 |OPC Unified Architecture - Part 7: Profiles |- style=\"vertical-align:top\" | IEC 62541-8 | 2020 | OPC Unified Architecture - Part 8: Data Access |- |IEC 62541-9 |2020 |OPC Unified Architecture - Part 9: Alarms and Conditions |- |IEC 62541-10 |2020 |OPC Unified Architecture - Part 10: Programs |- |IEC 62541-11 |2020 |OPC Unified Architecture - Part 11: Historical Access |- |IEC 62541-12 |2020 |OPC unified architecture - Part 12: Discovery and global services |- |IEC 62541-13 |2020 |OPC Unified Architecture - Part 13: Aggregates |- |IEC 62541-14 |2020 |OPC unified architecture - Part 14: PubSub |- |IEC 62541-100 |2015 |OPC Unified Architecture - Part 100: Device Interface |} == See also == * OPC Data Access * OLE for process control * OPC Foundation == References == == Literature == * Wolfgang Mahnke, Stefan-Helmut Leitner, Matthias Damm: OPC Unified Architecture. Springer Verlag 2009; * Lange, J., Iwanitz, F., Burke, T. OPC From Data Access to Unified Architecture 2010; == External links == * OPC Foundation * Introduction to OPC UA based on the open source open62541 SDK * CECILL-C Licensed OPC UA implementation * Cross platform OPC UA development and free cross platform clients (Windows, Linux, Android, iOS) * Multiplatform OPC UA mySCADA running on Windows, Linux, MacOS, Android and iOS * Ignition Native Java OPC UA Stack * Introduction to OPC UA Address Space modelling * Node-OPCUA -OPC UA for nodejs - (MIT licence) * OPC UA for Android devices * OPC Unified Architecture e-Book * Open Source OPC UA SDK for Java * The FreeOpcUa project implement an open-source (LGPL) OPC UA stack and associated tools. * SDK for OPC UA (Java) and free client/server * The OPC Programmer's Connection * A Tale of Two Industrial IoT Standards: DDS and OPC UA * Woopsa - a protocol bringing functionalities similar to OPC UA to the Web * Communication in Industry 4.0 with Wolfram SystemModeler and OPC UA * OPC UA Gateway for Industry 4.0 * S2OPC open source safe OPC UA * A complete guide on OPC UA Category:Application programming interfaces Category:Automation Category:Computer standards ",
    "title": "OPC Unified Architecture"
}