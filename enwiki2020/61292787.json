{
    "id": "61292787",
    "text": "A Counting Bloom filter is a generalized data structure of Bloom filter, that is used to test whether a count number of a given element is smaller than a given threshold when a sequence of elements is given. As a generalized form of Bloom filter, false positive matches are possible, but false negatives are not \u2013 in other words, a query returns either \"possibly bigger or equal than the threshold\" or \"definitely smaller than the threshold\". == Algorithm description == Most of the parameters are defined same with Bloom filter, such as n, k. m is the number of counters in Counting Bloom filter, which is expansion of m bits in Bloom filter. An empty Counting Bloom filter is a m counters, all set to 0. Similar to Bloom filter, there must also be k different hash functions defined, each of which maps or hashes some set element to one of the m counter array positions, generating a uniform random distribution. It is also similar that k is a constant, much smaller than m, which is proportional to the number of elements to be added. The main generalization of Bloom filter is adding an element. To add an element, feed it to each of the k hash functions to get k array positions and increment the counters 1 at all these positions. To query for an element with a threshold \u03b8 (test whether the count number of an element is smaller than \u03b8), feed it to each of the k hash functions to get k counter positions. If any of the counters at these positions is less than \u03b8, the count number of element is definitely less than \u03b8 \u2013 if it were more and equal, then all the corresponding counters would have been greater or equal to \u03b8. If all are greater or equal to \u03b8, then either the count is really greater or equal to \u03b8, or the counters have by chance been greater or equal to \u03b8. If all are greater or equal to \u03b8 even though the count is smaller than \u03b8, this circumstance is defined as false positive. This also should be minimized like Bloom filter. About hashing problem and advantages, see Bloom filter. == Probability of false positives == The same assumptions in Bloom filter, which hash functions make insertions uniform random, is also assumed here. In the m pots, kn balls are inserted randomly. So the probability of one of counter in Counting Bloom filter counts l is b(l, kn, \\frac{1}{m}) = {kn \\choose l}(\\frac{1}{m})^l (1 - \\frac{1}{m})^{kn-l}, where b is binomial distribution. By the way, Counting Bloom filter determines an element is greater or equal to \u03b8 when the corresponding k counters are greater or equal to \u03b8. Therefore, the probability that Counting Bloom filter determines an element is greater or equal to \u03b8 is p_{fp}(\\theta, k, n, m) = (1 - \\sum\\limits_{l < \\theta} b(l, kn, \\frac{1}{m}))^k. This is different from formal definition of false positive in Counting Bloom filter. However, following the assumption in Bloom filter, above probability is defined as false positive of Counting Bloom filter. If \u03b8=1, the equation becomes false positive of Bloom filter. === Optimal number of hash functions === For large but fixed n and m, the false positive decreases from k=1 to a point defined k_{opt}, and increases from k_{opt}to positive infinity. Kim et al. (2019) shows numerical values of k_{opt}within 1\\leq\\theta\\leq30. If \u03b8 is bigger than 30, they suggested to use k_{opt}=\\lfloor\\frac{m}{n} (0.2037\\theta + 0.9176)\\rflooror k_{opt}=\\lceil\\frac{m}{n} (0.2037\\theta + 0.9176)\\rceil. == References == Category:Data structures Category:Hash based data structures ",
    "title": "Counting Bloom filter"
}