{
    "id": "61547718",
    "text": "An artificial neural network (ANN) combines biological principles with advanced statistics to solve problems in domains such as pattern recognition and game-play. ANNs adopt the basic model of neuron analogues connected to each other in a variety of ways. == Structure == === Neuron === A neuron with label j receiving an input p_j(t) from predecessor neurons consists of the following components: * an activation a_j(t), the neuron's state, depending on a discrete time parameter, * an optional threshold \\theta_j, which stays fixed unless changed by learning, * an activation function f that computes the new activation at a given time t+1 from a_j(t), \\theta_j and the net input p_j(t) giving rise to the relation :: a_j(t+1) = f(a_j(t), p_j(t), \\theta_j), * and an output function f_\\text{out} computing the output from the activation :: o_j(t) = f_\\text{out}(a_j(t)). Often the output function is simply the identity function. An input neuron has no predecessor but serves as input interface for the whole network. Similarly an output neuron has no successor and thus serves as output interface of the whole network. === Propagation function === The propagation function computes the input p_j(t) to the neuron j from the outputs o_i(t)and typically has the form : p_j(t) = \\sum_i o_i(t) w_{ij}. === Bias === A bias term can be added, changing the form to the following: : p_j(t) = \\sum_i o_i(t) w_{ij}+ w_{0j}, where w_{0j} is a bias. == Neural networks as functions == Neural network models can be viewed as defining a function that takes an input (observation) and produces an output (decision). \\textstyle f : X \\rightarrow Y or a distribution over \\textstyle X or both \\textstyle X and \\textstyle Y. Sometimes models are intimately associated with a particular learning rule. A common use of the phrase \"ANN model\" is really the definition of a class of such functions (where members of the class are obtained by varying parameters, connection weights, or specifics of the architecture such as the number of neurons, number of layers or their connectivity). Mathematically, a neuron's network function \\textstyle f(x) is defined as a composition of other functions \\textstyle g_i(x), that can further be decomposed into other functions. This can be conveniently represented as a network structure, with arrows depicting the dependencies between functions. A widely used type of composition is the nonlinear weighted sum, where \\textstyle f (x) = K \\left(\\sum_i w_i g_i(x)\\right) , where \\textstyle K (commonly referred to as the activation function) is some predefined function, such as the hyperbolic tangent, sigmoid function, softmax function, or rectifier function. The important characteristic of the activation function is that it provides a smooth transition as input values change, i.e. a small change in input produces a small change in output. The following refers to a collection of functions \\textstyle g_i as a vector \\textstyle g = (g_1, g_2, \\ldots, g_n). ANN dependency graph This figure depicts such a decomposition of \\textstyle f, with dependencies between variables indicated by arrows. These can be interpreted in two ways. The first view is the functional view: the input \\textstyle x is transformed into a 3-dimensional vector \\textstyle h, which is then transformed into a 2-dimensional vector \\textstyle g, which is finally transformed into \\textstyle f. This view is most commonly encountered in the context of optimization. The second view is the probabilistic view: the random variable \\textstyle F = f(G) depends upon the random variable \\textstyle G = g(H), which depends upon \\textstyle H=h(X), which depends upon the random variable \\textstyle X. This view is most commonly encountered in the context of graphical models. The two views are largely equivalent. In either case, for this particular architecture, the components of individual layers are independent of each other (e.g., the components of \\textstyle g are independent of each other given their input \\textstyle h). This naturally enables a degree of parallelism in the implementation. Two separate depictions of the recurrent ANN dependency graph Networks such as the previous one are commonly called feedforward, because their graph is a directed acyclic graph. Networks with cycles are commonly called recurrent. Such networks are commonly depicted in the manner shown at the top of the figure, where \\textstyle f is shown as dependent upon itself. However, an implied temporal dependence is not shown. == Backpropagation == Backpropagation training algorithms fall into three categories: * steepest descent (with variable learning rate and momentum, resilient backpropagation); * quasi-Newton (Broyden\u2013Fletcher\u2013Goldfarb\u2013Shanno, one step secant); * Levenberg\u2013Marquardt and conjugate gradient (Fletcher\u2013Reeves update, Polak\u2013Ribi\u00e9re update, Powell\u2013Beale restart, scaled conjugate gradient). === Algorithm === Let N be a network with e connections, m inputs and n outputs. Below, x_1,x_2,\\dots denotes vectors in \\mathbb{R}^m, y_1,y_2,\\dots vectors in \\mathbb{R}^n, and w_0, w_1, w_2, \\ldots vectors in \\mathbb{R}^e. These are called inputs, outputs and weights, respectively. The network corresponds to a function y = f_N(w, x) which, given a weight w, maps an input x to an output y. In supervised learning, a sequence of training examples (x_1,y_1), \\dots, (x_p, y_p) produces a sequence of weights w_0, w_1, \\dots, w_p starting from some initial weight w_0, usually chosen at random. These weights are computed in turn: first compute w_i using only (x_i, y_i, w_{i-1}) for i = 1, \\dots, p. The output of the algorithm is then w_p, giving a new function x \\mapsto f_N(w_p, x). The computation is the same in each step, hence only the case i = 1 is described. w_1 is calculated from (x_1, y_1, w_0) by considering a variable weight w and applying gradient descent to the function w\\mapsto E(f_N(w, x_1), y_1) to find a local minimum, starting at w = w_0. This makes w_1 the minimizing weight found by gradient descent. == Learning pseudocode == To implement the algorithm above, explicit formulas are required for the gradient of the function w \\mapsto E(f_N(w, x), y) where the function is E(y,y')= |y-y'|^2. The learning algorithm can be divided into two phases: propagation and weight update. === Propagation === Propagation involves the following steps: * Propagation forward through the network to generate the output value(s) * Calculation of the cost (error term) * Propagation of the output activations back through the network using the training pattern target to generate the deltas (the difference between the targeted and actual output values) of all output and hidden neurons. === Weight update === For each weight: * Multiply the weight's output delta and input activation to find the gradient of the weight. * Subtract the ratio (percentage) of the weight's gradient from the weight. The learning rate is the ratio (percentage) that influences the speed and quality of learning. The greater the ratio, the faster the neuron trains, but the lower the ratio, the more accurate the training. The sign of the gradient of a weight indicates whether the error varies directly with or inversely to the weight. Therefore, the weight must be updated in the opposite direction, \"descending\" the gradient. Learning is repeated (on new batches) until the network performs adequately. === Pseudocode === Pseudocode for a stochastic gradient descent algorithm for training a three-layer network (one hidden layer): initialize network weights (often small random values) do for each training example named ex do prediction = _neural-net-output_ (network, ex) // forward pass actual = _teacher-output_ (ex) compute error (prediction - actual) at the output units // backward pass // backward pass continued update network weights // input layer not modified by error estimate until error rate becomes acceptably low return the network The lines labeled \"backward pass\" can be implemented using the backpropagation algorithm, which calculates the gradient of the error of the network regarding the network's modifiable weights.Werbos, Paul J. (1994). The Roots of Backpropagation. From Ordered Derivatives to Neural Networks and Political Forecasting. New York, NY: John Wiley & Sons, Inc. == References == Category:Computational statistics Category:Classification algorithms Category:Computational neuroscience ",
    "title": "Mathematics of artificial neural networks"
}