{
    "id": "1448821",
    "text": "A comparison of the convergence of gradient descent with optimal step size (in green) and conjugate vector (in red) for minimizing a quadratic function associated with a given linear system. Conjugate gradient, assuming exact arithmetic, converges in at most n steps, where n is the size of the matrix of the system (here n = 2). In mathematics, the conjugate gradient method is an algorithm for the numerical solution of particular systems of linear equations, namely those whose matrix is symmetric and positive-definite. The conjugate gradient method is often implemented as an iterative algorithm, applicable to sparse systems that are too large to be handled by a direct implementation or other direct methods such as the Cholesky decomposition. Large sparse systems often arise when numerically solving partial differential equations or optimization problems. The conjugate gradient method can also be used to solve unconstrained optimization problems such as energy minimization. It was mainly developed by Magnus Hestenes and Eduard Stiefel, who programmed it on the Z4.Speiser, Ambros \"Konrad Zuse and the ERMETH: A worldwide comparison of architectures\" (\"Konrad Zuse und die ERMETH: Ein weltweiter Architektur-Vergleich\"), in: Hans Dieter Hellige (ed.): Geschichten der Informatik. Visionen, Paradigmen, Leitmotive. Berlin, Springer 2004, . p. 185. The biconjugate gradient method provides a generalization to non-symmetric matrices. Various nonlinear conjugate gradient methods seek minima of nonlinear equations. ==Description of the problem addressed by conjugate gradients== Suppose we want to solve the system of linear equations :\\mathbf{A}\\mathbf{x} = \\mathbf{b} for the vector x, where the known n \u00d7 n matrix A is symmetric (i.e., AT = A), positive-definite (i.e. xTAx > 0 for all non-zero vectors x in Rn), and real, and b is known as well. We denote the unique solution of this system by \\mathbf{x}_*. ==As a direct method== We say that two non-zero vectors u and v are conjugate (with respect to A) if : \\mathbf{u}^\\mathsf{T} \\mathbf{A} \\mathbf{v} = 0. Since A is symmetric and positive-definite, the left-hand side defines an inner product : \\mathbf{u}^\\mathsf{T} \\mathbf{A} \\mathbf{v} = \\langle \\mathbf{u}, \\mathbf{v} \\rangle_\\mathbf{A} := \\langle \\mathbf{A} \\mathbf{u}, \\mathbf{v}\\rangle = \\langle \\mathbf{u}, \\mathbf{A}^\\mathsf{T} \\mathbf{v}\\rangle = \\langle \\mathbf{u}, \\mathbf{A}\\mathbf{v}\\rangle. Two vectors are conjugate if and only if they are orthogonal with respect to this inner product. Being conjugate is a symmetric relation: if u is conjugate to v, then v is conjugate to u. Suppose that :P = \\\\{ \\mathbf{p}_1, \\dots, \\mathbf{p}_n \\\\} is a set of n mutually conjugate vectors (with respect to A). Then forms a basis for \\mathbb{R}^n, and we may express the solution of \\mathbf{Ax} = \\mathbf{b} in this basis: :\\mathbf{x}_* = \\sum^{n}_{i=1} \\alpha_i \\mathbf{p}_i. Based on this expansion we calculate: :\\mathbf{A} \\mathbf{x}_* = \\sum^{n}_{i=1} \\alpha_i \\mathbf{A} \\mathbf{p}_i. Left-multiplying by \\mathbf{p}_k^\\mathsf{T}: :\\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{x}_* = \\sum^{n}_{i=1} \\alpha_i \\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{p}_i, substituting \\mathbf{Ax_*} = \\mathbf{b} and \\mathbf{u}^\\mathsf{T} \\mathbf{A} \\mathbf{v} = \\langle \\mathbf{u}, \\mathbf{v} \\rangle_\\mathbf{A}: :\\mathbf{p}_k^\\mathsf{T} \\mathbf{b} = \\sum^{n}_{i=1} \\alpha_i \\left \\langle \\mathbf{p}_k, \\mathbf{p}_i \\right \\rangle_{\\mathbf{A}}, then \\mathbf{u}^\\mathsf{T} \\mathbf{v} = \\langle \\mathbf{u}, \\mathbf{v} \\rangle and using \\forall i eq k: \\langle \\mathbf{p}_k, \\mathbf{p}_i \\rangle_{\\mathbf{A}} = 0 yields :\\langle \\mathbf{p}_k, \\mathbf{b} \\rangle = \\alpha_k \\langle \\mathbf{p}_k, \\mathbf{p}_k \\rangle_{\\mathbf{A}}, which implies :\\alpha_k = \\frac{\\langle \\mathbf{p}_k, \\mathbf{b} \\rangle}{\\langle \\mathbf{p}_k, \\mathbf{p}_k \\rangle_\\mathbf{A}}. This gives the following method for solving the equation : find a sequence of n conjugate directions, and then compute the coefficients . ==As an iterative method== If we choose the conjugate vectors pk carefully, then we may not need all of them to obtain a good approximation to the solution . So, we want to regard the conjugate gradient method as an iterative method. This also allows us to approximately solve systems where n is so large that the direct method would take too much time. We denote the initial guess for by (we can assume without loss of generality that , otherwise consider the system Az = b \u2212 Ax0 instead). Starting with x0 we search for the solution and in each iteration we need a metric to tell us whether we are closer to the solution (that is unknown to us). This metric comes from the fact that the solution is also the unique minimizer of the following quadratic function : f(\\mathbf{x}) = \\tfrac12 \\mathbf{x}^\\mathsf{T} \\mathbf{A}\\mathbf{x} - \\mathbf{x}^\\mathsf{T} \\mathbf{b}, \\qquad \\mathbf{x}\\in\\mathbf{R}^n \\,. The existence of a unique minimizer is apparent as its second derivative is given by a symmetric positive-definite matrix : abla^2 f(\\mathbf{x}) = \\mathbf{A} \\,, and that the minimizer (use Df(x)=0) solves the initial problem is obvious from its first derivative : abla f(\\mathbf{x}) = \\mathbf{A} \\mathbf{x} - \\mathbf{b} \\,. This suggests taking the first basis vector p0 to be the negative of the gradient of f at x = x0. The gradient of f equals . Starting with an initial guess x0, this means we take p0 = b \u2212 Ax0. The other vectors in the basis will be conjugate to the gradient, hence the name conjugate gradient method. Note that p0 is also the residual provided by this initial step of the algorithm. Let rk be the residual at the kth step: : \\mathbf{r}_k = \\mathbf{b} - \\mathbf{Ax}_k. As observed above, rk is the negative gradient of f at x = xk, so the gradient descent method would require to move in the direction rk. Here, however, we insist that the directions pk be conjugate to each other. A practical way to enforce this, is by requiring that the next search direction be built out of the current residual and all previous search directions. The conjugation constraint is an orthonormal-type constraint and hence the algorithm bears resemblance to Gram-Schmidt orthonormalization. This gives the following expression: :\\mathbf{p}_{k} = \\mathbf{r}_{k} - \\sum_{i < k}\\frac{\\mathbf{p}_i^\\mathsf{T} \\mathbf{A} \\mathbf{r}_{k}}{\\mathbf{p}_i^\\mathsf{T}\\mathbf{A} \\mathbf{p}_i} \\mathbf{p}_i (see the picture at the top of the article for the effect of the conjugacy constraint on convergence). Following this direction, the next optimal location is given by : \\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k with : \\alpha_{k} = \\frac{\\mathbf{p}_k^\\mathsf{T} (\\mathbf{b} - \\mathbf{Ax}_k )}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k} = \\frac{\\mathbf{p}_{k}^\\mathsf{T} \\mathbf{r}_{k}}{\\mathbf{p}_{k}^\\mathsf{T} \\mathbf{A} \\mathbf{p}_{k}}, where the last equality follows from the definition of rk . The expression for \\alpha_k can be derived if one substitutes the expression for xk+1 into f and minimizing it w.r.t. \\alpha_k : \\begin{align} f(\\mathbf{x}_{k+1}) &= f(\\mathbf{x}_k + \\alpha_k \\mathbf{p}_k) =: g(\\alpha_k) \\\\\\ g'(\\alpha_k) &\\overset{!}{=} 0 \\quad \\Rightarrow \\quad \\alpha_{k} = \\frac{\\mathbf{p}_k^\\mathsf{T} (\\mathbf{b} - \\mathbf{Ax}_k)}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k} \\,. \\end{align} ===The resulting algorithm=== The above algorithm gives the most straightforward explanation of the conjugate gradient method. Seemingly, the algorithm as stated requires storage of all previous searching directions and residue vectors, as well as many matrix-vector multiplications, and thus can be computationally expensive. However, a closer analysis of the algorithm shows that ri is orthogonal to rj , i.e. \\mathbf{r}_i^\\mathsf{T} \\mathbf{r}_j=0 , for i \u2260 j. And pi is A-orthogonal to pj , i.e. \\mathbf{p}_i^\\mathsf{T}A \\mathbf{p}_j=0 , for i \u2260 j. This can be regarded that as the algorithm progresses, pi and ri span the same Krylov subspace. Where ri form the orthogonal basis with respect to standard inner product, and pi form the orthogonal basis with respect to inner product induced by A. Therefore, xk can be regarded as the projection of x on the Krylov subspace. The algorithm is detailed below for solving Ax = b where A is a real, symmetric, positive-definite matrix. The input vector x0 can be an approximate initial solution or 0. It is a different formulation of the exact procedure described above. :\\begin{align} & \\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 \\\\\\ & \\hbox{if } \\mathbf{r}_{0} \\text{ is sufficiently small, then return } \\mathbf{x}_{0} \\text{ as the result}\\\\\\ & \\mathbf{p}_0 := \\mathbf{r}_0 \\\\\\ & k := 0 \\\\\\ & \\text{repeat} \\\\\\ & \\qquad \\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A p}_k} \\\\\\ & \\qquad \\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k \\\\\\ & \\qquad \\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A p}_k \\\\\\ & \\qquad \\hbox{if } \\mathbf{r}_{k+1} \\text{ is sufficiently small, then exit loop} \\\\\\ & \\qquad \\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{r}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k} \\\\\\ & \\qquad \\mathbf{p}_{k+1} := \\mathbf{r}_{k+1} + \\beta_k \\mathbf{p}_k \\\\\\ & \\qquad k := k + 1 \\\\\\ & \\text{end repeat} \\\\\\ & \\text{return } \\mathbf{x}_{k+1} \\text{ as the result} \\end{align} This is the most commonly used algorithm. The same formula for is also used in the Fletcher\u2013Reeves nonlinear conjugate gradient method. ====Computation of alpha and beta==== In the algorithm, is chosen such that \\mathbf{r}_{k+1} is orthogonal to rk. The denominator is simplified from :\\alpha_k = \\frac{\\mathbf{r}_{k}^\\mathsf{T} \\mathbf{r}_{k}}{\\mathbf{r}_{k}^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k} = \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A p}_k} since \\mathbf{r}_{k+1} = \\mathbf{p}_{k+1}-\\mathbf{\\beta}_{k}\\mathbf{p}_{k}. The is chosen such that \\mathbf{p}_{k+1} is conjugated to pk. Initially, is :\\beta_k = - \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k} using :\\mathbf{r}_{k+1} = \\mathbf{r}_{k} - \\alpha_{k} \\mathbf{A} \\mathbf{p}_{k} and equivalently \\mathbf{A} \\mathbf{p}_{k} = \\frac{1}{\\alpha_{k}} (\\mathbf{r}_{k} - \\mathbf{r}_{k+1}), the numerator of is rewritten as : \\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k = \\frac{1}{\\alpha_k} \\mathbf{r}_{k+1}^\\mathsf{T} (\\mathbf{r}_k - \\mathbf{r}_{k+1}) = - \\frac{1}{\\alpha_k} \\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{r}_{k+1} because \\mathbf{r}_{k+1} and rk are orthogonal by design. The denominator is rewritten as : \\mathbf{p}_k^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k = (\\mathbf{r}_k + \\beta_{k-1} \\mathbf{p}_{k-1})^\\mathsf{T} \\mathbf{A} \\mathbf{p}_k = \\frac{1}{\\alpha_k} \\mathbf{r}_k^\\mathsf{T} (\\mathbf{r}_k - \\mathbf{r}_{k+1}) = \\frac{1}{\\alpha_k} \\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k using that the search directions pk are conjugated and again that the residuals are orthogonal. This gives the in the algorithm after cancelling . ====Example code in MATLAB / GNU Octave==== function x = conjgrad(A, b, x) r = b - A * x; p = r; rsold = r' * r; for i = 1:length(b) Ap = A * p; alpha = rsold / (p' * Ap); x = x + alpha * p; r = r - alpha * Ap; rsnew = r' * r; if sqrt(rsnew) < 1e-10 break; end p = r + (rsnew / rsold) * p; rsold = rsnew; end end ===Numerical example=== Consider the linear system Ax = b given by :\\mathbf{A} \\mathbf{x}= \\begin{bmatrix} 4 & 1 \\\\\\ 1 & 3 \\end{bmatrix} \\begin{bmatrix} x_1 \\\\\\ x_2 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\\\ 2 \\end{bmatrix}, we will perform two steps of the conjugate gradient method beginning with the initial guess :\\mathbf{x}_0 = \\begin{bmatrix} 2 \\\\\\ 1 \\end{bmatrix} in order to find an approximate solution to the system. ====Solution==== For reference, the exact solution is : \\mathbf{x} = \\begin{bmatrix} \\frac{1}{11} \\\\\\\\\\\\\\ \\frac{7}{11} \\end{bmatrix} \\approx \\begin{bmatrix} 0.0909 \\\\\\\\\\\\\\ 0.6364 \\end{bmatrix} Our first step is to calculate the residual vector r0 associated with x0. This residual is computed from the formula r0 = b - Ax0, and in our case is equal to :\\mathbf{r}_0 = \\begin{bmatrix} 1 \\\\\\ 2 \\end{bmatrix} - \\begin{bmatrix} 4 & 1 \\\\\\ 1 & 3 \\end{bmatrix} \\begin{bmatrix} 2 \\\\\\ 1 \\end{bmatrix} = \\begin{bmatrix}-8 \\\\\\ -3 \\end{bmatrix} = \\mathbf{p}_0. Since this is the first iteration, we will use the residual vector r0 as our initial search direction p0; the method of selecting pk will change in further iterations. We now compute the scalar using the relationship : \\alpha_0 = \\frac{\\mathbf{r}_0^\\mathsf{T} \\mathbf{r}_0}{\\mathbf{p}_0^\\mathsf{T} \\mathbf{A p}_0} = \\frac{\\begin{bmatrix} -8 & -3 \\end{bmatrix} \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix}}{ \\begin{bmatrix} -8 & -3 \\end{bmatrix} \\begin{bmatrix} 4 & 1 \\\\\\ 1 & 3 \\end{bmatrix} \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix} } =\\frac{73}{331}. We can now compute x1 using the formula :\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0\\mathbf{p}_0 = \\begin{bmatrix} 2 \\\\\\ 1 \\end{bmatrix} + \\frac{73}{331} \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix} = \\begin{bmatrix} 0.2356 \\\\\\ 0.3384 \\end{bmatrix}. This result completes the first iteration, the result being an \"improved\" approximate solution to the system, x1. We may now move on and compute the next residual vector r1 using the formula :\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 \\mathbf{A} \\mathbf{p}_0 = \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix} - \\frac{73}{331} \\begin{bmatrix} 4 & 1 \\\\\\ 1 & 3 \\end{bmatrix} \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix} = \\begin{bmatrix} -0.2810 \\\\\\ 0.7492 \\end{bmatrix}. Our next step in the process is to compute the scalar that will eventually be used to determine the next search direction p1. :\\beta_0 = \\frac{\\mathbf{r}_1^\\mathsf{T} \\mathbf{r}_1}{\\mathbf{r}_0^\\mathsf{T} \\mathbf{r}_0} = \\frac{\\begin{bmatrix} -0.2810 & 0.7492 \\end{bmatrix} \\begin{bmatrix} -0.2810 \\\\\\ 0.7492 \\end{bmatrix}}{\\begin{bmatrix} -8 & -3 \\end{bmatrix} \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix}} = 0.0088. Now, using this scalar , we can compute the next search direction p1 using the relationship :\\mathbf{p}_1 = \\mathbf{r}_1 + \\beta_0 \\mathbf{p}_0 = \\begin{bmatrix} -0.2810 \\\\\\ 0.7492 \\end{bmatrix} + 0.0088 \\begin{bmatrix} -8 \\\\\\ -3 \\end{bmatrix} = \\begin{bmatrix} -0.3511 \\\\\\ 0.7229 \\end{bmatrix}. We now compute the scalar using our newly acquired p1 using the same method as that used for . : \\alpha_1 = \\frac{\\mathbf{r}_1^\\mathsf{T} \\mathbf{r}_1}{\\mathbf{p}_1^\\mathsf{T} \\mathbf{A p}_1} = \\frac{\\begin{bmatrix} -0.2810 & 0.7492 \\end{bmatrix} \\begin{bmatrix} -0.2810 \\\\\\ 0.7492 \\end{bmatrix}}{ \\begin{bmatrix} -0.3511 & 0.7229 \\end{bmatrix} \\begin{bmatrix} 4 & 1 \\\\\\ 1 & 3 \\end{bmatrix} \\begin{bmatrix} -0.3511 \\\\\\ 0.7229 \\end{bmatrix} } = 0.4122. Finally, we find x2 using the same method as that used to find x1. :\\mathbf{x}_2 = \\mathbf{x}_1 + \\alpha_1 \\mathbf{p}_1 = \\begin{bmatrix} 0.2356 \\\\\\ 0.3384 \\end{bmatrix} + 0.4122 \\begin{bmatrix} -0.3511 \\\\\\ 0.7229 \\end{bmatrix} = \\begin{bmatrix} 0.0909 \\\\\\ 0.6364 \\end{bmatrix}. The result, x2, is a \"better\" approximation to the system's solution than x1 and x0. If exact arithmetic were to be used in this example instead of limited-precision, then the exact solution would theoretically have been reached after n = 2 iterations (n being the order of the system). ==Convergence properties== The conjugate gradient method can theoretically be viewed as a direct method, as it produces the exact solution after a finite number of iterations, which is not larger than the size of the matrix, in the absence of round-off error. However, the conjugate gradient method is unstable with respect to even small perturbations, e.g., most directions are not in practice conjugate, and the exact solution is never obtained. Fortunately, the conjugate gradient method can be used as an iterative method as it provides monotonically improving approximations \\mathbf{x}_{k} to the exact solution, which may reach the required tolerance after a relatively small (compared to the problem size) number of iterations. The improvement is typically linear and its speed is determined by the condition number \\kappa(A) of the system matrix A: the larger \\kappa(A) is, the slower the improvement. If \\kappa(A) is large, preconditioning is used to replace the original system \\mathbf{A x}-\\mathbf{b} = 0 with \\mathbf{M}^{-1}(\\mathbf{A x}-\\mathbf{b}) = 0 such that \\kappa(\\mathbf{M}^{-1}\\mathbf{A}) is smaller than \\kappa(\\mathbf{A}), see below. === Convergence theorem === Define a subset of polynomials as : \\Pi_k^* := \\left\\lbrace \\ p \\in \\Pi_k \\ : \\ p(0)=1 \\ \\right\\rbrace \\,, where \\Pi_k is the set of polynomials of maximal degree k . Let \\left( \\mathbf{x}_k \\right)_k be the iterative approximations of the exact solution \\mathbf{x}_* , and define the errors as \\mathbf{e}_k := \\mathbf{x}_k - \\mathbf{x}_* . Now, the rate of convergence can be approximated as : \\begin{align} \\left\\| \\mathbf{e}_k \\right\\|_\\mathbf{A} &= \\min_{p \\in \\Pi_k^*} \\left\\| p(\\mathbf{A}) \\mathbf{e}_0 \\right\\|_\\mathbf{A} \\\\\\ &\\leq \\min_{p \\in \\Pi_k^*} \\, \\max_{ \\lambda \\in \\sigma(\\mathbf{A})} | p(\\lambda) | \\ \\left\\| \\mathbf{e}_0 \\right\\|_\\mathbf{A} \\\\\\ &\\leq 2 \\left( \\frac{ \\sqrt{\\kappa(\\mathbf{A})}-1 }{ \\sqrt{\\kappa(\\mathbf{A})}+1 } \\right)^k \\ \\left\\| \\mathbf{e}_0 \\right\\|_\\mathbf{A} \\,, \\end{align} where \\sigma(\\mathbf{A}) denotes the spectrum, and \\kappa(\\mathbf{A}) denotes the condition number. Note, the important limit when \\kappa(\\mathbf{A}) tends to \\infty : \\frac{ \\sqrt{\\kappa(\\mathbf{A})}-1 }{ \\sqrt{\\kappa(\\mathbf{A})}+1 } \\approx 1 - \\frac{2}{\\sqrt{\\kappa(\\mathbf{A})}} \\quad \\text{for} \\quad \\kappa(\\mathbf{A}) \\gg 1 \\,. This limit shows a faster convergence rate compared to the iterative methods of Jacobi or Gauss\u2013Seidel which scale as \\approx 1 - \\frac{2}{\\kappa(\\mathbf{A})} . ==The preconditioned conjugate gradient method== In most cases, preconditioning is necessary to ensure fast convergence of the conjugate gradient method. The preconditioned conjugate gradient method takes the following form: :\\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 :\\mathbf{z}_0 := \\mathbf{M}^{-1} \\mathbf{r}_0 :\\mathbf{p}_0 := \\mathbf{z}_0 :k := 0 \\, :repeat ::\\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k}{\\mathbf{p}_k^\\mathsf{T} \\mathbf{A p}_k} ::\\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{p}_k ::\\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A p}_k ::if rk+1 is sufficiently small then exit loop end if ::\\mathbf{z}_{k+1} := \\mathbf{M}^{-1} \\mathbf{r}_{k+1} ::\\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{z}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k} ::\\mathbf{p}_{k+1} := \\mathbf{z}_{k+1} + \\beta_k \\mathbf{p}_k ::k := k + 1 \\, :end repeat :The result is xk+1 The above formulation is equivalent to applying the conjugate gradient method without preconditioning to the system :\\mathbf{E}^{-1}\\mathbf{A}(\\mathbf{E}^{-1})^\\mathsf{T}\\mathbf{\\hat{x}}=\\mathbf{E}^{-1}\\mathbf{b} where :\\mathbf{EE}^\\mathsf{T}=\\mathbf{M}, \\qquad \\mathbf{\\hat{x}}=\\mathbf{E}^\\mathsf{T}\\mathbf{x}. The preconditioner matrix M has to be symmetric positive-definite and fixed, i.e., cannot change from iteration to iteration. If any of these assumptions on the preconditioner is violated, the behavior of the preconditioned conjugate gradient method may become unpredictable. An example of a commonly used preconditioner is the incomplete Cholesky factorization. ==The flexible preconditioned conjugate gradient method== In numerically challenging applications, sophisticated preconditioners are used, which may lead to variable preconditioning, changing between iterations. Even if the preconditioner is symmetric positive-definite on every iteration, the fact that it may change makes the arguments above invalid, and in practical tests leads to a significant slow down of the convergence of the algorithm presented above. Using the Polak\u2013Ribi\u00e8re formula :\\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\left(\\mathbf{z}_{k+1}-\\mathbf{z}_{k}\\right)}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k} instead of the Fletcher\u2013Reeves formula :\\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{z}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k} may dramatically improve the convergence in this case. This version of the preconditioned conjugate gradient method can be called flexible, as it allows for variable preconditioning. The flexible version is also shownHenricus Bouwmeester, Andrew Dougherty, Andrew V Knyazev. Nonsymmetric Preconditioning for Conjugate Gradient and Steepest Descent Methods. Procedia Computer Science, Volume 51, Pages 276-285, Elsevier, 2015. https://doi.org/10.1016/j.procs.2015.05.241 to be robust even if the preconditioner is not symmetric positive definite (SPD). The implementation of the flexible version requires storing an extra vector. For a fixed SPD preconditioner, \\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{z}_{k}=0, so both formulas for are equivalent in exact arithmetic, i.e., without the round-off error. The mathematical explanation of the better convergence behavior of the method with the Polak\u2013Ribi\u00e8re formula is that the method is locally optimal in this case, in particular, it does not converge slower than the locally optimal steepest descent method. ===Example code in MATLAB / GNU Octave=== function [x, k] = cgp(x0, A, C, b, mit, stol, bbA, bbC) % Synopsis: % x0: initial point % A: Matrix A of the system Ax=b % C: Preconditioning Matrix can be left or right % mit: Maximum number of iterations % stol: residue norm tolerance % bbA: Black Box that computes the matrix-vector product for A * u % bbC: Black Box that computes: % for left-side preconditioner : ha = C \\ ra % for right-side preconditioner: ha = C * ra % x: Estimated solution point % k: Number of iterations done % % Example: % tic;[x, t] = cgp(x0, S, speye(1), b, 3000, 10^-8, @(Z, o) Z*o, @(Z, o) o);toc % Elapsed time is 0.550190 seconds. % % Reference: % M\u00e9todos iterativos tipo Krylov para sistema lineales % B. Molina y M. Raydan - if nargin < 8, error('Not enough input arguments. Try help.'); end; if isempty(A), error('Input matrix A must not be empty.'); end; if isempty(C), error('Input preconditioner matrix C must not be empty.'); end; x = x0; ha = 0; hp = 0; hpp = 0; ra = 0; rp = 0; rpp = 0; u = 0; k = 0; ra = b - bbA(A, x0); % <\\--- ra = b - A * x0; while norm(ra, inf) > stol ha = bbC(C, ra); % <\\--- ha = C \\ ra; k = k + 1; if (k == mit), warning('GCP:MAXIT', 'mit reached, no conversion.'); return; end; hpp = hp; rpp = rp; hp = ha; rp = ra; t = rp' * hp; if k == 1 u = hp; else u = hp + (t / (rpp' * hpp)) * u; end; Au = bbA(A, u); % <\\--- Au = A * u; a = t / (u' * Au); x = x + a * u; ra = rp - a * Au; end; ==Vs. the locally optimal steepest descent method== In both the original and the preconditioned conjugate gradient methods one only needs to set \\beta_k := 0 in order to make them locally optimal, using the line search, steepest descent methods. With this substitution, vectors are always the same as vectors , so there is no need to store vectors . Thus, every iteration of these steepest descent methods is a bit cheaper compared to that for the conjugate gradient methods. However, the latter converge faster, unless a (highly) variable and/or non-SPD preconditioner is used, see above. ==Derivation of the method== The conjugate gradient method can be derived from several different perspectives, including specialization of the conjugate direction method for optimization, and variation of the Arnoldi/Lanczos iteration for eigenvalue problems. Despite differences in their approaches, these derivations share a common topic\u2014proving the orthogonality of the residuals and conjugacy of the search directions. These two properties are crucial to developing the well-known succinct formulation of the method. The conjugate gradient method can also be derived using optimal control theory.Ross, I. M., \"An Optimal Control Theory for Accelerated Optimization,\" , 2019. In this approach, the conjugate gradient method falls out as an optimal feedback controller,u = k(x, v):= -\\gamma_a abla f(x) - \\gamma_b v for the double integrator system,\\dot x = v, \\quad \\dot v = u The quantities \\gamma_a and \\gamma_b are variable feedback gains. ==Conjugate gradient on the normal equations== The conjugate gradient method can be applied to an arbitrary n-by-m matrix by applying it to normal equations ATA and right-hand side vector ATb, since ATA is a symmetric positive-semidefinite matrix for any A. The result is conjugate gradient on the normal equations (CGNR). : ATAx = ATb As an iterative method, it is not necessary to form ATA explicitly in memory but only to perform the matrix-vector and transpose matrix-vector multiplications. Therefore, CGNR is particularly useful when A is a sparse matrix since these operations are usually extremely efficient. However the downside of forming the normal equations is that the condition number \u03ba(ATA) is equal to \u03ba2(A) and so the rate of convergence of CGNR may be slow and the quality of the approximate solution may be sensitive to roundoff errors. Finding a good preconditioner is often an important part of using the CGNR method. Several algorithms have been proposed (e.g., CGLS, LSQR). The LSQR algorithm purportedly has the best numerical stability when A is ill- conditioned, i.e., A has a large condition number. ==See also== * Biconjugate gradient method (BiCG) * Conjugate residual method * Gaussian belief propagation * Iterative method: Linear systems * Krylov subspace * Nonlinear conjugate gradient method * Preconditioning * Sparse matrix-vector multiplication ==References== ==Further reading== * * * * ==External links== * Category:Numerical linear algebra Category:Gradient methods Category:Articles with example MATLAB/Octave code ",
    "title": "Conjugate gradient method"
}