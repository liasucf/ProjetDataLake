{
    "id": "31305228",
    "text": "ACE (Advanced Cryptographic Engine) \u2014 the collection of units, implementing both a public key encryption scheme and a digital signature scheme. Corresponding names for these schemes \u2014 \u00abACE Encrypt\u00bb and \u00abACE Sign\u00bb. Schemes are based on Cramer-Shoup public key encryption scheme and Cramer-Shoup signature scheme. Introduced variants of these schemes are intended to achieve a good balance between performance and security of the whole encryption system. == Authors == All the algorithms, implemented in ACE are based on algorithms developed by Victor Shoup and Ronald Cramer. The full algorithms specification is written by Victor Shoup. Implementation of algorithms is done by Thomas Schweinberger and Mehdi Nassehi, its supporting and maintaining is done by Victor Shoup. Thomas Schweinberger participated in construction of ACE specification document and also wrote a user manual. Ronald Cramer currently stays in the university of Aarhus, Denmark. He worked on the project of ACE Encrypt while his staying in ETH in Z\u00fcrich, Switzerland. Mehdi Nassehi and Thomas Schweinberger worked on ACE project in the IBM research lab in Z\u00fcrich, Switzerland. Victor Shoup works in the IBM research lab in Z\u00fcrich, Switzerland. == Security == The encryption scheme in ACE can be proven secure under reasonable and natural intractability assumptions. These four assumptions are: * The Decisional Diffie-Hellman (DDH) assumption * Strong RSA assumption * SHA-1 second preimage collision resistance * MARS sum/counter mode pseudo-randomness == Basic Terminology and Notation == Here we introduce some notations, being used in this article. === Basic mathematical notation === Z\\, \u2014 The set of integers. F_2[T]\\, \u2014 The set of univariate polynomials with coefficients in the finite field F_2\\, of cardinality 2. A rem n\\, \u2014 integer r \\in \\left\\\\{0,...,n-1\\right\\\\} such that A\\equiv r(mod n) for integer n>0\\, and A \\in Z\\,. A rem f\\, \u2014 polynomial r \\in F_2[T] with deg(r) such that A\\equiv r(mod f) with A,f \\in F_2[T],f e 0\\,. === Basic string notation === A^{\\ast}\\, \u2014 The set of all strings. A^{n}\\, \u2014 The set of all strings with length n. For x \\in A^{\\ast} L(x) \u2014 length of string x\\,. The string of length zero is denoted \\lambda_A\\,. For x,y \\in A^{\\ast} x||y\\, \u2014 the result of x\\, and y\\, concatenation. === Bits, Bytes, Words === b\\stackrel{\\mathrm{def}}{=}\\left\\\\{0,1\\right\\\\} \u2014 The set of bits. Let us take all sets of form b, b^{n_1}, (b^{n_1})^{n_2},.... For such a set A we define the \"zero element\": 0_b\\stackrel{\\mathrm{def}}{=}0 \\in b; 0_{A^n}\\stackrel{\\mathrm{def}}{=}(0_A,...,0_A) \\in A^n for n>0\\,. We define B\\stackrel{\\mathrm{def}}{=}b^8 as a set of bytes, and W\\stackrel{\\mathrm{def}}{=}b^{32} as a set of words. For x \\in A^{\\ast}\\, with A \\in \\left\\\\{b,B,W\\right\\\\}\\, and l>0\\, we define a padding operator: pad_l(x) \\stackrel{\\mathrm{def}}{=} \\begin{cases} x, & L(x) \\ge l \\\\\\ x||0_{A^{l-L(x)}}, & L(x). === Conversion operator === Conversion operator I_{src}^{dst}: src \\rightarrow dst makes a conversion between elements Z,F_2[T],b^{\\ast},B^{\\ast},W^{\\ast}. == Encryption Scheme == === Encryption Key Pair === The encryption scheme employs two key types: ACE public key: (P,q,g_1,g_2,c,d,h_1,h_2,k_1,k_2)\\,. ACE private key: (w,x,y,z_1,z_2)\\,. For a given size parameter m m\\,, such that 1024 \\le m \\le 16384, key components are defined as: q\\, \u2014 a 256-bit prime number. P\\, \u2014 a m-bit prime number, such that P\\equiv1(mod q). g_1,g_2,c,d,h_1,h_2\\, \u2014 elements \\left\\\\{1,...,P-1\\right\\\\} (whose multiplicative order modulo P\\, divides q\\,). w,x,y,z_1,z_2\\, \u2014 elements \\left\\\\{0,...,q-1\\right\\\\}. k_1,k_2\\, \u2014 elements B^\\ast with L(k_1)=20l^\\prime+64 and L(k_2)=32\\left\\lceil l/16 \\right\\rceil+40, where l=\\left\\lceil m/8 \\right\\rceil and l^\\prime=L_b(\\left\\lceil (2\\left\\lceil l/4 \\right\\rceil +4)/16 \\right\\rceil). === Key Generation === Algorithm. Key Generation for ACE encryption scheme. Input: a size parameter m m\\,, such that 1024 \\le m \\le 16384. Output: a public/private key pair. # Generate a random prime q\\,, such that 2^{255} < q < 2^{256}\\,. # Generate a random prime P\\,, 2^{m-1} < P < 2^{m}\\,, such that P\\equiv1(mod q). # Generate a random integer g_1 \\in \\left\\\\{ 2,...,P-1 \\right\\\\}, such that g_1^q\\equiv1(mod P). # Generate random integers w \\in \\left\\\\{ 1,...,q-1 \\right\\\\} and x,y,z_1,z_2 \\in \\left\\\\{ 0,...,q-1 \\right\\\\} # Compute the following integers in \\left\\\\{ 1,...,P-1 \\right\\\\}:g_2 \\leftarrow g_1^w rem P, c \\leftarrow g_1^x rem P, d \\leftarrow g_1^y rem P, h_1 \\leftarrow g_1^{z_1} rem P, h_2 \\leftarrow g_1^{z_2} rem P. # Generate random byte strings k_1 \\in B^{20l^\\prime+64} and k_2 \\in B^{2\\left\\lceil l/16 \\right\\rceil+40}, where l=L_B(P)\\, and l^\\prime = L_B(\\left\\lceil (2\\left\\lceil l/4 \\right\\rceil +4)/16 \\right\\rceil). # Return the public key/private key pair ((P,q,g_1,g_2,c,d,h_1,h_2,k_1,k_2),(w,x,y,z_1,z_2))\\, === Ciphertext Representation === A ciphertext of the ACE encryption scheme has the form (s,u_1,u_2,v,e)\\,, where the components are defined as: u_1,u_2,v\\, \u2014 integers from \\left\\\\{ 1,...,P-1 \\right\\\\} (whose multiplicative order modulo P\\, divides q\\,). s\\, \u2014 element W^4\\,. e\\, \u2014 element B^{\\ast}\\,. s,u_1,u_2,v\\, we call the preamble, and e\\, \u2014 the cryptogram. If a cleartext is a string consisting of l\\, \u0431\u0430\u0439\u0442, then the length of e\\, is equal to l+16\\left\\lceil l/1024 \\right\\rceil. We need to introduce the function CEncode\\,, which maps a ciphertext to its byte-string representation, and the corresponding inverse function CDecode\\,. For the integer l>0\\,, word string s \\in W^4, integers 0 \\le u_1,u_2,v<256^l, and byte string e \\in B^{\\ast}, CEncode(l,s,u_1,u_2,v,e) \\stackrel{\\mathrm{def}}{=}I_{W^{\\ast}}^{B^{\\ast}}(s)||pad_l(I_{Z}^{B^{\\ast}}(u_1))||pad_l(I_{Z}^{B^{\\ast}}(u_2))||pad_l(I_{Z}^{B^{\\ast}}(v))||e \\in B^{\\ast}. For integer l>0\\,, byte string \\psi \\in B^{\\ast}, such that L(\\psi) \\ge 3l+16, CDecode(l,\\psi) \\stackrel{\\mathrm{def}}{=}(I_{B^{\\ast}}^{W^{\\ast}}(\\Bigl[\\psi\\Bigr]_{0}^{16}),I_{B^{\\ast}}^{Z}(\\Bigl[\\psi\\Bigr]_{16}^{16+l}),I_{B^{\\ast}}^{Z}(\\Bigl[\\psi\\Bigr]_{16+l}^{16+2l}),I_{B^{\\ast}}^{Z}(\\Bigl[\\psi\\Bigr]_{16+2l}^{16+3l}),\\Bigl[\\psi\\Bigr]_{16+3l}^{L(\\psi)}) \\in W^4 \\times Z \\times Z \\times Z \\times B^{\\ast}. === Encryption Process === Algorithm. ACE asymmetric encryption operation. input: public key (P,q,g_1,g_2,c,d,h_1,h_2,k_1,k_2)\\, and byte string M \\in B^{\\ast}\\,. Output: byte string \u2014 ciphertext \\psi\\ of M\\,. # Generate r \\in \\left\\\\{ 0,...,q-1 \\right\\\\} at random. # Generate the ciphertext preamble: ## Generate s \\in W^4\\, at random. ## Compute u_1 \\leftarrow g_1^r rem P, u_2 \\leftarrow g_2^r rem P. ## Compute \\alpha\\ \\leftarrow UOWHash^\\prime (k_1,L_B(P),s,u_1,u_2) \\in Z\\,; note that 0 < \\alpha\\ < 2^{160}\\,. ## Compute v \\leftarrow c^r d^{\\alpha\\ r} rem P\\,. # Compute the key for the symmetric encryption operation: ## \\tilde{h_1} \\leftarrow h_1^r rem P, \\tilde{h_2} \\leftarrow h_2^r rem P. ## Compute k \\leftarrow ESHash(k,L_B(P),s,u_1,u_2,\\tilde{h_1},\\tilde{h_2}) \\in W^8\\,. # Compute cryptogram e \\leftarrow SEnc(k,s,1024,M). # Encode the ciphertext: \\psi\\ \\leftarrow CEncode(L_B(P),s,u_1,u_2,v,e). # Return \\psi\\ . Before starting off the symmetric encryption process, the input message M \\in B^{\\ast}\\, is divided into blocks M_1,...,M_t\\,, where each of the block, possibly except the last one, is of 1024 bytes. Each block is encrypted by the stream cipher. For each encrypted block E_i\\, 16-byte message authentication code is computed. We get the cryptogram e=E_1||C_1||...||E_t||C_t\\,.L(e)=L(M)+16\\left\\lceil L(M)/m \\right\\rceil. Note that if L(M)=0\\,, then L(e)=0\\,. Algorithm. ACE asymmetric encryption process. Input: (k,s,M,m) \\in W^8 \\times W^4 \\times Z \\times B^{\\ast} \\, m>0\\, Output: e \\in B^l, l=L(M)+16 \\left\\lceil L(N)/m \\right\\rceil. # If M=\\lambda_B \\,, then return \\lambda_B \\,. # Initialize a pseudo-random generator state:genState \\leftarrow InitGen(k,s) \\in GenState # Generate the key k_{AXU} AXUHash \\,: (k_{AXU},genState) \\leftarrow GenWords((5L_b(\\left\\lceil m/64 \\right\\rceil)+24),genState).. # e \\leftarrow \\lambda_B, i \\leftarrow 0. # While i, do the following: ## r \\leftarrow min(L(M)-i,m). ## Generate mask values for the encryption and MAC: ### (mask_m,genState) \\leftarrow GenWords(4,genState). ### (mask_e,genState) \\leftarrow GenWords(r,genState). ## Encrypt the plaintext: enc \\leftarrow \\Bigl[M\\Bigr]_i^{i+r} \\oplus mask_e. ## Generate the message authentication code: ### If i+r=L(M)\\,, then lastBlock \\leftarrow 1; else lastBlock \\leftarrow 0. ### mac \\leftarrow AXUHash(k_{AXU},lastBlock,enc) \\in W^4. ## Update the ciphertext: e \\leftarrow e||enc||I_{W^{\\ast}}^{B^{\\ast}}(mac \\oplus mask_m). ## i \\leftarrow i+r. # Return e \\,. === Decryption process === Algorithm. ACE decryption process. Input: public key (P,q,g_1,g_2,c,d,h_1,h_2,k_1,k_2)\\, and corresponding private key (w,x,y,z_1,z_2)\\,, byt e string \\psi \\in B^{\\ast}. Output: Decrypted message M \\in B^{\\ast} \\cup {Reject}. # Decrypt the ciphertext: ## If L(\\psi) < 3L_B(P)+16 \\,, then return Reject \\,. ## Compute: (s,u_1,u_2,v,e) \\leftarrow CDecode(L_B(P),\\psi) \\in W^4 \\times Z \\times Z \\times Z \\times B^{\\ast}; note that 0 \\le u_1,u_2,v<256^l, where l=L_B(P)\\,. # Verify the ciphertext preamble: ## If u_1 \\ge P or u_2 \\ge P or v \\ge P, then return Reject \\,. ## If u_1^q e 1 rem P, then return Reject \\,. ## reject \\leftarrow 0 \\,. ## If u_2 e u_1^w rem P, then reject \\leftarrow 1 \\,. ## Compute \\alpha \\leftarrow UOWHash^{\\prime}(k_1,L_B(P),s,u_1,u_2) \\in Z; note that 0 \\le \\alpha \\le 2^{160}. ## If v e u_1^{x+{\\alpha}y} rem P, then reject \\leftarrow 1 \\,. ## If reject=1 \\,, then return Reject \\,. # Compute the key for the symmetric decryption operation: ## \\tilde{h_1} \\leftarrow u_1^{z_1} rem P, \\tilde{h_2} \\leftarrow u_1^{z_2} rem P. ## Compute k \\leftarrow ESHash(k_2,L_B(P),s,u_1,\\tilde{h_1},\\tilde{h_2}) \\in W^8. # Compute M \\leftarrow SDec(k,s,1024,e);note that SDec\\, can return Reject \\,. # Return M\\,. Algorithm. Decryption operation SDec\\,. Input: (k,s,m,e) \\in W^8 \\times W^4 \\times Z \\times B^{\\ast} \\, m>0\\, Output: Decrypted message M \\in B^{\\ast} \\cup {Reject}. # If e=\\lambda_B \\,, then return \\lambda_B \\,. # Initialize a pseudo-random generator state: genState \\leftarrow InitGen(k,s) \\in GenState # Generate the key k_{AXU} AXUHash \\,: (k_{AXU},genState^{\\prime}) \\leftarrow GenWords((5L_b(\\left\\lceil m/64 \\right\\rceil)+24),genState).. # M \\leftarrow \\lambda_B, i \\leftarrow 0. # While i, do the following: ## r \\leftarrow min(L(e)-i,m+16)-16. ## If r \\le 0, then return Reject \\,. ## Generate mask values for the encryption and MAC: ### (mask_m,genState) \\leftarrow GenWords(4,genState). ### (mask_e,genState) \\leftarrow GenWords(r,genState). ## Verify the message authentication code: ### If i+r+16=L(M)\\,, then lastblock \\leftarrow 1; else lastblock \\leftarrow 0. ### mac \\leftarrow AXUHash(k_{AXU},lastBlock,\\Bigl[e\\Bigr]_i^{i+r}) \\in W^4. ### If \\Bigl[e\\Big]r_{i+r}^{i+r+16} e I_{W^{\\ast}}^{B^{\\ast}}(mac \\oplus mask_m), then return Reject \\,. ## Update the plaintext: M \\leftarrow M||(\\Bigl[e\\Bigr]_i^{i+r}) \\oplus mask_e). ## i \\leftarrow i+r+16. # Return M \\,. == Signature Scheme == The signature scheme employs two key types: ACE Signature public key: (N,h,x,e^{\\prime},k^{\\prime},s)\\,. ACE Signature private key: (p,q,a)\\,. For the given size parameter m\\,, such that 1024 \\le m \\le 16384, key components are defined the following way: p\\, \u2014 \\left\\lfloor m/2 \\right\\rfloor-bit prime number with (p-1)/2\\, \u2014 is also a prime number. q\\, \u2014 \\left\\lfloor m/2 \\right\\rfloor-bit prime number with (q-1)/2\\, \u2014 is also a prime number. N\\, \u2014 N=pq\\,and has either m\\, or m-1\\, \u0431\u0438\u0442. h,x\\, \u2014 elements \\left\\\\{1,...,N-1\\right\\\\} (quadratic residues modulo N\\,). e^{\\prime}\\, \u2014 161-bit prime number. a\\, \u2014 element \\left\\\\{0,...,(p-1)(q-1)/4-1\\right\\\\} k^{\\prime}\\, \u2014 elements B^{184}\\,. s\\, \u2014 elements B^{32}\\,. === Key Generation === Algorithm. Key generation for the ACE public-key signature scheme. Input: size parameter m\\,, such that 1024 \\le m \\le 16384. Output: public/private key pair. # Generate random prime numbersp,q\\,, such that (p-1)/2\\, and (q-1)/2\\, \u2014 is also a prime number, and 2^{m_1-1} < p < 2^{m_1}, 2^{m_2-1}, \u0438 p e q, where m_1=\\left\\lfloor m/2 \\right\\rfloor and m_1=\\left\\lceil m/2 \\right\\rceil. # Set N \\leftarrow pq. # Generate random prime number e^{\\prime}\\,, \u0433\u0434\u0435 2^{160} \\le e^{\\prime} \\le 2^{161}. # Generate random h^{\\prime} \\in \\left\\\\{1,...,N-1\\right\\\\}, taking into account gcd(h^{\\prime},N)=1 and gcd(h^{\\prime} \\pm 1,N)=1, and compute h \\leftarrow (h^{\\prime})^{-2} rem N. # Generate random a \\in \\left\\\\{0,...,(p-1)(q-1)/4-1\\right\\\\}and compute x \\leftarrow h^a rem N. # Generate random byte strings k^{\\prime} \\in B^{184}\\,, and s \\in B^{32}\\,. # Return public key/private key pair ((N,h,x,e^{\\prime},k^{\\prime},s),(p,q,a))\\,. === Signature Representation === The signature in the ACE signature scheme has the form (d,w,y,y^{\\prime},\\tilde{k}), where the components are defined the following way: d\\, \u2014 element B^{64}\\,. w\\, \u2014 integer, such that 2^{160} \\le w \\le 2^{161}. y,y^{\\prime}\\, \u2014 elements \\left\\\\{1,...,N-1\\right\\\\}. \\tilde{k}\\, \u2014 element B^{\\ast}\\,;note that L(\\tilde{k})=64+20L_B(\\left\\lceil (L(M)+8)/64 \\right\\rceil), where M\\, \u2014 message being signed. We need to introduce the SEncode\\, function, which maps a signature into its byte string representation, and the corresponding inverse function SDecode\\,. For integer l>0\\,, byte string d \\in B^{64}, integers 0 \\le w \\le 256^{21} and 0 \\le y,y^{\\prime}<256^l, and byte string \\tilde{k} \\in B^{\\ast},SEncode(l,d,w,y,y^{\\prime},\\tilde{k}) \\stackrel{\\mathrm{def}}{=}d||pad_{21}(I_{Z}^{B^{\\ast}}(w))||pad_l(I_{Z}^{B^{\\ast}}(y))||pad_l(I_{Z}^{B^{\\ast}}(y^{\\prime}))||\\tilde{k} \\in B^{\\ast}. For integer l>0\\,, byte string \\sigma \\in B^{\\ast}, where L(\\sigma) \\ge 2l+53, CSecode(l,\\sigma) \\stackrel{\\mathrm{def}}{=}(\\Bigl[\\sigma\\Bigr]_{0}^{64},I_{B^{\\ast}}^{Z}(\\Bigl[\\sigma\\Bigr]_{64}^{85}),I_{B^{\\ast}}^{Z}(\\Bigl[\\sigma\\Bigr]_{85}^{85+l}),I_{B^{\\ast}}^{Z}(\\Bigl[\\sigma\\Bigr]_{85+l}^{85+2l}),\\Bigl[\\sigma\\Bigr]_{85+2l}^{L(\\sigma)}) \\in B^{64} \\times Z \\times Z \\times Z \\times B^{\\ast}. === Signature Generation Process === Algorithm. ACE Signature Generation Process. Input: public key (N,h,x,e^{\\prime},k^{\\prime},s)\\, and corresponding private key (p,q,a)\\, and byte string M \\in B^{\\ast}\\,, 0 \\le L(M) \\le 2^{64}. Output: byte string \u2014 digital signature \\sigma \\in B^{\\ast}\\,. # Perform the following steps to hash the input data: ## Generate a hash key \\tilde{k} \\in B^{20m+64} at random, such that m=L_b(\\left\\lceil (L(M)+8)/64 \\right\\rceil). ## Compute m_h \\leftarrow I_{W^{\\ast}}^{Z}(UOWHash^{\\prime\\prime}(\\tilde{k},M)). # Select \\tilde{y} \\in \\left\\\\{1,...,N-1\\right\\\\} at random, and compute y^{\\prime} \\leftarrow \\tilde{y}^2 rem N. # Compute x^{\\prime} \\leftarrow (y^{\\prime})^{r^{\\prime}}h^{m_h} rem N. # Generate a random prime e\\,, 2^{160} \\le e \\le 2^{161}, and its certificate of correctness (w,d)\\,: (e,w,d) \\leftarrow GenCertPrime(s)\\,. Repeat this step until e e e^{\\prime}\\,. # Set r \\leftarrow UOWHash^{\\prime\\prime\\prime}(k^{\\prime},L_B(N),x^{\\prime},\\tilde{k}) \\in Z; note that 0 \\le r < 2^{160}. # Compute y \\leftarrow h^b rem N, where b \\leftarrow e^{-1}(a-r)rem(p^{\\prime}q^{\\prime}), and where p^{\\prime}=(p-1)/2 and q^{\\prime}=(q-1)/2. # Encode the signature: \\sigma \\leftarrow SEncode(L_B(N),d,w,y,y^{\\prime},\\tilde{k}). # Return \\sigma\\, == Notes == In the definition of ACE Encryption process and ACE Signature process some auxiliary function (e.g. UOWHash, ESHash and some other) are being used, definition of which goes beyond this article. More details about it can be found in \u0432.ACE: The Advanced Cryptographic Engine, T. Schweinberger and V. Shoup, manuscript 2000 == Implementation, Utilization and Performance == ACE Encryption scheme is recommended by NESSIE (New European Schemes for Signatures, Integrity and Encryption) as asymmetric encryption scheme. Press-release is dated by February 2003. Both schemes were implemented in ANSI C, with the use of GNU GMP library. Tests were done on two platforms: Power PC 604 model 43P under AIX system and 266 MHz Pentium under Windows NT system. Result tables: Table 1. Time costs on basic operations. {| class=\"wikitable\" | |colspan=\"2\" |Power PC |colspan=\"2\" |Pentium |- | |colspan=\"2\" |Operand size(byte) |colspan=\"2\" |Operand size(byte) |- | |512 |1024 |512 |1024 |- |Multiplication |3.5 * 10^(-5) sec |1.0 * 10^(-4) sec |4.5 * 10^(-5) sec |1.4 * 10^(-4) sec |- |Squaring |3.3 * 10^(-5) sec |1.0 * 10^(-4) sec |4.4 * 10^(-5) sec |1.4 * 10^(-4) sec |- |Exponentiation |1.9 * 10^(-2) sec |1.2 * 10^(-1) sec |2.6 * 10^(-2) sec |1.7 * 10^(-1) sec |} Table 2. Performance of encryption scheme and signature scheme. {| class=\"wikitable\" | |colspan=\"2\" |Power PC |colspan=\"2\" |Pentium |- | |Fixed costs (ms) |MBit/sec |Fixed costs (ms) |MBit/sec |- |Encrypt |160 |18 |230 |16 |- |Decrypt |68 |18 |97 |14 |- |Sign |48 |64 |62 |52 |- |Sign set-up |29 | |41 | |- |Verify |52 |65 |73 |53 |} == Literature == ==External links== * http://www.alphaworks.ibm.com/tech/ace * http://www.zurich.ibm.com/security/ace/ * NESSIE Portfolio of recommended cryptographic primitives Category:Cryptographic software ",
    "title": "ACE Encrypt"
}