{
    "id": "61408357",
    "text": "In mathematical logic, the intersection type discipline is a branch of type theory encompassing type systems that use the intersection type constructor (\\cap) to assign multiple types to a single term. In particular, if a term M can be assigned _both_ the type \\varphi_1 and the type \\varphi_2, then M can be assigned the intersection type \\varphi_1 \\cap \\varphi_2 (and vice versa). Therefore, the intersection type constructor can be used to express finite heterogeneous ad hoc polymorphism (as opposed to parametric polymorphism). For example, the \u03bb-term \\lambda x.\\\\!(x\\;x) can be assigned the type ((\\alpha \\to \\beta) \\cap \\alpha) \\to \\beta in most intersection type systems, assuming for the term variable x both the function type \\alpha \\to \\beta and the corresponding argument type \\alpha. Prominent intersection type systems include the Coppo\u2013Dezani type assignment system, the Barendregt-Coppo\u2013Dezani type assignment system, and the essential intersection type assignment system. Most strikingly, intersection type systems are closely related to (and often exactly characterize) normalization properties of \u03bb-terms under \u03b2-reduction. In programming languages, such as TypeScript and Scala, intersection types are used to express ad hoc polymorphism. == History == The intersection type discipline was pioneered by Mario Coppo, Mariangiola Dezani-Ciancaglini, Patrick Sall\u00e9, and Garrel Pottinger. The underlying motivation was to study semantic properties (such as normalization) of the \u03bb-calculus by means of type theory. While the initial work by Coppo and Dezani established a type theoretic characterization of strong normalization for the \u03bbI-calculus, Pottinger extended this characterization to the \u03bbK-calculus. In addition, Sall\u00e9 contributed the notion of the universal type \\omega that can be assigned to any \u03bb-term, thereby corresponding to the empty intersection. Using the universal type \\omega allowed for a fine-grained analysis of head normalization, normalization, and strong normalization. In collaboration with Henk Barendregt, a filter \u03bb-model for an intersection type system was given, tying intersection types ever more closely to \u03bb-calculus semantics. Due to the correspondence with normalization, typability in prominent intersection type systems (excluding the universal type) is undecidable. Complementarily, undecidability of the dual problem of type inhabitation in prominent intersection type systems was proven by Pawe\u0142 Urzyczyn. Later, this result was refined showing exponential space completeness of rank 2 intersection type inhabitation and undecidability of rank 3 intersection type inhabitation. Remarkably, principal type inhabitation is decidable in polynomial time. == Coppo\u2013Dezani type assignment system == The Coppo\u2013Dezani type assignment system (\\vdash_{\\text{CD}}) extends the simply typed \u03bb-calculus by allowing multiple types to be assumed for a term variable. === Term language === The term language of (\\vdash_\\text{CD}) is given by \u03bb-terms (or, lambda expressions): : \\begin{align} M, N & ::= x \\mid (\\lambda x.\\\\!M) \\mid (M\\;N) && \\text{ where } x \\text{ ranges over term variables}\\\\\\ \\end{align} === Type language === The type language of (\\vdash_\\text{CD}) is inductively defined by the following grammar: : \\begin{align} \\varphi & ::= \\alpha \\mid \\sigma \\to \\varphi && \\text{ where } \\alpha \\text{ ranges over type variables}\\\\\\ \\sigma & ::= \\varphi_1 \\cap \\cdots \\cap \\varphi_n && \\text{ where } n \\geq 1 \\end{align} The intersection type constructor (\\cap) is taken modulo associativity, commutativity and idempotence. === Type rules === The type rules (\\to\\\\!\\\\!\\text{I}), (\\to\\\\!\\\\!\\text{E}), (\\cap\\text{I}), and (\\cap\\text{E}) of (\\vdash_\\text{CD}) are: : \\begin{array}{cc} \\dfrac{\\Gamma, x : \\sigma \\vdash_\\text{CD} M : \\varphi}{\\Gamma \\vdash_\\text{CD} \\lambda x.\\\\!M : \\sigma \\to \\varphi}(\\to\\\\!\\\\!\\text{I}) &\\dfrac{\\Gamma \\vdash_\\text{CD} M : \\sigma \\to \\varphi \\quad \\Gamma \\vdash_\\text{CD} N : \\sigma}{\\Gamma \\vdash_\\text{CD} M\\;N : \\varphi}(\\to\\\\!\\\\!\\text{E})\\\\\\\\\\\\\\ \\dfrac{\\Gamma \\vdash_\\text{CD} M : \\varphi_1 \\quad \\ldots \\quad \\Gamma \\vdash_\\text{CD} M : \\varphi_n}{\\Gamma \\vdash_\\text{CD} M : \\varphi_1 \\cap \\cdots \\cap \\varphi_n}(\\cap\\text{I}) &\\dfrac{(1 \\leq i \\leq n)}{\\Gamma, x : \\varphi_1 \\cap \\cdots \\cap \\varphi_n \\vdash_\\text{CD} x : \\varphi_i}(\\cap\\text{E}) \\end{array} === Properties === Typability and normalization are closely related in (\\vdash_{\\text{CD}}) by the following properties: * Subject reduction: If \\Gamma \\vdash_{\\text{CD}} M : \\sigma and M \\to_\\beta N, then \\Gamma \\vdash_{\\text{CD}} N : \\sigma. * Normalization: If \\Gamma \\vdash_{\\text{CD}} M : \\sigma, then M has a \u03b2-normal form. * Typability of strongly normalizing \u03bb-terms: If M is strongly normalizing, then \\Gamma \\vdash_{\\text{CD}} M : \\sigma for some \\Gamma and \\sigma. * Characterization of \u03bbI-normalization: M has a normal form in the \u03bbI- calculus, if and only if \\Gamma \\vdash_{\\text{CD}} M : \\sigma for some \\Gamma and \\sigma. If the type language is extended to contain the empty intersection, i.e. \\sigma = \\varphi_1 \\cap \\cdots \\cap \\varphi_n \\text{ where } n = 0, then (\\vdash_{\\text{CD}}) is closed under \u03b2-equality and is sound and complete for inference semantics. == Barendregt\u2013Coppo\u2013Dezani type assignment system == The Barendregt\u2013Coppo\u2013Dezani type assignment system (\\vdash_{\\text{BCD}}) extends the Coppo\u2013Dezani type assignment system in the following three aspects: * (\\vdash_\\text{BCD}) introduces the universal type constant \\omega (akin to the empty intersection) that can be assigned to any \u03bb-term. * (\\vdash_{\\text{BCD}}) allows the intersection type constructor (\\cap) to appear on the right-hand side of the arrow type constructor (\\to). * (\\vdash_\\text{BCD}) introduces the intersection type subtyping (\\leq) partial order on types together with a corresponding typing rule. === Term language === The term language of (\\vdash_{\\text{BCD}}) is given by \u03bb-terms (or, lambda expressions): : \\begin{align} M, N & ::= x \\mid (\\lambda x.\\\\!M) \\mid (M\\;N) && \\text{ where } x \\text{ ranges over term variables}\\\\\\ \\end{align} === Type language === The type language of (\\vdash_{\\text{BCD}}) is inductively defined by the following grammar: : \\begin{align} \\sigma, \\tau & ::= \\alpha \\mid \\omega \\mid \\sigma \\to \\tau \\mid \\sigma \\cap \\tau && \\text{ where } \\alpha \\text{ ranges over type variables} \\end{align} === Intersection type subtyping === Intersection type subtyping (\\leq) is defined as the smallest preorder (reflexive and transitive relation) over intersection types satisfying the following properties: : \\begin{align} &\\sigma \\leq \\omega, \\quad \\omega \\leq \\omega\\to\\omega, \\quad \\sigma \\cap \\tau \\leq \\sigma, \\quad \\sigma \\cap \\tau \\leq \\tau, \\\\\\ & (\\sigma\\to\\tau_1) \\cap (\\sigma\\to\\tau_2) \\leq \\sigma \\to \\tau_1 \\cap \\tau_2,\\\\\\ &\\text{if }\\sigma \\leq \\tau_1 \\text{ and } \\sigma\\leq \\tau_2 \\text{, then } \\sigma \\leq \\tau_1 \\cap \\tau_2, \\\\\\ &\\text{if } \\sigma_2 \\leq \\sigma_1 \\text{ and } \\tau_1 \\leq \\tau_2 \\text{, then } \\sigma_1\\to\\tau_1 \\leq \\sigma_2\\to\\tau_2 \\end{align} Intersection type subtyping is decidable in quadratic time. === Type rules === The type rules (\\to\\\\!\\\\!\\text{I}), (\\to\\\\!\\\\!\\text{E}), (\\cap\\text{I}), (\\leq), (\\text{A}), and (\\omega) of (\\vdash_{\\text{BCD}}) are: : \\begin{array}{cc} \\dfrac{\\Gamma, x : \\sigma \\vdash_{\\text{BCD}} M : \\tau}{\\Gamma \\vdash_{\\text{BCD}} \\lambda x.\\\\!M : \\sigma \\to \\tau}(\\to\\\\!\\\\!\\text{I}) &\\dfrac{\\Gamma \\vdash_{\\text{BCD}} M : \\sigma \\to \\tau \\quad \\Gamma \\vdash_{\\text{BCD}} N : \\sigma}{\\Gamma \\vdash_{\\text{BCD}} M\\;N : \\tau}(\\to\\\\!\\\\!\\text{E})\\\\\\\\\\\\\\ \\dfrac{\\Gamma \\vdash_{\\text{BCD}} M : \\sigma \\quad \\Gamma \\vdash_{\\text{BCD}} M : \\tau}{\\Gamma \\vdash_{\\text{BCD}} M : \\sigma \\cap \\tau}(\\cap\\text{I}) &\\dfrac{\\Gamma \\vdash_{\\text{BCD}} M : \\sigma \\quad (\\sigma \\leq \\tau)}{\\Gamma \\vdash_{\\text{BCD}} M : \\tau}(\\leq)\\\\\\\\\\\\\\ \\dfrac{}{\\Gamma, x : \\sigma \\vdash_{\\text{BCD}} x : \\sigma}(\\text{A}) &\\dfrac{}{\\Gamma \\vdash_{\\text{BCD}} M : \\omega}(\\omega) \\end{array} === Properties === * Semantics: (\\vdash_{\\text{BCD}}) is sound and complete wrt. a filter \u03bb-model, in which the interpretation of a \u03bb-term coincides with the set of types that can be assigned to it. * Subject reduction: If \\Gamma \\vdash_{\\text{BCD}} M : \\sigma and M \\to_{\\beta} N, then \\Gamma \\vdash_{\\text{BCD}} N : \\sigma. * Subject expansion: If \\Gamma \\vdash_{\\text{BCD}} N : \\sigma and M \\to_{\\beta} N, then \\Gamma \\vdash_{\\text{BCD}} M : \\sigma. * Characterization of strong normalization: M is strongly normalizing wrt. \u03b2-reduction, if and only if \\Gamma \\vdash_{\\text{BCD}} M : \\sigma is derivable without rule (\\omega) for some \\Gamma and \\sigma. * Principal pairs: If M is strongly normalizing, then there exists a principal pair (\\Gamma, \\sigma) such that for any typing \\Gamma' \\vdash_{\\text{BCD}} M : \\sigma' the pair (\\Gamma', \\sigma') can be obtained from the principal pair (\\Gamma, \\sigma) by means of type expansions, liftings, and substitutions. ==References== Category:Type theory Category:Type systems Category:Lambda calculus Category:Theory of computation Category:Polymorphism (computer science) ",
    "title": "Intersection type discipline"
}