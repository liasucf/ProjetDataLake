{
    "id": "647569",
    "text": "In computing, vectored I/O, also known as scatter/gather I/O, is a method of input and output by which a single procedure call sequentially reads data from multiple buffers and writes it to a single data stream, or reads data from a data stream and writes it to multiple buffers, as defined in a vector of buffers. Scatter/gather refers to the process of gathering data from, or scattering data into, the given set of buffers. Vectored I/O can operate synchronously or asynchronously. The main reasons for using vectored I/O are efficiency and convenience. Vectored I/O has several potential uses: * Atomicity: if the particular vectored I/O implementation supports atomicity, a process can write into or read from a set of buffers to or from a file without risk that another thread or process might perform I/O on the same file between the first process' reads or writes, thereby corrupting the file or compromising the integrity of the input * Concatenating output: an application that wants to write non-sequentially placed data in memory can do so in one vectored I/O operation. For example, writing a fixed-size header and its associated payload data that are placed non-sequentially in memory can be done by a single vectored I/O operation without first concatenating the header and the payload to another buffer * Efficiency: one vectored I/O read or write can replace many ordinary reads or writes, and thus save on the overhead involved in syscalls * Splitting input: when reading data held in a format that defines a fixed-size header, one can use a vector of buffers in which the first buffer is the size of that header; and the second buffer will contain the data associated with the header Standards bodies document the applicable functions `readv`readv in the Single Unix Specification and `writev`writev in the Single Unix Specification in POSIX 1003.1-2001 and the Single UNIX Specification version 2. The Windows API has analogous functions `ReadFileScatter` and `WriteFileGather`; however, unlike the POSIX functions, they require the alignment of each buffer on a memory page.ReadFileScatter in MSDN Library Winsock provides separate `WSASend` and `WSARecv` functions without this requirement. While working directly with a vector of buffers can be significantly harder than working with a single buffer, using higher-level APIs Vstr the Vectored String API for working efficiently can mitigate the difficulties. == Examples == The following example prints \"Hello, Wikipedia Community!\" to the standard output. Each word is saved into a single buffer and with only one call to `writev()`, all buffers are printed to the standard output. #include #include #include #include #include int main(int argc, char *argv[]) { const char buf1[] = \"Hello, \"; const char buf2[] = \"Wikipedia \"; const char buf3[] = \"Community! \"; struct iovec bufs[] = { { .iov_base = (void *) buf1, .iov_len = sizeof buf1 - 1 }, { .iov_base = (void *) buf2, .iov_len = sizeof buf2 - 1 }, { .iov_base = (void *) buf3, .iov_len = sizeof buf3 - 1 }, }; if (-1 == writev(STDOUT_FILENO, bufs, sizeof bufs / sizeof *bufs)) { perror(\"writev()\"); exit(EXIT_FAILURE); } return EXIT_SUCCESS; } == References == Category:Input/output ",
    "title": "Vectored I/O"
}