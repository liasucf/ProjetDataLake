{
    "id": "523166",
    "text": "In abstract algebra, the free monoid on a set is the monoid whose elements are all the finite sequences (or strings) of zero or more elements from that set, with string concatenation as the monoid operation and with the unique sequence of zero elements, often called the empty string and denoted by \u03b5 or \u03bb, as the identity element. The free monoid on a set A is usually denoted A\u2217. The free semigroup on A is the subsemigroup of A\u2217 containing all elements except the empty string. It is usually denoted A+., More generally, an abstract monoid (or semigroup) S is described as free if it is isomorphic to the free monoid (or semigroup) on some set. As the name implies, free monoids and semigroups are those objects which satisfy the usual universal property defining free objects, in the respective categories of monoids and semigroups. It follows that every monoid (or semigroup) arises as a homomorphic image of a free monoid (or semigroup). The study of semigroups as images of free semigroups is called combinatorial semigroup theory. Free monoids (and monoids in general) are associative, by definition; that is, they are written without any parenthesis to show grouping or order of operation. The non-associative equivalent is the free magma. == Examples == === Natural numbers === The monoid (N0,+) of natural numbers (including zero) under addition is a free monoid on a singleton free generator, in this case the natural number 1. According to the formal definition, this monoid consists of all sequences like \"1\", \"1+1\", \"1+1+1\", \"1+1+1+1\", and so on, including the empty sequence. Mapping each such sequence to its evaluation result Since addition of natural numbers is associative, the result doesn't depend on the order of evaluation, thus ensuring the mapping to be well-defined. and the empty sequence to zero establishes an isomorphism from the set of such sequences to N0. This isomorphism is compatible with \"+\", that is, for any two sequences s and t, if s is mapped (i.e. evaluated) to a number m and t to n, then their concatenation s+t is mapped to the sum m+n. === Kleene star === In formal language theory, usually a finite set of \"symbols\" A (sometimes called the alphabet) is considered. A finite sequence of symbols is called a \"word over A\", and the free monoid A\u2217 is called the \"Kleene star of A\". Thus, the abstract study of formal languages can be thought of as the study of subsets of finitely generated free monoids. For example, assuming an alphabet A = {a, b, c}, its Kleene star A\u2217 contains all concatenations of a, b, and c: :{\u03b5, a, ab, ba, caa, ', ...}. If A is any set, the word length function on A\u2217 is the unique monoid homomorphism from A\u2217 to (N0,+) that maps each element of A to 1. A free monoid is thus a graded monoid.Sakarovitch (2009) p.382 (A graded monoid M is a monoid that can be written as M=M_0\\oplus M_1\\oplus M_2 \\cdots. Each M_n is a grade; the grading here is just the length of the string. That is, M_n contains those strings of length n. The \\oplus symbol here can be taken to mean \"set union\"; it is used instead of the symbol \\cup because, in general, set unions might not be monoids, and so a distinct symbol is used. By convention, gradations are always written with the \\oplus symbol.) There are deep connections between the theory of semigroups and that of automata. For example, every formal language has a syntactic monoid that recognizes that language. For the case of a regular language, that monoid is isomorphic to the transition monoid associated to the semiautomaton of some deterministic finite automaton that recognizes that language. The regular languages over an alphabet A are the closure of the finite subsets of A*, the free monoid over A, under union, product, and generation of submonoid. For the case of concurrent computation, that is, systems with locks, mutexes or thread joins, the computation can be described with history monoids and trace monoids. Roughly speaking, elements of the monoid can commute, (e.g. different threads can execute in any order), but only up to a lock or mutex, which prevent further commutation (e.g. serialize thread access to some object). ==Conjugate words== Example for 1st case of equidivisibility: m=\"UNCLE\", n=\"ANLY\", p=\"UN\", q=\"CLEANLY\", and s=\"CLE\" We define a pair of words in A\u2217 of the form uv and vu as conjugate: the conjugates of a word are thus its circular shifts.Sakarovitch (2009) p.27 Two words are conjugate in this sense if they are conjugate in the sense of group theory as elements of the free group generated by A. ===Equidivisibility=== A free monoid is equidivisible: if the equation mn = pq holds, then there exists an s such that either m = ps, sn = q (example see image) or ms = p, n = sq.Sakarovitch (2009) p.26 This result is also known as Levi's lemma. A monoid is free if and only if it is graded and equidivisible. == Free generators and rank == The members of a set A are called the free generators for A\u2217 and A+. The superscript * is then commonly understood to be the Kleene star. More generally, if S is an abstract free monoid (semigroup), then a set of elements which maps onto the set of single- letter words under an isomorphism to a semigroup A+ (monoid A\u2217) is called a set of free generators for S. Each free semigroup (or monoid) S has exactly one set of free generators, the cardinality of which is called the rank of S. Two free monoids or semigroups are isomorphic if and only if they have the same rank. In fact, every set of generators for a free semigroup or monoid S contains the free generators (see definition of generators in Monoid) since a free generator has word length 1 and hence can only be generated by itself. It follows that a free semigroup or monoid is finitely generated if and only if it has finite rank. A submonoid N of A\u2217 is stable if u, v, ux, xv in N together imply x in N. A submonoid of A\u2217 is stable if and only if it is free. For example, using the set of bits { \"0\", \"1\" } as A, the set N of all bit strings containing an even number of \"1\"s is a stable submonoid because if u contains an even number of \"1\"s, and ux as well, then x must contain an even number of \"1\"s, too. While N cannot be freely generated by any set of single bits, it can be freely generated by the set of bit strings { \"0\", \"11\", \"101\", \"1001\", \"10001\", ... } \u2013 the set of strings of the form \"10n1\" for some integer n. ===Codes=== A set of free generators for a free monoid P is referred to as a basis for P: a set of words C is a code if C* is a free monoid and C is a basis. A set X of words in A\u2217 is a prefix, or has the prefix property, if it does not contain a proper (string) prefix of any of its elements. Every prefix in A+ is a code, indeed a prefix code. A submonoid N of A\u2217 is right unitary if x, xy in N implies y in N. A submonoid is generated by a prefix if and only if it is right unitary. ==Factorization== A factorization of a free monoid is a sequence of subsets of words with the property that every word in the free monoid can be written as a concatenation of elements drawn from the subsets. The Chen\u2013Fox\u2013Lyndon theorem states that the Lyndon words furnish a factorization. More generally, Hall words provide a factorization; the Lyndon words are a special case of the Hall words. ==Free hull== The intersection of free submonoids of a free monoid A\u2217 is again free. If S is a subset of a free monoid A* then the intersection of all free submonoids of A* containing S is well-defined, since A* itself is free, and contains S; it is a free monoid and called the free hull of S. A basis for this intersection is a code. The defect theorem states that if X is finite and C is the basis of the free hull of X, then either X is a code and C = X, or :|C| \u2264 |X| \u2212 1 . ==Morphisms== A monoid morphism f from a free monoid B\u2217 to a monoid M is a map such that f(xy) = f(x)\u22c5f(y) for words x,y and f(\u03b5) = \u03b9, where \u03b5 and \u03b9 denotes the identity element of B\u2217 and M, respectively. The morphism f is determined by its values on the letters of B and conversely any map from B to M extends to a morphism. A morphism is non-erasing or continuous if no letter of B maps to \u03b9 and trivial if every letter of B maps to \u03b9. A morphism f from a free monoid B\u2217 to a free monoid A\u2217 is total if every letter of A occurs in some word in the image of f; cyclic or periodicSalomaa (1981) p.77 if the image of f is contained in {w}\u2217 for some word w of A\u2217. A morphism f is k-uniform if the length |f(a)| is constant and equal to k for all a in A. A 1-uniform morphism is strictly alphabetic or a coding. A morphism f from a free monoid B\u2217 to a free monoid A\u2217 is simplifiable if there is an alphabet C of cardinality less than that of B such the morphism f factors through C\u2217, that is, it is the composition of a morphism from B\u2217 to C\u2217 and a morphism from that to A\u2217; otherwise f is elementary. The morphism f is called a code if the image of the alphabet B under f is a code: every elementary morphism is a code.Salomaa (1981) p.72 ===Test sets=== For L a subset of B\u2217, a finite subset T of L is a test set for L if morphisms f and g on B\u2217 agree on L if and only if they agree on T. The Ehrenfeucht conjecture is that any subset L has a test set: it has been proved independently by Albert and Lawrence; McNaughton; and Guba. The proofs rely on Hilbert's basis theorem. ===Map and fold=== The computational embodiment of a monoid morphism is a map followed by a fold. In this setting, the free monoid on a set A corresponds to lists of elements from A with concatenation as the binary operation. A monoid homomorphism from the free monoid to any other monoid (M,\u2022) is a function f such that * f(x1...xn) = f(x1) \u2022 ... \u2022 f(xn) * f() = e where e is the identity on M. Computationally, every such homomorphism corresponds to a map operation applying f to all the elements of a list, followed by a fold operation which combines the results using the binary operator \u2022. This computational paradigm (which can be generalized to non-associative binary operators) has inspired the MapReduce software framework. ==Endomorphisms== An endomorphism of A\u2217 is a morphism from A\u2217 to itself. The identity map I is an endomorphism of A\u2217, and the endomorphisms form a monoid under composition of functions. An endomorphism f is prolongable if there is a letter a such that f(a) = as for a non-empty string s.Allouche & Shallit (2003) p.10 ===String projection=== The operation of string projection is an endomorphism. That is, given a letter a \u2208 \u03a3 and a string s \u2208 \u03a3\u2217, the string projection pa(s) removes every occurrence of a from s; it is formally defined by :p_a(s) = \\begin{cases} \\varepsilon & \\text{if } s=\\varepsilon, \\text{ the empty string} \\\\\\ p_a(t) & \\text{if } s=ta \\\\\\ p_a(t)b & \\text{if } s=tb \\text{ and } b e a. \\end{cases} Note that string projection is well-defined even if the rank of the monoid is infinite, as the above recursive definition works for all strings of finite length. String projection is a morphism in the category of free monoids, so that :p_a\\left(\\Sigma^*\\right)= \\left(\\Sigma-a\\right)^* where p_a\\left(\\Sigma^*\\right) is understood to be the free monoid of all finite strings that don't contain the letter a. Projection commutes with the operation of string concatenation, so that p_a(st)=p_a(s)p_a(t) for all strings s and t. There are many right inverses to string projection, and thus it is a split epimorphism. The identity morphism is p_\\varepsilon, defined as p_\\varepsilon(s)=s for all strings s, and p_\\varepsilon(\\varepsilon)=\\varepsilon. String projection is commutative, as clearly :p_a(p_b(s))=p_b(p_a(s)). For free monoids of finite rank, this follows from the fact that free monoids of the same rank are isomorphic, as projection reduces the rank of the monoid by one. String projection is idempotent, as :p_a(p_a(s))=p_a(s) for all strings s. Thus, projection is an idempotent, commutative operation, and so it forms a bounded semilattice or a commutative band. ==The free commutative monoid== Given a set A, the free commutative monoid on A is the set of all finite multisets with elements drawn from A, with the monoid operation being multiset sum and the monoid unit being the empty multiset. For example, if A = {a, b, c}, elements of the free commutative monoid on A are of the form :{\u03b5, a, ab, a2b, ab3c4, ...}. The fundamental theorem of arithmetic states that the monoid of positive integers under multiplication is a free commutative monoid on an infinite set of generators, the prime numbers. The free commutative semigroup is the subset of the free commutative monoid which contains all multisets with elements drawn from A except the empty multiset. The free partially commutative monoid, or trace monoid, is a generalization that encompasses both the free and free commutative monoids as instances. This generalization finds applications in combinatorics and in the study of parallelism in computer science. ==See also== * String operations ==Notes== ==References== * * * * * * * * ==External links== * Category:Semigroup theory Category:Formal languages Category:Free algebraic structures Category:Combinatorics on words ",
    "title": "Free monoid"
}