{
    "id": "61369588",
    "text": "Topswops (and the variants Topdrops, Bottomswops and Bottomdrops) are mathematical problems devised and analysed by the British mathematician John Conway in 1973. Contrary to other games and problems introduced by Conway, these problems have not received much attention from the scientific community. Two famous mathematicians who have contributed to the problem are Martin Gardner and Donald Knuth. A Topswops example with N=5 numbers. The algorithm ends after 7 iterations. ==Formulation== In each variant of the problem, Conway uses a deck of playing cards. Since the numerical values of the deck are only relevant, only one suit is used. This is mathematically equivalent to a row of integers from 1 to N. A shuffled pile of cards is written as A[1], ..., A[N]. ===Topswops=== For topswops the following algorithm is applied: # Consider the first card from the pile (which is A[1]) # Take the first A[1] cards from the pile # Swap these cards and place them back on the pile # Repeat step 1, 2 and 3 until the top card is 1 The final configuration of the row always starts with 1. The topswops problem is occasionally named differently, with naming including deterministic pancake problem, topswops, topswaps, reverse card shuffle and fannkuch. The problem formulated by Conway is the following: :Which initial configuration leads to the maximum number of 'swops' before the algorithm terminates? In literature there are some attempts to find lower and upper bounds for the number of iterations f(N). Theorem: f(N) is bounded by 2^{N-1}. Proof by Herbert S. Wilf: Consider a permutation A[1] to A[N] of the row 1 to N. As an example, we consider 7,2,11,8,5,13,6,1,9,10,3,12,4 . We are specifically interested in numbers which are at 'the correct position'. These are: 2, 5, 9, 10, 12. We define the Wilf number as 2^{(2-1)}+2^{(5-1)}+2^{(9-1)}+2^{(10-1)}+2^{(12-1)} = 2833. Claim: after each iteration of the algorithm, the Wilf number increases. Proof: We perform one iteration of the algorithm. Every number at 'the correct position' and larger than A[1], leaves the Wilf number unchanged. The remaining numbers at 'the correct position' will in general not be at 'the correct position' anymore. Nevertheless, the A[1]'s number is at the correct position. And since the sum of the first A[1]-1 Wilf numbers is always smaller than the Wilf number of A[1], the total Wilf number always increases (with at least 1 per iteration of the algorithm). \\square The maximal Wilf number is found when each number is at the correct position. So the maximal Wilf number is 2^{N+1}-1. By refining the proof, the given upper bound can be proven to be a real upper bound for the number of iterations. \\square Topswops: the relation between N and f(N) in a semi-logarithmic graph. The upper bound is loose, whereas the lower bound is quite tight. double logarithmic graph. The data points in the graph are only some permutated rows, and are lower bounds of the real value. The upper bound is again very loose, whereas the lower bound is relatively tight. Theorem: f(N) is bounded by the (N+1)th Fibonacci number. Proof by Murray S. Klamkin: Suppose that during the algorithm, the first number A[1] takes on in total k distinct values. Claim: f(N) \\leq F_{k+1}. Proof: We prove the claim by mathematical induction. For k=1, the algorithm directly terminates, hence, f(N)=0. Thus A[1]=1 and since F_2 = 1 the claim is proven. We now take some k \\geq 2. All k values that A[1] takes on, are ordered and can be written as: d_1 < ...< d_k. Suppose that the largest value of these values, which is d_k, occurs for the first time at position 1 during iteration r of the algorithm. Denote t=A[d_k]. During the (r+1)'th iteration, we know A[1]=t and A[d_k]=d_k. The remaining iterations will always retain A[d_k]=d_k. Hence A[1] can now take on at most k-1 values. Using induction for k, it follows that f(N) - r \\leq F_k and also that d_1=1. \\square Suppose we would exchange d_1=1 and d_k in iteration r Then A[1]=1 and the algorithm terminates; f(N)=r. During the algorithm, we are sure that both d_k and t have never been at position A[1], unless t=1. Suppose t=1. Then r \\leq F_k since A[1] takes on at most k-1 distinct values. So it follows that f(N) \\leq r+1 \\leq F_{k+1}. Suppose t>1. Then r \\leq F_{k-1} since A[1] takes on at most k-2 distinct values. Using the claim, it follows that f(N) \\leq F_k + r \\leq F_{k+1}. This proves the theorem. \\square Besides these results, Morales and Sudborough have recently proven that the lower bound for f(N) is a quadratic function in N. The optimal values are, however, still unknown. There have been several attempts to find the optimal values, for example by A. Pepperdine. For rows with 17 or fewer numbers, the exact solution is known. Larger rows only have lower bounds, which is shown on the right. {| class=\"wikitable\" |- ! row length !!scope=\"col\" style=\"width: 20px;\"|1 !!scope=\"col\" style=\"width: 20px;\"|2 !!scope=\"col\" style=\"width: 20px;\"|3 !!scope=\"col\" style=\"width: 20px;\"|4 !!scope=\"col\" style=\"width: 20px;\"|5 !!scope=\"col\" style=\"width: 20px;\"|6 !!scope=\"col\" style=\"width: 20px;\"|7 !!scope=\"col\" style=\"width: 20px;\"|8 !!scope=\"col\" style=\"width: 20px;\"|9 !!scope=\"col\" style=\"width: 20px;\"|10 !!scope=\"col\" style=\"width: 20px;\"|11 !!scope=\"col\" style=\"width: 20px;\"|12 !!scope=\"col\" style=\"width: 20px;\"|13 !!scope=\"col\" style=\"width: 20px;\"|14 !!scope=\"col\" style=\"width: 20px;\"|15 !!scope=\"col\" style=\"width: 20px;\"|16 !!scope=\"col\" style=\"width: 20px;\"|17 |- style=\"text-align:center;\" | maximal number of iterations ||0 ||1 ||2 ||4 ||7 ||10 ||16 ||22 ||30 ||38 ||51 ||65 ||80 ||101 ||113 ||139 ||159 |} It is yet unknown whether this problem is NP-hard. ===Topdrops=== A similar problem is topdrops, where the same playing cards are used. In this problem, the first card of the pile is shown (and has value A[1]). Take the first A[1] cards of the pile, change the order and place them back on the bottom of the pile (which contrasts topswops, where the cards are placed at the top). This problem allows for infinite loops. As an example, we consider the row 2,1,3,4. By applying the algorithm, the following sequence is obtained: * 2 1 3 4 * 3 4 1 2 * 2 1 4 3 * 4 3 1 2 * 2 1 3 4 whereafter the original row is found again. ===Botswops=== In this variant, the bottom card of the pile is taken (and again named A[1]). Then the first A[1] cards of the pile are swapped. Unless the bottom card is the highest card in the pile, nothing happens. This makes the problem uninteresting due to the limited behaviour. ===Botdrops=== The final variant is botdrops where the bottom card of the pile is taken (again A[1]). In this variant, the bottom A[1] cards are swapped. == References == ==External links== *OEIS: page 375 (topswops) *OEIS: page 376 (topswops which ends up sorted) *Rosetta code: Computing Topswops in multiple programming languages *Topswops competition to compute the maximal number of iterations Category:John Horton Conway Category:Recreational mathematics ",
    "title": "Topswops"
}