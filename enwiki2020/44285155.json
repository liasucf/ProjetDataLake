{
    "id": "44285155",
    "text": "In the C, C++, and D programming languages, a type qualifier is a keyword that is applied to a type, resulting in a qualified type. For example, `const int` is a qualified type representing a constant integer, while `int` is the corresponding unqualified type, simply an integer. In D these are known as type constructors, by analogy with constructors in object-oriented programming. Type qualifiers are a way of expressing additional information about a value through the type system, and ensuring correctness in the use of the data. Type qualifiers are not generally used outside the C/C++ family of languages: many languages have a notion of constants, but express this by the name binding being constant (a \"variable that doesn't vary\"), rather than through the type system; see alternatives, below. ==By language== ===C/C++=== and C11, there are four type qualifiers in standard C: `const` (C89), `volatile` (C89), `restrict` (C99) and `_Atomic` (C11) \u2013 the latter has a private name to avoid clashing with user-defined names.C11:The New C Standard, Thomas Plum The first two of these, `const` and `volatile`, are also present in C++, and are the only type qualifiers in C++. Thus in C++ the term \"cv- qualified type\" (for const and volatile) is often used for \"qualified type\", while the terms \"c-qualified type\" and \"v-qualified type\" are used when only one of the qualifiers is relevant. Of these, `const` is by far the best-known and most used, appearing in the C and C++ standard libraries and encountered in any significant use of these languages, which must satisfy const- correctness. The other qualifiers are used for low-level programming, and while widely used there, are rarely used by typical programmers. For a time however `volatile` was used by some C++ programmers for synchronization during threading, though this was discouraged and is now broken in most compilers. ===D=== In D the type constructors are `const`, `immutable`, `shared`, and `inout`. `immutable` is a stronger variant of `const`, indicating data that can never change its value, while `const` indicates data that cannot be changed through this reference: it is a constant view on possibly mutable data. `shared` is used for shared data in multi-threading (as `volatile` was briefly used for in C++). `inout` is a wildcard used to allow functions that do not modify data (and thus are only concerned with the unqualified type of the data) to return the same qualified type as the input. `const` and `immutable` can also be used as storage class specifiers. ==Syntax== In C and C++, a type is given in a function declaration or variable declaration by giving one or more type specifiers, and optionally type qualifiers. For example, an integer variable can be declared as: int x; where `int` is the type specifier. An unsigned integer variable can be declared as: unsigned int x; where both `unsigned` and `int` are type specifiers. A constant unsigned integer variable can be declared as: const unsigned int x; where `const` is a type qualifier, which the qualified type of `x` is `const unsigned int` and the unqualified type is `unsigned int`. Variable declarations further have an optional storage class specifier. Properly this is a separate topic, distinct from the type, though `const` on a variable declaration is also taken to have implications for the storage class, namely that it can be stored in read-only memory. ==Volatile-correctness== The other qualifier in C and C++, `volatile`, indicates that an object may be changed by something external to the program at any time and so must be re-read from memory every time it is accessed. The qualifier is most often found in code that manipulates hardware directly (such as in embedded systems and device drivers) and in multithreaded applications (though often used incorrectly in that context; see external links at volatile variable). It can be used in exactly the same manner as `const` in declarations of variables, pointers, references, and member functions, and in fact, `volatile` is sometimes used to implement a similar design-by-contract strategy which Andrei Alexandrescu calls `volatile`-correctness,\"Generic: volatile \u2014 Multithreaded Programmer's Best Friend Volatile-Correctness or How to Have Your Compiler Detect Race Conditions for You\" by Andrei Alexandrescu in the C/C++ Users Journal C++ Experts Forum though this is far less common than `const`-correctness. The `volatile` qualifier also can be stripped by `const_cast`, and it can be combined with the `const` qualifier as in this sample: // Set up a reference to a read-only hardware register that is // mapped in a hard-coded memory location. const volatile int & hardwareRegister = *reinterpret_cast(0x8000); int currentValue = hardwareRegister; // Read the memory location int newValue = hardwareRegister; // Read it again hardwareRegister = 5; // Error, cannot write to a const location Because `hardwareRegister` is `volatile`, there is no guarantee that it will hold the same value on two successive reads even though the programmer cannot modify it. The semantics here indicate that the register's value is read-only but not necessarily unchanging. ==History== The notion of a type qualifier was introduced, along with the example of `readonly` (later renamed `const`) by Bjarne Stroustrup in a Bell Labs internal Technical Memorandum of 1981,Bjarne Stroustrup, \"Extensions of the C Language Type Concept.\", Bell Labs internal Technical Memorandum, January 5, 1981. and implemented in C with Classes, the predecessor to C++.Sibling Rivalry: C and C++, Bjarne Stroustrup, 2002, p. 5 As to motivation, Stroustrup writes: :\"It served two functions: as a way of defining a symbolic constant that obeys scope and type rules (that is, without using a macro) and as a way of deeming an object in memory immutable.\" `const` was then adopted in C as part of standardization, and appears in C89 (and subsequent versions) along with another type qualifier, `volatile`, which was invented by the ANSI C standard committee (X3J11).Dennis M. Ritchie, \"The Development of the C Language \", 2003: \"X3J11 also introduced a host of smaller additions and adjustments, for example, the type qualifiers const and volatile, and slightly different type promotion rules.\" `volatile` appeared by 1985;It appears in the notes for the European UNIX System User Group (EUUC) meeting technical talk \"The ANSI Draft Standard for the C Programming Language\" by Mike Banahan, 1985 September 13, as printed in the Australian Unix systems User Group Newsletter (AUUGN), Vol 6, No 6, p. 73 and an early use was in compiling the UNIX kernel for MIPS, to allow optimized compiling by preventing usual optimizations from being applied to volatile variables. A further qualifier, `noalias`, was suggested at the December 1987 meeting of the X3J11 committee, but was rejected; its goal was ultimately fulfilled by the `restrict` qualifier in C99. The motivation for `noalias` was complementary to `volatile`, namely that it indicated that even normally unsafe optimizations could be performed. Ritchie was not very supportive of type qualifiers, arguing that they did not \"carry their weight\", but ultimately did not argue for their removal from the standard;\"Let me begin by saying that I'm not convinced that even the pre-December qualifiers ('const' and 'volatile') carry their weight; I suspect that what they add to the cost of learning and using the language is not repaid in greater expressiveness. 'Volatile', in particular, is a frill for esoteric applications, and much better expressed by other means. Its chief virtue is that nearly everyone can forget about it. 'Const' is simultaneously more useful and more obtrusive; you can't avoid learning about it, because of its presence in the library interface. Nevertheless, I don't argue for the extirpation of qualifiers, if only because it is too late.\" he did oppose `noalias` however, and it was dropped from the draft. Java does not have type qualifiers, and conspicuously omitted `const`: a 1999 proposal to add it was rejected, notably because adding it after the fact and then changing the standard library to use it consistently would have broken compatibility.JDK-4211070: Java should support const parameters (like C++) for code However, Java initially left open the possibility of implementing `const`, noticeable in that `const` is a reserved word, though it is not actually used as a keyword. Instead, Java has the object-oriented keyword `final`, which is used to qualify attributes (and thence also for local variables) as constant, but not to qualify types. ==Alternatives== Other languages take a different approach, considering constancy a property of an identifier (or name binding), not a type. Such languages thus have constant identifiers (corresponding to \"variables\" that do not vary) with single assignment, but do not have a notion of const- correctness: since constancy is not part of the type, there is no possibility of type mismatch. Examples include Ada 83 with constant objects and a `constant` keyword,1815A, 3.2.1. Object Declarations: \"The declared object is a constant if the reserved word constant appears in the object declaration; the declaration must then include an explicit initialization. The value of a constant cannot be modified after initialization. Formal parameters of mode in of subprograms and entries, and generic formal parameters of mode in, are also constants; a loop parameter is a constant within the corresponding loop; a subcomponent or slice of a constant is a constant.\" and Java with the `final` keyword. ==Notes== ==References== ==External links== * C11 standard * Type Constructors Category:C (programming language) Category:C++ ",
    "title": "Type qualifier"
}