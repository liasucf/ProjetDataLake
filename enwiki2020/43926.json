{
    "id": "43926",
    "text": "In computing, the Java API for XML Processing, or JAXP ( ), one of the Java XML Application programming interfaces (API)s, provides the capability of validating and parsing XML documents. It has three basic parsing interfaces: * the Document Object Model parsing interface or DOM interface * the Simple API for XML parsing interface or SAX interface * the Streaming API for XML or StAX interface (part of JDK 6; separate jar available for JDK 5) In addition to the parsing interfaces, the API provides an XSLT interface to provide data and structural transformations on an XML document. JAXP was developed under the Java Community Process as JSR 5 (JAXP 1.0), JSR 63 (JAXP 1.1 and 1.2), and JSR 206 (JAXP 1.3). {| |- ! Java SE version !! JAXP version bundled |- | 1.4 || 1.1 |- | 1.5 || 1.3 |- | 1.6 || 1.4 |- | 1.7.0 || 1.4.5 |- | 1.7.40 || 1.5 |- | 1.8 || 1.6https://www.jcp.org/en/jsr/detail?id=206 |} JAXP version 1.4.4 was released on September 3, 2010. JAXP 1.3 was declared end-of-life on February 12, 2008. == DOM interface == The DOM interface parses an entire XML document and constructs a complete in-memory representation of the document using the classes and modeling the concepts found in the Document Object Model(DOM) Level 2 Core Specification. The DOM parser is called a `DocumentBuilder`, as it builds an in-memory `Document` representation. The javax.xml.parsers.DocumentBuilder is created by the javax.xml.parsers.DocumentBuilderFactory. The `DocumentBuilder` creates an instance - a tree structure containing nodes in the XML Document. Each tree node in the structure implements the interface. Among the many different types of tree nodes, each representing the type of data found in an XML document, the most important include: * element nodes that may have attributes * text nodes representing the text found between the start and end tags of a document element. == SAX interface == The javax.xml.parsers.SAXParserFactory creates the SAX parser, called the SAXParser. Unlike the DOM parser, the SAX parser does not create an in-memory representation of the XML document and so runs faster and uses less memory. Instead, the SAX parser informs clients of the XML document structure by invoking callbacks, that is, by invoking methods on an org.xml.sax.helpers.DefaultHandler instance provided to the parser. This way of accessing document is called Streaming XML. The `DefaultHandler` class implements the ContentHandler, the ErrorHandler, the DTDHandler, and the EntityResolver interfaces. Most clients will be interested in methods defined in the `ContentHandler` interface that are called when the SAX parser encounters the corresponding elements in the XML document. The most important methods in this interface are: * `startDocument()` and `endDocument()` methods that are called at the start and end of a XML document. * `startElement()` and `endElement()` methods that are called at the start and end of a document element. * `characters()` method that is called with the text data contents contained between the start and end tags of an XML document element. Clients provide a subclass of the `DefaultHandler` that overrides these methods and processes the data. This may involve storing the data into a database or writing it out to a stream. During parsing, the parser may need to access external documents. It is possible to store a local cache for frequently used documents using an XML Catalog. This was introduced with Java 1.3 in May 2000.Compare the Java 1.2.1 API index with the 1.3 index. The Java Specification Request (JSR) 5, XML Parsing Specification, was finalised on 21 March, 2000. == StAX interface == StAX was designed as a median between the DOM and SAX interface. In its metaphor, the programmatic entry point is a cursor that represents a point within the document. The application moves the cursor forward - 'pulling' the information from the parser as it needs. This is different from an event based API - such as SAX - which 'pushes' data to the application - requiring the application to maintain state between events as necessary to keep track of location within the document. == XSLT interface == The XML Stylesheet Language for Transformations, or XSLT, allows for conversion of an XML document into other forms of data. JAXP provides interfaces in package javax.xml.transform allowing applications to invoke an XSLT transformation. This interface was originally called TrAX (Transformation API for XML), and was developed by an informal collaboration between the developers of a number of Java XSLT processors. Main features of the interface are * a factory class allowing the application to select dynamically which XSLT processor it wishes to use (TransformerFactory, TransformerFactory.NewInstance(), TransformerFactory.newInstance(java.lang.String,_java.lang.ClassLoader)). * methods on the factory class to create a Templates object, representing the compiled form of a stylesheet. This is a thread-safe object that can be used repeatedly, in series or in parallel, to apply the same stylesheet to multiple source documents (or to the same source document with different parameters) (TransformerFactory.newTemplates(javax.xml.transform.Source), also TransformerFactory.newTransformer(javax.xml.transform.Source), TransformerFactory.newTransformer()), a method on the Templates object to create a Transformer, representing the executable form of a stylesheet (Templates.newTransformer()) This cannot be shared across threads, though it is serially reusable. The Transformer provides methods to set stylesheet parameters and serialization options (for example, whether output should be indented), and a method to actually run the transformation. (Transformer.transform(javax.xml.transform.Source,_javax.xml.transform.Result)). Two abstract interfaces Source and Result are defined to represent the input and output of the transformation. This is a somewhat unconventional use of Java interfaces, since there is no expectation that a processor will accept any class that implements the interface - each processor can choose which kinds of Source or Result it is prepared to handle. In practice all JAXP processors support the three standard kinds of Source (`DOMSource`, `SAXSource`, `StreamSource`) and the three standard kinds of Result (`DOMResult`, `SAXResult`, `StreamResult`) and possibly other implementations of their own. === Example === The most primitive but complete example of XSLT transformation launching may look like this: /* file src/examples/xslt/XsltDemo.java */ package examples.xslt; import java.io.StringReader; import java.io.StringWriter; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource; public class XsltDemo { public static void main(String[] args) throws TransformerFactoryConfigurationError, TransformerException { String xsltResource = \" \"+ \" \"+ \" \"+ \" \"+ \" world \"+ \" \"+ \"\"; String xmlSourceResource = \" \"+ \"\"; StringWriter xmlResultResource = new StringWriter(); Transformer xmlTransformer = TransformerFactory.newInstance().newTransformer( new StreamSource(new StringReader(xsltResource)) ); xmlTransformer.transform( new StreamSource(new StringReader(xmlSourceResource)), new StreamResult(xmlResultResource) ); System.out.println(xmlResultResource.getBuffer().toString()); } } It applies the following hardcoded XSLT transformation: world To the following hardcoded XML document: The result of execution will be hello world == References == == External links == *JAXP Reference Implementation Project Home Page Category:Java API for XML XML Processing Category:XML parsers ",
    "title": "Java API for XML Processing"
}