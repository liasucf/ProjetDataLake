{
    "id": "60378307",
    "text": "Broadcast is a collective communication primitive in parallel programming to distribute programming instructions or data to nodes in a cluster it is the reverse operation of reduce. The broadcast operation is widely used in parallel algorithms, such as matrix-vector multiplication, Gaussian elimination and shortest paths. The Message Passing Interface implements broadcast in `MPI_Bcast`.MPI: A Message-Passing Interface StandardVersion 3.0, Message Passing Interface Forum, pp. 148, 2012 == Definition == A message M [1 .. m]of length n should be distributed from one node to all other p-1 nodes. T_\\text{byte}is the time it takes to send one byte. T_\\text{start}is the time it takes for a message to travel to another node, independent of its length. Therefore, the time to send a package from one node to another is t = size*T_\\text{byte} + T_\\text{start}. p is the number of nodes and the number of processors. == Binomial Tree Broadcast Michael Ikkert, T. Kieritz, P. Sanders Parralele Algorithme - Script (German), Karlsruhe Institute of Technology, pp. 29-32, 2009 == Binomial Tree Broadcast With Binomial Tree Broadcast the whole message is sent at once. Each node that has already received the message sends it on further. This grows exponentially as each time step the amount of sending nodes is doubled. The algorithm is ideal for short messages but falls short with longer ones as during the time when the first transfer happens and only one node is busy. Sending a message to all nodes takes log_2(p) t time which results in a runtime of log_2(p) ( m T_\\text{byte} + T_\\text{start}) Message M id := node number p := number of nodes if id > 0 blocking_receive M for (i := ceil(log_2(id)) - 1; i >= 0; i--) if (id + 2^i <= p) send M to node id + 2^i == Linear Pipeline Broadcast == Pipeline Broadcast The message is split up into k packages and send piecewise from node n to node n+1. The time needed to distribute the first message piece is p t = \\frac{m}{k} T_\\text{byte} + T_\\text{start} whereby t is the time needed to send a package from one processor to another. Sending a whole message takes ( p + k )( \\frac{mT_\\text{byte}}{k} + T_\\text{start} ) = (p + k) t = p t + k t. Optimal is to choose k = \\sqrt{ \\frac{ m (p-2) T_\\text{byte} }{T_\\text{start} } } resulting in a runtime of approximately m T_\\text{byte} + p T_\\text{start} + \\sqrt{m p T_\\text{start} T_\\text{byte}} The run time is dependent on not only message length but also the number of processors that play roles. This approach shines when the length of the message is much larger than the amount of processors. Message M := [m_1, m_2, ..., m_n] id = node number for (i := 1; i <= n; i++) in parallel if (id != 0) blocking_receive m_i if (id != n) send m_i to node id + 1 == Pipelined Binary Tree Broadcast == Pipelined Binary Tree Broadcast This algorithm combines Binomial Tree Broadcast and Linear Pipeline Broadcast, which makes the algorithm work well for both short and long messages. The aim is to have as many nodes work as possible while maintaining the ability to send short messages quickly. A good approach is to use Fibonacci trees for splitting up the tree, which are a good choice as a message cannot be sent to both children at the same time. This results in a binary tree structure. We will assume in the following that communication is full-duplex. The Fibonacci tree structure has a depth of about d \\approx log_\\Phi(p)whereby \\Phi = \\frac{1+\\sqrt{5}}{2}the golden ratio. The resulting runtime is (\\frac{m}{k}T_\\text{byte} + T_\\text{start})(d + 2k - 2). Optimal is k = \\sqrt{\\frac{n (d-2) T_\\text{byte} }{ 3T_\\text{start}}}. This results in a runtime of 2mT_\\text{byte} + T_\\text{start} log_\\Phi(p) + \\sqrt{2m log_\\Phi(p) T_\\text{start} T_\\text{byte}}. Message M := [m_1, m_2, ..., m_k] for i = 1 to k if (hasParent()) blocking_receive m_i if (hasChild(left_child)) send m_i to left_child if (hasChild(right_child)) send m_i to right_child == Two Tree Broadcast (23-Broadcast) Michael Ikkert, T. Kieritz, P. Sanders Parralele Algorithme - Script (German), Karlsruhe Institute of Technology, pp.33-37, 2009P. Sanders (German), Karlsruhe Institute of Technology, pp. 82-96, 2018 == Visualization of Two Tree Broadcast === Definition === This algorithm aims to improve on some disadvantages of tree structure models with pipelines. Normally in tree structure models with pipelines (see above methods), leaves receive just their data and cannot contribute to send and spread data. The algorithm concurrently uses two binary trees to communicate over. Those trees will be called tree A and B. Structurally in binary trees there are relatively more leave nodes than inner nodes. Basic Idea of this algorithm is to make a leaf node of tree A be an inner node of tree B. It has also the same technical function in opposite side from B to A tree. This means, two packets are sent and received by inner nodes and leaves in different steps. === Tree construction === Examples of tree structures depending on the number of processors The number of steps needed to construct construct two parallel- working binary trees is dependent on the amount of processors. Like with other structures one processor can is the root node who sends messages to two trees. It is not necessary to set a root node, because it is not hard to recognize that the direction of sending messages in binary tree is normally top to bottom. There is no limitation on the number of processors to build two binary trees. Let the height of the combined tree be . Tree A and B can have a height of h -1 . Especially, if the number of processors correspond to p = 2^h - 1 , we can make both sides trees and a root node. To construct this model efficiently and easily with a fully built tree, we can use two methods called \"Shifting\" and \"Mirroring\" to get second tree. Let assume tree A is already modelled and tree B is supposed to be constructed based on tree A. We assume that we have p processors ordered from 0 to p-1 . ==== Shifting ==== Tree construction using \"Shifting\" The \"Shifting\" method, first copies tree A and moves every node one position to the left to get tree B. The node, which will be located on -1, becomes a child of processor p-2 . ==== Mirroring ==== Tree construction using mirroring \"Mirroring\" is ideal for an even number of processors. With this method tree B can be more easily constructed by tree A, because there are no structural transformations in order to create the new tree. In addition, a symmetric process makes this approach simple. This method can also handle an odd number of processors, in this case, we can set processor p-1 as root node for both trees. For the remaining processors \"Mirroring\" can be used. === Coloring === We need to find a schedule in order to make sure that no processor has to send or receive two messages from two trees in a step. The edge, is a communication connection to connect two nodes, and can be labelled as either 0 or 1 to make sure that every processor can alternate between 0 and 1-labelled edges. The edges of and can be colored with two colors (0 and 1) such that * no processor is connected to its parent nodes in and using edges of the same color- * no processor is connected to its children nodes in or using edges of the same color. In every even step the edges with 0 are activated and edges with 1 are activated in every odd step. === Time complexity === In this case the number of packet k is divided in half for each tree. Both trees are working together the total number of packets k = k/2 + k/2 (upper tree + bottom tree) In each binary tree sending a message to another nodes takes 2*i steps until a processor has at least a packet in step i. Therefore, we can calculate all steps as d := log_2 (p+1) => log_2(p+1) \\approx log_2(p) . The resulting run time is T(m,p,k) \\approx (\\frac{m}{k}T_\\text{byte} + T_\\text{start})(2d + k - 1). (Optimal k = \\sqrt{\\frac{m (2d-1) T_\\text{byte} }{ T_\\text{start}}}) This results in a run time of T(m,p) \\approx mT_\\text{byte} + T_\\text{start} * 2log_2 (p) + \\sqrt{m *2log_2 (p) T_\\text{start} T_\\text{byte}}. == ESBT-Broadcasting (Edge-disjoint Spanning Binomial Trees)Michael Ikkert, T. Kieritz, P. Sanders Parralele Algorithme - Script (German), Karlsruhe Institute of Technology, pp.40-42, 2009P. Sanders (German), Karlsruhe Institute of Technology, pp. 101-104, 2018 == In this section, another broadcasting algorithm with an underlying telephone communication model will be introduced. A Hypercube creates network system with p = 2^d (d = 0,1,2,3,...) . Every node is represented by binary {0,1} depending on the number of dimensions. Fundamentally ESBT(Edge-disjoint Spanning Binomial Trees) is based on hypercube graphs, pipelining( m messages are divided by k packets) and binomial trees. The Processor 0^d cyclically spreads packets to roots of ESBTs. The roots of ESBTs broadcast data with binomial tree. To leave all of k from p_0, k steps are required, because all packets are distributed by p_0 . It takes another d steps until the last leaf node receives the packet. In total d+ k steps are necessary to broadcast m message through ESBT. The resulting run time is T(m,p,k) = (\\frac{m}{k}T_\\text{byte} + T_\\text{start})(k+d). (k = \\sqrt{\\frac{m d T_\\text{byte} }{ T_\\text{start}}}). This results in a run time of T(m,p) := mT_\\text{byte} + dT_\\text{start} + \\sqrt{mdT_\\text{start} T_\\text{byte}}. == See also == * Reduce (parallel pattern) * Reduction Operator == References == Category:Parallel computing Category:Algorithms ",
    "title": "Broadcast (parallel pattern)"
}