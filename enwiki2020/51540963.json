{
    "id": "51540963",
    "text": "Cache prefetching is a technique used by computer processors to boost execution performance by fetching instructions or data from their original storage in slower memory to a faster local memory before it is actually needed (hence the term 'prefetch'). Most modern computer processors have fast and local cache memory in which prefetched data is held until it is required. The source for the prefetch operation is usually main memory. Because of their design, accessing cache memories is typically much faster than accessing main memory, so prefetching data and then accessing it from caches is usually many orders of magnitude faster than accessing it directly from main memory. Prefetching can be done with non-blocking cache control instructions. == Data vs. instruction cache prefetching == Cache prefetching can either fetch data or instructions into cache. * Data prefetching fetches data before it is needed. Because data access patterns show less regularity than instruction patterns, accurate data prefetching is generally more challenging than instruction prefetching. * Instruction prefetching fetches instructions before they need to be executed. The first mainstream microprocessors to use some form of instruction prefetch were the Intel 8086 (six bytes) and the Motorola 68000 (four bytes). In recent years, all high-performance processors use prefetching techniques. == Hardware vs. software cache prefetching == Cache prefetching can be accomplished either by hardware or by software. * Hardware based prefetching is typically accomplished by having a dedicated hardware mechanism in the processor that watches the stream of instructions or data being requested by the executing program, recognizes the next few elements that the program might need based on this stream and prefetches into the processor's cache. * Software based prefetching is typically accomplished by having the compiler analyze the code and insert additional \"prefetch\" instructions in the program during compilation itself. == Methods of hardware prefetching == === Stream buffers === * Stream buffers were developed based on the concept of \"one block lookahead (OBL) scheme\" proposed by Alan Jay Smith. * Stream buffers are one of the most common hardware based prefetching techniques in use. This technique was originally proposed by Norman Jouppi in 1990 and many variations of this method have been developed since. The basic idea is that the cache miss address (and k subsequent addresses) are fetched into a separate buffer of depth k. This buffer is called a stream buffer and is separate from cache. The processor then consumes data/instructions from the stream buffer if the address associated with the prefetched blocks match the requested address generated by the program executing on the processor. The figure below illustrates this setup: 400x400px * Whenever the prefetch mechanism detects a miss on a memory block, say A, it allocates a stream to begin prefetching successive blocks from the missed block onward. If the stream buffer can hold 4 blocks, then we would prefetch A+1, A+2, A+3, A+4 and hold those in the allocated stream buffer. If the processor consumes A+1 next, then it shall be moved \"up\" from the stream buffer to the processor's cache. The first entry of the stream buffer would now be A+2 and so on. This pattern of prefetching successive blocks is called Sequential Prefetching. It is mainly used when contiguous locations are to be prefetched. For example, it is used when prefetching instructions. * This mechanism can be scaled up by adding multiple such 'stream buffers' - each of which would maintain a separate prefetch stream. For each new miss, there would be a new stream buffer allocated and it would operate in a similar way as described above. * The ideal depth of the stream buffer is something that is subject to experimentation against various benchmarks and depends on the rest of the microarchitecture involved. Another pattern of prefetching instructions is to prefetch addresses that are s addresses ahead in the sequence. It is mainly used when the consecutive blocks that are to be prefetched are s addresses apart. This is termed as Strided Prefetching. == Methods of software prefetching == === Compiler directed prefetching === Compiler directed prefetching is widely used within loops with a large number of iterations. In this technique, the compiler predicts future cache misses and inserts a prefetch instruction based on the miss penalty and execution time of the instructions. These prefetches are non-blocking memory operations, i.e. these memory accesses do not interfere with actual memory accesses. They do not change the state of the processor or cause page faults. One main advantage of software prefetching is that it reduces the number of compulsory cache misses. The following example shows the how a prefetch instruction will be added into a code to improve cache performance. Consider a for loop as shown below: for (int i=0; i<1024; i++) { array1[i] = 2 * array1[i]; } At each iteration, the ith element of the array \"array1\" is accessed. Therefore, we can prefetch the elements that are going to be accessed in future iterations by inserting a \"prefetch\" instruction as shown below: for (int i=0; i<1024; i++) { prefetch (array1 [i + k]); array1[i] = 2 * array1[i]; } Here, the prefetch stride, k depends on two factors, the cache miss penalty and the time it takes to execute a single iteration of the for loop. For instance, if one iteration of the loop takes 7 cycles to execute, and the cache miss penalty is 49 cycles then we should have k = 49/7 = 7 \\- which means that we prefetch 7 elements ahead. With the first iteration, i will be 0, so we prefetch the 7th element. Now, with this arrangement, the first 7 accesses (i=0->6) will still be misses (under the simplifying assumption that each element of array1 is in a separate cache line of its own). == Comparison of hardware and software prefetching == * While software prefetching requires programmer or compiler intervention, hardware prefetching requires special hardware mechanisms. * Software prefetching works well only with loops where there is regular array access as the programmer has to hand code the prefetch instructions. Whereas, hardware prefetchers work dynamically based on the program's behavior at runtime. * Hardware prefetching also has less CPU overhead when compared to software prefetching. == Metrics of cache prefetching == There are three main metrics to judge cache prefetching === Coverage === Coverage is the fraction of total misses that are eliminated because of prefetching, i.e. Coverage = \\frac{\\text{Cache Misses eliminated by Prefetching}}{\\text{Total Cache Misses}}, where, \\text{Total Cache Misses} = (\\text{Cache misses eliminated by prefetching}) + (\\text{Cache misses not eliminated by prefetching}) === Accuracy === Accuracy is the fraction of total prefetches that were useful - i.e. the ratio of the number of memory addresses prefetched were actually referenced by the program to the total prefetches done. \\text{Prefetch Accuracy} = \\frac{\\text{Cache Misses eliminated by prefetching}}{(\\text{Useless Cache Prefetches}) + (\\text{Cache Misses eliminated by prefetching})} While it appears that having perfect accuracy might imply that there are no misses, this is not the case. The prefetches themselves might result in new misses if the prefetched blocks are placed directly into the cache. Although these may be a small fraction of the total number of misses we might see without any prefetching, this is a non-zero number of misses. === Timeliness === The qualitative definition of timeliness is how early a block is prefetched versus when it is actually referenced. An example to further explain timeliness is as follows : Consider a for loop where each iteration takes 3 cycles to execute and the 'prefetch' operation takes 12 cycles. This implies that for the prefetched data to be useful, we must start the prefetch 12/3 = 4 iterations prior to its usage to maintain timeliness. == See also == * Prefetch input queue * Link prefetching * Prefetcher * Cache control instruction ==References== Category:Cache (computing) ",
    "title": "Cache prefetching"
}