{
    "id": "1284311",
    "text": "Johnson's algorithm is a way to find the shortest paths between all pairs of vertices in an edge-weighted, directed graph. It allows some of the edge weights to be negative numbers, but no negative-weight cycles may exist. It works by using the Bellman\u2013Ford algorithm to compute a transformation of the input graph that removes all negative weights, allowing Dijkstra's algorithm to be used on the transformed graph.. Section 25.3, \"Johnson's algorithm for sparse graphs\", pp. 636\u2013640.. It is named after Donald B. Johnson, who first published the technique in 1977.. A similar reweighting technique is also used in Suurballe's algorithm for finding two disjoint paths of minimum total length between the same two vertices in a graph with non-negative edge weights.. ==Algorithm description== Johnson's algorithm consists of the following steps: #First, a new node is added to the graph, connected by zero- weight edges to each of the other nodes. #Second, the Bellman\u2013Ford algorithm is used, starting from the new vertex , to find for each vertex the minimum weight of a path from to . If this step detects a negative cycle, the algorithm is terminated. #Next the edges of the original graph are reweighted using the values computed by the Bellman\u2013Ford algorithm: an edge from to , having length , is given the new length . #Finally, is removed, and Dijkstra's algorithm is used to find the shortest paths from each node to every other vertex in the reweighted graph. The distance in the original graph is then computed for each distance ( , ), by adding to the distance returned by Dijkstra's algorithm. ==Example== The first three stages of Johnson's algorithm are depicted in the illustration below. center The graph on the left of the illustration has two negative edges, but no negative cycles. At the center is shown the new vertex , a shortest path tree as computed by the Bellman\u2013Ford algorithm with as starting vertex, and the values computed at each other node as the length of the shortest path from to that node. Note that these values are all non-positive, because has a length-zero edge to each vertex and the shortest path can be no longer than that edge. On the right is shown the reweighted graph, formed by replacing each edge weight by . In this reweighted graph, all edge weights are non-negative, but the shortest path between any two nodes uses the same sequence of edges as the shortest path between the same two nodes in the original graph. The algorithm concludes by applying Dijkstra's algorithm to each of the four starting nodes in the reweighted graph. ==Correctness== In the reweighted graph, all paths between a pair and of nodes have the same quantity added to them. The previous statement can be proven as follows: Let be an path. Its weight W in the reweighted graph is given by the following expression: :\\bigl(w(s, p_1) + h(s) - h(p_1)\\bigr) + \\bigl(w(p_1, p_2) + h(p_1) - h(p_2)\\bigr) + ... + \\bigl(w(p_n, t) + h(p_n) - h(t)\\bigr). Every +h(p_i) is cancelled by -h(p_i) in the previous bracketed expression; therefore, we are left with the following expression for W: :\\bigl(w(s, p_1) + w(p_1, p_2) + ... + w(p_n, t)\\bigr)+ h(s) - h(t) The bracketed expression is the weight of p in the original weighting. Since the reweighting adds the same amount to the weight of every path, a path is a shortest path in the original weighting if and only if it is a shortest path after reweighting. The weight of edges that belong to a shortest path from q to any node is zero, and therefore the lengths of the shortest paths from q to every node become zero in the reweighted graph; however, they still remain shortest paths. Therefore, there can be no negative edges: if edge uv had a negative weight after the reweighting, then the zero-length path from q to u together with this edge would form a negative-length path from q to v, contradicting the fact that all vertices have zero distance from q. The non- existence of negative edges ensures the optimality of the paths found by Dijkstra's algorithm. The distances in the original graph may be calculated from the distances calculated by Dijkstra's algorithm in the reweighted graph by reversing the reweighting transformation. ==Analysis== The time complexity of this algorithm, using Fibonacci heaps in the implementation of Dijkstra's algorithm, is O(|V|^2\\log |V| + |V||E|): the algorithm uses O(|V||E|) time for the Bellman\u2013Ford stage of the algorithm, and O(|V|\\log |V| + |E|) for each of the |V| instantiations of Dijkstra's algorithm. Thus, when the graph is sparse, the total time can be faster than the Floyd\u2013Warshall algorithm, which solves the same problem in time O(|V|^3). ==References== == External links == *Boost: All Pairs Shortest Paths Category:Graph algorithms Category:Search algorithms ",
    "title": "Johnson's algorithm"
}