{
    "id": "2212634",
    "text": "Linux API, Linux ABI, and in-kernel APIs and ABIs The Linux kernel provides several interfaces to user-space applications that are used for different purposes and that have different properties by design. There are two types of application programming interface (API) in the Linux kernel that are not to be confused: the \"kernel-user space\" API and the \"kernel internal\" API. == Linux API == The Linux API is composed out of the System Call Interface of the Linux kernel, the GNU C Library (by GNU), libcgroup, libdrm, libalsa and libevdev (by freedesktop.org). Linux API vs. POSIX API The Linux API is the kernel-user space API, which allows programs in user space to access system resources and services of the Linux kernel. It is composed out of the System Call Interface of the Linux kernel and the subroutines in the GNU C Library (glibc). The focus of the development of the Linux API has been to provide the usable features of the specifications defined in POSIX in a way which is reasonably compatible, robust and performant, and to provide additional useful features not defined in POSIX, just as the kernel- user space APIs of other systems implementing the POSIX API also provide additional features not defined in POSIX. The Linux API, by choice, has been kept stable over the decades through a policy of not introducing breaking changes; this stability guarantees the portability of source code. At the same time, Linux kernel developers have historically been conservative and meticulous about introducing new system calls. Much available free and open-source software is written for the POSIX API. Since so much more development flows into the Linux kernel as compared to the other POSIX-compliant combinations of kernel and C standard library, the Linux kernel and its API have been augmented with additional features. As far as these additional features provide a technical advantage, programming for the Linux API is preferred over the POSIX-API. Well-known current examples are udev, systemd and Weston. People such as Lennart Poettering openly advocate to prefer the Linux API over the POSIX API, where this offers advantages. At FOSDEM 2016, Michael Kerrisk explained some of the perceived issues with the Linux kernel's user-space API, describing that it contains multiple design errors by being non-extensible, unmaintainable, overly complex, of limited purpose, in violation of standards, and inconsistent. Most of those mistakes cannot be fixed because doing so would break the ABI that the kernel presents to the user space. === System Call Interface of the Linux kernel=== System Call Interface is the denomination for the entirety of all implemented and available system calls in a kernel. Various subsystems, such as e.g. the DRM define their own system calls and the entirety is called System Call Interface. Various issues with the organization of the Linux kernel system calls are being publicly discussed. Issues have been pointed out by Andy Lutomirski, Michael Kerrisk and others. === The C standard library === The GNU C Library is a wrapper around the Linux kernel System Call Interface. The GNU C Library is a wrapper around the system calls of the Linux kernel; the combination of the Linux kernel System Call Interface and glibc is what builds the Linux API. * GNU C Library (glibc) * Embedded GLIBC * uClibc * klibc * Newlib * musl * dietlibc * libbionic and libhybris ==== Additions to POSIX ==== As in other Unix-like systems, additional capabilities of the Linux kernel exist that are not part of POSIX: * cgroups subsystem, the system calls it introduces and libcgroup * The system calls of the Direct Rendering Manager, especially the driver-private ioctls for the command submission are not part of the POSIX specifications. * Advanced Linux Sound Architecture could set system calls, which are not part of the POSIX specifications * The system calls `futex` (fast userspace mutex), `epoll`, `splice`, `dnotify`, `fanotify`, and `inotify` have been exclusive to the Linux kernel so far. * The system call `getrandom` was introduced in version 3.17 of the Linux kernel mainline * `memfd` was proposed by the kdbus developers ** `memfd_create` was merged into the Linux kernel mainline in kernel version 3.17 * `readahead` initiates a file \"read-ahead\" into page cache DRM has been paramount for the development and implementations of well-defined and performant free and open- source graphics device drivers without which no rendering acceleration would be available at all, or even worse, only the 2D drivers would be available in the X.Org Server. DRM was developed for Linux, and since has been ported to other operating systems as well. === Further libraries === * libdrm (for Direct Rendering Manager) * libnl (The libnl suite is a collection of libraries providing APIs to netlink protocol based Linux kernel interfaces.) * libevdev (for evdev) * libasound (Advanced Linux Sound Architecture) * \u2026 == Linux ABI == ABI The term Linux ABI refers to a kernel\u2013user space ABI. The Application binary interface refers to the compiled binaries, in machine code. Any such ABI is therefore bound to the instruction set. Defining a useful ABI and keeping it stable is less the responsibility of the Linux kernel developers or of the developers of the GNU C Library, and more the task for Linux distributions and Independent software vendor (ISVs) who wish to sell and provide support for their proprietary software as binaries only for such a single Linux ABI, as opposed to supporting multiple Linux ABIs. An ABI has to be defined for every instruction set, such as x86, x86-64, MIPS, ARMv7-A (32-Bit), ARMv8-A (64-Bit), etc. with the endianness, if both are supported. It should be able to compile the software with different compilers against the definitions specified in the ABI and achieve full binary compatibility. Compilers that are free and open-source software are e.g. GNU Compiler Collection, LLVM/Clang. End-users are in fact not all interested in the Linux API (or the Windows API), but in the ABIs. == In-kernel APIs == There are a lot of kernel-internal APIs for all the subsystems to interface with one another. These are being kept fairly stable, but there is no guarantee for stability. In case new research or insights make a change seem favorable, an API is changed, all necessary rewrite and testing have to be done by the author. The Linux kernel is a monolithic kernel, hence device drivers are kernel components. To ease the burden of companies maintaining their (proprietary) device drivers out-of-tree, stable APIs for the device drivers have been repeatedly requested. The Linux kernel developers have repeatedly denied guaranteeing stable in-kernel APIs for device drivers. Guaranteeing such would have faltered the development of the Linux kernel in the past and would still in the future and, due to the nature of free and open-source software, are not necessary. Ergo, by choice, the Linux kernel has no stable in-kernel API. == In-kernel ABIs == Since there are no stable in-kernel APIs, there cannot be stable in-kernel ABIs. == Abstraction APIs == OpenGL is indeed an abstraction API to make use of diverse GPUs of multiple vendors without the need to program for each one specifically. Vulkan was to make the \"graphics driver\", i.e. the implementation of the graphics API, do less. For several use cases the Linux API is considered too low-level and higher abstraction APIs are used. Such of course still need to work on top of the low-level Linux APIs. Examples: * implementation of the OpenGL and Vulkan specifications in proprietary Linux graphics drivers and the free and open-source implementation in Mesa * implementation of the OpenAL specification * Simple DirectMedia Layer: abstraction API for input/sound/etc. available for many operating systems * Simple and Fast Multimedia Library: like above == See also == * The Linux Programming Interface by Michael Kerrisk * Semaphore (programming) * system call is a function to facilitate programs to request services from the kernel ** ** netlink socket family used for IPC between kernel and user space processes, designed as the successor of ; Netlink was added by Alan Cox during Linux kernel 1.3 development as a character driver interface to provide multiple kernel and user-space bidirectional communications links. Then, Alexey Kuznetsov extended it during Linux kernel 2.1 development to provide a flexible and extensible messaging interface to the new advanced routing infrastructure. Since then, Netlink sockets have become one of the main interfaces that kernel subsystems provide to user-space applications in Linux. Modern WNIC drivers use it to communicate with user-space. * Windows API article on various API available on Microsoft Windows operating systems ** windows.h header file for the C programming language which contains declarations for all of the functions in the Windows API * Wine a compatibility layer between Linux and programs written for Microsoft Windows * libhybris \u2013 compatibility layer between Linux and programs written for Android == References == == External links == *The Linux Kernel API 5.0, Memory Management APIs 5.0 (new sphinx format) *The API of Linux kernel 2.6.20 and 4.12 (in deprecated htmldocs format) *API/ABI changes review for Linux * The Linux Programming Interface book, Linux and glibc API changes since The Linux Programming Interface was released in 2010 *Interactive Linux kernel map with main API functions and structures, PDF version * Linux Device Drivers by Jonathan Corbet, Greg Kroah-Hartman and Alessandro Rubini, 3rd edition * Linux Kernel Linked List Explained ",
    "title": "Linux kernel interfaces"
}