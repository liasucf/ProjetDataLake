{
    "id": "20506304",
    "text": "In computer science, a property testing algorithm for a decision problem is an algorithm whose query complexity to its input is much smaller than the instance size of the problem. Typically property testing algorithms are used to decide if some mathematical object (such as a graph or a boolean function) has a \"global\" property, or is \"far\" from having this property, using only a small number of \"local\" queries to the object. For example, the following promise problem admits an algorithm whose query complexity is independent of the instance size (for an arbitrary constant \u03b5 > 0): :\"Given a graph G on n vertices, decide if G is bipartite, or G cannot be made bipartite even after removing an arbitrary subset of at most \\epsilon\\tbinom n2 edges of G.\" Property testing algorithms are central to the definition of probabilistically checkable proofs, as a probabilistically checkable proof is essentially a proof that can be verified by a property testing algorithm. ==Definition and variants== Formally, a property testing algorithm with query complexity q(n) and proximity parameter \u03b5 for a decision problem L is a randomized algorithm that, on input x (an instance of L) makes at most q(|x|) queries to x and behaves as follows: * If x is in L, the algorithm accepts x with probability at least \u2154. * If x is \u03b5-far from L, the algorithm rejects x with probability at least \u2154. Here, \"x is \u03b5-far from L\" means that the Hamming distance between x and any string in L is at least \u03b5|x|. A property testing algorithm is said to have one-sided error if it satisfies the stronger condition that the accepting probability for instances x \u2208 L is 1 instead of \u2154. A property testing algorithm is said be non-adaptive if it performs all its queries before it \"observes\" any answers to previous queries. Such an algorithm can be viewed as operating in the following manner. First the algorithm receives its input. Before looking at the input, using its internal randomness, the algorithm decides which symbols of the input are to be queried. Next, the algorithm observes these symbols. Finally, without making any additional queries (but possibly using its randomness), the algorithm decides whether to accept or reject the input. ==Features and limitations== The main efficiency parameter of a property testing algorithm is its query complexity, which is the maximum number of input symbols inspected over all inputs of a given length (and all random choices made by the algorithm). One is interested in designing algorithms whose query complexity is as small as possible. In many cases the running time of property testing algorithms is sublinear in the instance length. Typically, the goal is first to make the query complexity as small as possible as a function of the instance size n, and then study the dependency on the proximity parameter \u03b5. Unlike other complexity-theoretic settings, the asymptotic query complexity of property testing algorithms is affected dramatically by the representation of instances. For example, when \u03b5 = 0.01, the problem of testing bipartiteness of dense graphs (which are represented by their adjacency matrix) admits an algorithm of constant query complexity. In contrast, sparse graphs on n vertices (which are represented by their adjacency list) require property testing algorithms of query complexity \\Omega(\\sqrt{n}). The query complexity of property testing algorithms grows as the proximity parameter \u03b5 becomes smaller for all non-trivial properties. This dependence on \u03b5 is necessary as a change of fewer than \u03b5 symbols in the input cannot be detected with constant probability using fewer than O(1/\u03b5) queries. Many interesting properties of dense graphs can be tested using query complexity that depends only on \u03b5 and not on the graph size n. However, the query complexity can grow enormously fast as a function of \u03b5. For example, for a long time the best known algorithm for testing if a graph does not contain any triangle had a query complexity which is a tower function of poly(1/\u03b5), and only in 2010 this has been improved to a tower function of log(1/\u03b5). One of the reasons for this enormous growth in bounds is that many of the positive results for property testing of graphs are established using the Szemer\u00e9di regularity lemma, which also has tower-type bounds in its conclusions. The connection of property testing to the Szemer\u00e9di regularity lemma and related graph removal lemmas is elaborated on below. ==Property testing of graphs== For graphs with n vertices, the notion of distance we will use is the edit distance. That is, we say that the distance between two graphs is the smallest \u03b5 such that one can add and/or delete \\varepsilon n^2 edges and get from the first graph to the second. Under a reasonable representation of graphs, this is equivalent to the earlier Hamming distance definition (up to possibly a change of constants). For graphs, there is a characterization of which properties are easy to test. Namely, the properties that are easy to test are precisely those properties that are (almost) hereditary. These statements will be made clearer below. First of all, by a property being easy to test, we mean that it has an oblivious tester. === Oblivious testers === Informally, an oblivious tester for a graph property P is an algorithm that takes as input a parameter \u03b5 and graph G, and then runs as a property testing algorithm on G for the property P with proximity parameter \u03b5 that makes exactly q(\u03b5) queries to G. Crucially, the number of queries an oblivious tester makes is a constant only dependent on \u03b5. The formal definition is that an oblivious tester is an algorithm that takes as input a parameter \u03b5. It computes an integer q(\u03b5) and then asks an oracle for an induced subgraph H on exactly q(\u03b5) vertices from G chosen uniformly at random. It then accepts or rejects according to \u03b5 and H. As before, we say it tests for the property P if it accepts with probability at least \u2154 for G that has property P, and rejects with probability at least \u2154 or G that is \u03b5-far from having property P. In complete analogy with property testing algorithms, we can talk about oblivious testers with one-sided error. === Testing hereditary properties === A hereditary property is a property that is preserved under deletion of vertices. A few important hereditary properties are H-freeness (for some graph H), k-colorability, and planarity. All hereditary properties are testable, and there is a proof of this fact using a version of the graph removal lemma for infinite families of induced subgraphs. In fact, a rough converse of this is also true -- the properties that have oblivious testers with one-sided error are almost hereditary (Alon & Shapira 2008), in a sense which will not be made precise here. === Example: testing triangle-freeness === In this section, we will sketch a proof of the existence of an oblivious tester for triangle-freeness; this proof is an application of the triangle removal lemma. Sketch of proof: If a graph G is \u03b5-far from being triangle-free, then by the triangle removal lemma, there is a (computable) constant \\delta=\\delta(\\varepsilon) so that G has at least \\delta n^3 triangles. The oblivious tester samples q(\\varepsilon)=1/\\delta triples of vertices independently at random from the graph. It accepts if no triple of vertices induces a triangle, and rejects otherwise. * If G is triangle-free, then clearly this algorithm always accepts. * If G is \u03b5-far from being triangle-free, then a more than 6/\\delta fraction of the triples of vertices in G induce a triangle, and then it is not difficult to see that there is greater than \u2154 chance that the algorithm finds at least one triangle. Therefore, the algorithm above is an oblivious tester with one-sided error for triangle-freeness. ==References== * * * * * * Category:Approximation algorithms Category:Randomized algorithms Category:Theoretical computer science ",
    "title": "Property testing"
}