{
    "id": "51512079",
    "text": "The ABC software metric was introduced by Jerry Fitzpatrick in 1997 to overcome the drawbacks of the LOC. The metric defines an ABC score as a triplet of values that represent the size of a set of source code statements. An ABC score is calculated by counting the number of assignments (A), number of branches (B), and number of conditionals (C) in a program. ABC score can be applied to individual methods, functions, classes, modules or files within a program. ABC score is represented by a 3-D vector < Assignments (A), Branches (B), Conditionals (C) >. It can also be represented as a scalar value, which is the magnitude of the vector < Assignments (A), Branches (B), Conditionals (C) >, and is calculated as follows: ::|| = \\surd(A^2 + B^2 + C^2) By convention, an ABC magnitude value is rounded to the nearest tenth. == History == The concept of measuring software size was first introduced by Maurice Halstead from Purdue University in 1975. He suggested that every computer program consists mainly of tokens: operators and operands. He concluded that a count of the number of unique operators and operands gives us a measure of the size of the program. However, this was not adopted as a measure of the size of a program. Lines of code (LOC) was another popular measure of the size of a program. The LOC was not considered an accurate measure of the size of the program because even a program with identical functionality may have different numbers of lines depending on the style of coding. Another metric called the Function Point (FP) metric was introduced to calculate the number of user input and output transactions. The function point calculations did not give information about both the functionality of the program and about the routines that were involved in the program. The ABC metric is intended to overcome the drawbacks of the LOC, FP and token (operation and operand) counts. However, an FP score can also be used to supplement an ABC score. Though the author contends that the ABC metric measures size, some believe that it measures complexity. The ability of the ABC metric to measure complexity depends on how complexity is defined. == Definition == The three components of the ABC score are defined as following: * Assignment: storage or transfer of data into a variable. * Branches: an explicit forward program branch out of scope. * Conditionals: Boolean or logic test. Since basic languages such as C, C++, Java, etc. have operations like assignments of variables, function calls and test conditions only, the ABC score has these three components. If the ABC vector is denoted as <5,11,9> for a subroutine, it means that the subroutine has 5 assignments, 11 branches and 9 conditionals. For standardization purposes, the counts should be enclosed in angle brackets and written in the same order per the notation . It is often more convenient to compare source code sizes using a scalar value. The individual ABC counts are distinct so, per Jerry Fitzpatrick, we consider the three components to be orthogonal, allowing a scalar ABC magnitude to be computed as shown above. Scalar ABC scores lose some of the benefits of the vector. Instead of computing a vector magnitude, the weighted sum of the vectors may support more accurate size comparison. ABC scalar scores should not be presented without the accompanying ABC vectors, since the scalar values are not the complete representation of the size. == Theory == The specific rules for counting ABC vector values should be interpreted differently for different languages due to semantic differences between them. Therefore, the rules for calculating ABC vector slightly differ based on the language. We define the ABC metric calculation rules for C, C++ and Java below. Based on these rules the rules for other imperative languages can be interpreted. === ABC rules for C === The following rules give the count of Assignments, Branches, Conditionals in the ABC metric for C: # Add one to the assignment count when: #* Occurrence of an assignment operator (=, *=, /=, %=, +=, <<=, >>=, &=, !=, ^=). #* Occurrence of an increment or a decrement operator (++, --). # Add one to branch count when: #* Occurrence of a function call. #* Occurrence of any goto statement which has a target at a deeper level of nesting than the level to the goto. # Add one to condition count when: #* Occurrence of a conditional operator (<, >, <=, >=, ==, !=). #* Occurrence of the following keywords (\u2018else\u2019, \u2018case\u2019, \u2018default\u2019, \u2018?\u2019). #* Occurrence of a unary conditional operator. === ABC rules for C++ === The following rules give the count of Assignments, Branches, Conditionals in the ABC metric for C++: # Add one to the assignment count when: #* Occurrence of an assignment operator (exclude constant declarations and default parameter assignments) (=, *=, /=, %=, +=, <<=, >>=, &=, !=, ^=). #* Occurrence of an increment or a decrement operator (prefix or postfix) (++, --). #* Initialization of a variable or a nonconstant class member. # Add one to branch count when: #* Occurrence of a function call or a class method call. #* Occurrence of any goto statement which has a target at a deeper level of nesting than the level to the goto. #* Occurrence of \u2018new\u2019 or \u2018delete\u2019 operators. # Add one to condition count when: #* Occurrence of a conditional operator (<, >, <=, >=, ==, !=). #* Occurrence of the following keywords (\u2018else\u2019, \u2018case\u2019, \u2018default\u2019, \u2018?\u2019, \u2018try\u2019, \u2018catch\u2019). #* Occurrence of a unary conditional operator. === ABC rules for Java === The following rules give the count of Assignments, Branches, Conditionals in the ABC metric for Java: # Add one to the assignment count when: #* Occurrence of an assignment operator (exclude constant declarations and default parameter assignments) (=, *=, /=, %=, +=, <<=, >>=, &=, !=, ^=, >>>=). #* Occurrence of an increment or a decrement operator (prefix or postfix) (++, --). # Add one to branch count when #* Occurrence of a function call or a class method call. #* Occurrence of a \u2018new\u2019 operator. # Add one to condition count when: #* Occurrence of a conditional operator (<, >, <=, >=, ==, !=). #* Occurrence of the following keywords (\u2018else\u2019, \u2018case\u2019, \u2018default\u2019, \u2018?\u2019, \u2018try\u2019, \u2018catch\u2019). #* Occurrence of a unary conditional operator. == Applications == === Independent of style of coding === Since the ABC score metric is built on the idea that tasks like data storage, branching and conditional testing, this metric is independent of the user\u2019s style of coding. === Project time estimation === ABC score calculation helps in estimating the amount of time needed to complete a project. This can be done by roughly estimating the ABC score for the project, and by calculating the ABC score of the program in a particular day. The amount of time taken for the completion for the project can be obtained by dividing the ABC score of the project by the ABC score achieved in one day. === Bug rate calculation === The bug rate was originally calculated as Number of bugs / LOC. However, the LOC is not a reliable measure of the size of the program because it depends on the style of coding. A more accurate way of measuring bug rate is to count the - Number of bugs / ABC score. === Program comparison === Programs written in different languages can be compared with the help of ABC scores because most languages use assignments, branches and conditional statements. The information on the count of the individual parameters (number of assignments, branches and conditions) can help classify the program as \u2018data strong\u2019 or \u2018function strong\u2019 or \u2018logic strong\u2019. The vector form of an ABC score can provide insight into the driving principles behind the application, whereas the details are lost in the scalar form of the score. === Linear metric === ABC scores are linear, so any file, module, class, function or method can be scored. For example, the (vector) ABC score for a module is the sum of the scores of its sub-modules. Scalar ABC scores, however, are non-linear. == See also == * Software complexity * Halstead complexity measures * Cyclomatic complexity * Synchronization complexity * Software metric == References == == External links == * Applying the ABC Metric to C, C++, and Java * ABC Metric * Size and Complexity Rules * Deciphering Ruby Code Metrics * The ABC metric Category:Software engineering ",
    "title": "ABC Software Metric"
}