{
    "id": "303031",
    "text": "Information Processing Language (IPL) is a programming language created by Allen Newell, Cliff Shaw, and Herbert A. Simon at RAND Corporation and the Carnegie Institute of Technology about 1956. Newell had the job of language specifier-application programmer, Shaw was the system programmer, and Simon had the job of application programmer-user. The code includes features intended to help with programs that perform simple problem solving actions such as lists, dynamic memory allocation, data types, recursion, functions as arguments, generators, and cooperative multitasking. IPL invented the concept of list processing, albeit in an assembly-language style. ==Basics of IPL== An IPL computer has: # A set of symbols. All symbols are addresses, and name cells. Unlike symbols in later languages, symbols consist of a character followed by a number, and are written H1, A29, 9-7, 9-100. ## Cell names beginning with a letter are regional, and are absolute addresses. ## Cell names beginning with \"9-\" are local, and are meaningful within the context of a single list. One list's 9-1 is independent of another list's 9-1. ## Other symbols (e.g., pure numbers) are internal. # A set of cells. Lists are made from several cells including mutual references. Cells have several fields: ## P, a 3-bit field used for an operation code when the cell is used as an instruction, and unused when the cell is data. ## Q, a 3-valued field used for indirect reference when the cell is used as an instruction, and unused when the cell is data. ## SYMB, a symbol used as the value in the cell. # A set of primitive processes, which would be termed primitive functions in modern languages. The data structure of IPL is the list, but lists are more intricate structures than in many languages. A list consists of a singly linked sequence of symbols, as might be expected\u2014plus some description lists, which are subsidiary singly linked lists interpreted as alternating attribute names and values. IPL provides primitives to access and mutate attribute value by name. The description lists are given local names (of the form 9-1). So, a list named L1 containing the symbols S4 and S5, and described by associating value V1 to attribute A1 and V2 to A2, would be stored as follows. 0 indicates the end of a list; the cell names 100, 101, etc. are automatically generated internal symbols whose values are irrelevant. These cells can be scattered throughout memory; only L1, which uses a regional name that must be globally known, needs to reside in a specific place. {|style=\"font-family:monospace; margin: 1em auto\" |+ IPL-V List Structure Example |- !Name !! SYMB !! LINK |- |L1 || 9-1 || 100 |- |100 || S4 || 101 |- |101 || S5 || 0 |- |9-1 || 0 || 200 |- |200 || A1 || 201 |- |201 || V1 || 202 |- |202 || A2 || 203 |- |203 || V2 || 0 |} IPL is an assembly language for manipulating lists. It has a few cells which are used as special-purpose registers. H1, for example, is the program counter. The SYMB field of H1 is the name of the current instruction. However, H1 is interpreted as a list; the LINK of H1 is, in modern terms, a pointer to the beginning of the call stack. For example, subroutine calls push the SYMB of H1 onto this stack. H2 is the free-list. Procedures which need to allocate memory grab cells off of H2; procedures which are finished with memory put it on H2. On entry to a function, the list of parameters is given in H0; on exit, the results should be returned in H0. Many procedures return a boolean result indicating success or failure, which is put in H5. Ten cells, W0-W9, are reserved for public working storage. Procedures are \"morally bound\" (to quote the CACM article) to save and restore the values of these cells. There are eight instructions, based on the values of P: subroutine call, push/pop S to H0; push/pop the symbol in S to the list attached to S; copy value to S; conditional branch. In these instructions, S is the target. S is either the value of the SYMB field if Q=0, the symbol in the cell named by SYMB if Q=1, or the symbol in the cell named by the symbol in the cell named by SYMB if Q=2. In all cases but conditional branch, the LINK field of the cell tells which instruction to execute next. IPL has a library of some 150 basic operations. These include such operations as: * Test symbols for equality * Find, set, or erase an attribute of a list * locate the next symbol in a list; insert a symbol in a list; erase or copy an entire list. * Arithmetic operations (on symbol names). * Manipulation of symbols; e.g., test if a symbol denotes an integer, or make a symbol local. * I/O operations * \"generators\", which correspond to iterators and filters in functional programming. For example, a generator may accept a list of numbers and produce the list of their squares. Generators could accept suitably designed functions\u2014strictly, the addresses of code of suitably designed functions\u2014as arguments. == History == IPL was first utilized to demonstrate that the theorems in Principia Mathematica which were proven laboriously by hand, by Bertrand Russell and Alfred North Whitehead, could in fact be proven by computation. According to Simon's autobiography Models of My Life, this application was originally developed first by hand simulation, using his children as the computing elements, while writing on and holding up note cards as the registers which contained the state variables of the program. IPL was used to implement several early artificial intelligence programs, also by the same authors: the Logic Theorist (1956), the General Problem Solver (1957), and their computer chess program NSS (1958). Several versions of IPL were created: IPL-I (never implemented), IPL-II (1957 for JOHNNIAC), IPL-III (existed briefly), IPL-IV, IPL-V (1958, for IBM 650, IBM 704, IBM 7090, Philco model 212, many others. Widely used), IPL-VI. However the language was soon displaced by Lisp, which had much more powerful features, a simpler syntax, and the benefit of automatic garbage collection. == Legacy to computer programming == IPL arguably introduced several programming language features: * List manipulation\u2014but only lists of atoms, not general lists. * Property lists\u2014but only when attached to other lists. * Higher-order functions\u2014except that assembly programming has always been able to compute with addresses of functions to call; IPL was an early attempt to generalize this property of assembly language and in a principled way * Computation with symbols\u2014except that the symbols are letter+number, not full words. * Virtual machine. Many of these features were generalized, rationalized, and incorporated into LispJohn McCarthy (1979) History of Lisp \"LISP prehistory - Summer 1956 through Summer 1958.\" and from there into many other programming languages during the next several decades. ==References== ==Sources== * ==Further reading== *Newell, A. and F.C. Shaw. \"Programming the Logic Theory Machine.\" Feb. 1957. Proceedings of the Western Joint Computer Conference, pp. 230-240. *Newell, Allen, and Fred M. Tonge. 1960. \"An Introduction to Information Processing Language V.\" CACM 3(4): 205-211. *Newell, Allen. 1964. Information Processing Language-V Manual; Second Edition. Rand Corporation [Allen Newell], Englewood Cliffs, NJ: Prentice-Hall. *Samuel, Arthur L.: Programming Computers to Play Games. In: Advances in Computers, Vol. 1, 1960, pp 165-192 (esp.: 171-175). ==External links== * Allen Newell, \"Biographical Memoirs\", National Academy of Sciences (includes a short section on IPL) * IPL documents from BitSavers * Influence of IPL on LISP Category:Procedural programming languages Category:History of artificial intelligence Category:Programming languages created in 1956 ",
    "title": "Information Processing Language"
}