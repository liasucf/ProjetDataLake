{
    "id": "7789356",
    "text": "In the C++ programming language, the assignment operator, `=`, is the operator used for assignment. Like most other operators in C++, it can be overloaded. The copy assignment operator, often just called the \"assignment operator\", is a special case of assignment operator where the source (right-hand side) and destination (left-hand side) are of the same class type. It is one of the special member functions, which means that a default version of it is generated automatically by the compiler if the programmer does not declare one. The default version performs a memberwise copy, where each member is copied by its own copy assignment operator (which may also be programmer- declared or compiler-generated). The copy assignment operator differs from the copy constructor in that it must clean up the data members of the assignment's target (and correctly handle self-assignment) whereas the copy constructor assigns values to uninitialized data members. For example: My_Array first; // initialization by default constructor My_Array second(first); // initialization by copy constructor My_Array third = first; // Also initialization by copy constructor second = third; // assignment by copy assignment operator ==Return value of overloaded assignment operator== The language permits an overloaded assignment operator to have an arbitrary return type (including `void`). However, the operator is usually defined to return a reference to the assignee. This is consistent with the behavior of assignment operator for built-in types (returning the assigned value) and allows for using the operator invocation as an expression, for instance in control statements or in chained assignment. Also, the C++ Standard Library requires this behavior for some user-supplied types.Working Draft, Standard for Programming Language C++, Section 17.6.3.1, Table 23; http://www.open- std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf ==Overloading copy assignment operator== When deep copies of objects have to be made, exception safety should be taken into consideration. One way to achieve this when resource deallocation never fails is: # Acquire new resources # Release old resources # Assign the new resources' handles to the object class My_Array{ int* array; int count; public: My_Array& operator=(const My_Array& other) { if (this != &other;) { // protect against invalid self-assignment // 1: allocate new memory and copy the elements int* new_array = new int[other.count]; std::copy(other.array, other.array + other.count, new_array); // 2: deallocate old memory delete[] array; // 3: assign the new memory to the object array = new_array; count = other.count; } // by convention, always return *this return *this; } // ... }; However, if a no-fail (no-throw) swap function is available for all the member subobjects and the class provides a copy constructor and destructor (which it should do according to the rule of three), the most straightforward way to implement copy assignment is as follows: public: void swap(My_Array & other) // the swap member function (should never fail!) { // swap all the members (and base subobject, if applicable) with other using std::swap; // because of ADL the compiler will use // custom swap for members if it exists // falling back to std::swap swap(array, other.array); swap(count, other.count); } My_Array & operator = (My_Array other) // note: argument passed by value! { // swap this with other swap(other); // by convention, always return *this return *this; // other is destroyed, releasing the memory } ==Assignment between different classes== C++ supports assignment between different classes, both via implicit copy constructor and assignment operator, if the destination instance class is the ancestor of the source instance class: class Ancestor { public: int a; }; class Descendant : public Ancestor { public: int b; }; int main() { Descendant d; Ancestor a(d); Ancestor b(d); a = d; } Copying from ancestor to descendant objects, which could leave descendant's fields uninitialized, is not permitted. ==See also== *Operator overloading *Rule of three (C++ programming) *Operators in C and C++ ==References== ==External links== * The Anatomy of the Assignment Operator, by Richard Gillam Category:C++ Category:Operators (programming) Category:Assignment operations ",
    "title": "Assignment operator (C++)"
}