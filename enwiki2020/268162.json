{
    "id": "268162",
    "text": "A perfect hash function for the four names shown A minimal perfect hash function for the four names shown In computer science, a perfect hash function for a set is a hash function that maps distinct elements in to a set of integers, with no collisions. In mathematical terms, it is an injective function. Perfect hash functions may be used to implement a lookup table with constant worst-case access time. A perfect hash function has many of the same applications as other hash functions, but with the advantage that no collision resolution has to be implemented. In addition, if the keys are not the data, the keys do not need to be stored in the lookup table, saving space. ==Application== A perfect hash function with values in a limited range can be used for efficient lookup operations, by placing keys from (or other associated values) in a lookup table indexed by the output of the function. One can then test whether a key is present in , or look up a value associated with that key, by looking for it at its cell of the table. Each such lookup takes constant time in the worst case. ==Construction== A perfect hash function for a specific set that can be evaluated in constant time, and with values in a small range, can be found by a randomized algorithm in a number of operations that is proportional to the size of S. The original construction of uses a two-level scheme to map a set of elements to a range of indices, and then map each index to a range of hash values. The first level of their construction chooses a large prime (larger than the size of the universe from which is drawn), and a parameter , and maps each element of to the index :g(x)=(kx\\bmod p)\\bmod n. If is chosen randomly, this step is likely to have collisions, but the number of elements that are simultaneously mapped to the same index is likely to be small. The second level of their construction assigns disjoint ranges of integers to each index . It uses a second set of linear modular functions, one for each index , to map each member of into the range associated with . As show, there exists a choice of the parameter such that the sum of the lengths of the ranges for the different values of is . Additionally, for each value of , there exists a linear modular function that maps the corresponding subset of into the range associated with that value. Both , and the second-level functions for each value of , can be found in polynomial time by choosing values randomly until finding one that works. The hash function itself requires storage space to store , , and all of the second-level linear modular functions. Computing the hash value of a given key may be performed in constant time by computing , looking up the second-level function associated with , and applying this function to . A modified version of this two-level scheme with a larger number of values at the top level can be used to construct a perfect hash function that maps into a smaller range of length . ==Space lower bounds== The use of words of information to store the function of is near-optimal: any perfect hash function that can be calculated in constant time requires at least a number of bits that is proportional to the size of .. ==Extensions== ===Dynamic perfect hashing=== Using a perfect hash function is best in situations where there is a frequently queried large set, , which is seldom updated. This is because any modification of the set may cause the hash function to no longer be perfect for the modified set. Solutions which update the hash function any time the set is modified are known as dynamic perfect hashing,. but these methods are relatively complicated to implement. ===Minimal perfect hash function=== A minimal perfect hash function is a perfect hash function that maps keys to consecutive integers \u2013 usually the numbers from to or from to . A more formal way of expressing this is: Let and be elements of some finite set . Then is a minimal perfect hash function if and only if implies (injectivity) and there exists an integer such that the range of is . It has been proven that a general purpose minimal perfect hash scheme requires at least 1.44 bits/key.. The best currently known minimal perfect hashing schemes can be represented using less than 1.56 bits/key if given enough time. . ===Order preservation=== A minimal perfect hash function is order preserving if keys are given in some order and for any keys and , implies . In this case, the function value is just the position of each key in the sorted ordering of all of the keys. A simple implementation of order-preserving minimal perfect hash functions with constant access time is to use an (ordinary) perfect hash function or cuckoo hashing to store a lookup table of the positions of each key. If the keys to be hashed are themselves stored in a sorted array, it is possible to store a small number of additional bits per key in a data structure that can be used to compute hash values quickly.. Order-preserving minimal perfect hash functions require necessarily bits to be represented.. ==Related constructions== A simple alternative to perfect hashing, which also allows dynamic updates, is cuckoo hashing. This scheme maps keys to two or more locations within a range (unlike perfect hashing which maps each key to a single location) but does so in such a way that the keys can be assigned one- to-one to locations to which they have been mapped. Lookups with this scheme are slower, because multiple locations must be checked, but nevertheless take constant worst-case time.. == References == == Further reading == *Richard J. Cichelli. Minimal Perfect Hash Functions Made Simple, Communications of the ACM, Vol. 23, Number 1, January 1980. * Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Third Edition. MIT Press, 2009. . Section 11.5: Perfect hashing, pp.267, 277-282\\. * Fabiano C. Botelho, Rasmus Pagh and Nivio Ziviani. \"Perfect Hashing for Data Management Applications\". * Fabiano C. Botelho and Nivio Ziviani. \"External perfect hashing for very large key sets\". 16th ACM Conference on Information and Knowledge Management (CIKM07), Lisbon, Portugal, November 2007. * Djamal Belazzougui, Paolo Boldi, Rasmus Pagh, and Sebastiano Vigna. \"Monotone minimal perfect hashing: Searching a sorted table with O(1) accesses\". In Proceedings of the 20th Annual ACM-SIAM Symposium On Discrete Mathematics (SODA), New York, 2009. ACM Press. * Douglas C. Schmidt, GPERF: A Perfect Hash Function Generator, C++ Report, SIGS, Vol. 10, No. 10, November/December, 1998. == External links == *gperf is an Open Source C and C++ perfect hash generator (very fast, but only works for small sets) *Minimal Perfect Hashing (bob algorithm) by Bob Jenkins *cmph: C Minimal Perfect Hashing Library, open source implementations for many (minimal) perfect hashes (works for big sets) *Sux4J: open source monotone minimal perfect hashing in Java *MPHSharp: perfect hashing methods in C# *BBHash: minimal perfect hash function in header-only C++ *Perfect::Hash, perfect hash generator in Perl that makes C code. Has a \"prior art\" section worth looking at. Category:Hashing Category:Hash functions Category:Search algorithms ",
    "title": "Perfect hash function"
}